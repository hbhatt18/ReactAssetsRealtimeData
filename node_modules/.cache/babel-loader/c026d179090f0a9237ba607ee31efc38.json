{"ast":null,"code":"\"use strict\";\n\nvar ArrayObservable_1 = require('../observable/ArrayObservable');\n\nvar ScalarObservable_1 = require('../observable/ScalarObservable');\n\nvar EmptyObservable_1 = require('../observable/EmptyObservable');\n\nvar concat_1 = require('../observable/concat');\n\nvar isScheduler_1 = require('../util/isScheduler');\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits the items you specify as arguments before it begins to emit\n * items emitted by the source Observable.\n *\n * <img src=\"./img/startWith.png\" width=\"100%\">\n *\n * @param {...T} values - Items you want the modified Observable to emit first.\n * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling\n * the emissions of the `next` notifications.\n * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items\n * emitted by the source Observable.\n * @method startWith\n * @owner Observable\n */\n\n\nfunction startWith() {\n  var array = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    array[_i - 0] = arguments[_i];\n  }\n\n  return function (source) {\n    var scheduler = array[array.length - 1];\n\n    if (isScheduler_1.isScheduler(scheduler)) {\n      array.pop();\n    } else {\n      scheduler = null;\n    }\n\n    var len = array.length;\n\n    if (len === 1) {\n      return concat_1.concat(new ScalarObservable_1.ScalarObservable(array[0], scheduler), source);\n    } else if (len > 1) {\n      return concat_1.concat(new ArrayObservable_1.ArrayObservable(array, scheduler), source);\n    } else {\n      return concat_1.concat(new EmptyObservable_1.EmptyObservable(scheduler), source);\n    }\n  };\n}\n\nexports.startWith = startWith;","map":{"version":3,"sources":["../../src/operators/startWith.ts"],"names":[],"mappings":";;AAEA,IAAA,iBAAA,GAAA,OAAA,CAAgC,+BAAhC,CAAA;;AACA,IAAA,kBAAA,GAAA,OAAA,CAAiC,gCAAjC,CAAA;;AACA,IAAA,iBAAA,GAAA,OAAA,CAAgC,+BAAhC,CAAA;;AACA,IAAA,QAAA,GAAA,OAAA,CAAuC,sBAAvC,CAAA;;AACA,IAAA,aAAA,GAAA,OAAA,CAA4B,qBAA5B,CAAA;AAWA;;AAEA;;;;;;;;;;;;;;;;AAcA,SAAA,SAAA,GAAA;AAA6B,MAAA,KAAA,GAAA,EAAA;;OAAA,IAAA,EAAA,GAAA,C,EAAA,EAAA,GAAA,SAAA,CAAA,M,EAAA,EAAA,E,EAA+B;AAA/B,IAAA,KAAA,CAAA,EAAA,GAAA,CAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;;AAC3B,SAAO,UAAC,MAAD,EAAsB;AAC3B,QAAI,SAAS,GAAe,KAAK,CAAC,KAAK,CAAC,MAAN,GAAe,CAAhB,CAAjC;;AACA,QAAI,aAAA,CAAA,WAAA,CAAY,SAAZ,CAAJ,EAA4B;AAC1B,MAAA,KAAK,CAAC,GAAN;AACD,KAFD,MAEO;AACL,MAAA,SAAS,GAAG,IAAZ;AACD;;AAED,QAAM,GAAG,GAAG,KAAK,CAAC,MAAlB;;AACA,QAAI,GAAG,KAAK,CAAZ,EAAe;AACb,aAAO,QAAA,CAAA,MAAA,CAAa,IAAI,kBAAA,CAAA,gBAAJ,CAA2B,KAAK,CAAC,CAAD,CAAhC,EAAqC,SAArC,CAAb,EAA8D,MAA9D,CAAP;AACD,KAFD,MAEO,IAAI,GAAG,GAAG,CAAV,EAAa;AAClB,aAAO,QAAA,CAAA,MAAA,CAAa,IAAI,iBAAA,CAAA,eAAJ,CAA4B,KAA5B,EAAmC,SAAnC,CAAb,EAA4D,MAA5D,CAAP;AACD,KAFM,MAEA;AACL,aAAO,QAAA,CAAA,MAAA,CAAa,IAAI,iBAAA,CAAA,eAAJ,CAAuB,SAAvB,CAAb,EAAgD,MAAhD,CAAP;AACD;AACF,GAhBD;AAiBD;;AAlBe,OAAA,CAAA,SAAA,GAAS,SAAT","sourcesContent":["import { IScheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { ArrayObservable } from '../observable/ArrayObservable';\nimport { ScalarObservable } from '../observable/ScalarObservable';\nimport { EmptyObservable } from '../observable/EmptyObservable';\nimport { concat as concatStatic } from '../observable/concat';\nimport { isScheduler } from '../util/isScheduler';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function startWith<T>(v1: T, scheduler?: IScheduler): MonoTypeOperatorFunction<T>;\nexport function startWith<T>(v1: T, v2: T, scheduler?: IScheduler): MonoTypeOperatorFunction<T>;\nexport function startWith<T>(v1: T, v2: T, v3: T, scheduler?: IScheduler): MonoTypeOperatorFunction<T>;\nexport function startWith<T>(v1: T, v2: T, v3: T, v4: T, scheduler?: IScheduler): MonoTypeOperatorFunction<T>;\nexport function startWith<T>(v1: T, v2: T, v3: T, v4: T, v5: T, scheduler?: IScheduler): MonoTypeOperatorFunction<T>;\nexport function startWith<T>(v1: T, v2: T, v3: T, v4: T, v5: T, v6: T, scheduler?: IScheduler): MonoTypeOperatorFunction<T>;\nexport function startWith<T>(...array: Array<T | IScheduler>): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits the items you specify as arguments before it begins to emit\n * items emitted by the source Observable.\n *\n * <img src=\"./img/startWith.png\" width=\"100%\">\n *\n * @param {...T} values - Items you want the modified Observable to emit first.\n * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling\n * the emissions of the `next` notifications.\n * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items\n * emitted by the source Observable.\n * @method startWith\n * @owner Observable\n */\nexport function startWith<T>(...array: Array<T | IScheduler>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => {\n    let scheduler = <IScheduler>array[array.length - 1];\n    if (isScheduler(scheduler)) {\n      array.pop();\n    } else {\n      scheduler = null;\n    }\n\n    const len = array.length;\n    if (len === 1) {\n      return concatStatic(new ScalarObservable<T>(<T>array[0], scheduler), source);\n    } else if (len > 1) {\n      return concatStatic(new ArrayObservable<T>(<T[]>array, scheduler), source);\n    } else {\n      return concatStatic(new EmptyObservable<T>(scheduler), source);\n    }\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}