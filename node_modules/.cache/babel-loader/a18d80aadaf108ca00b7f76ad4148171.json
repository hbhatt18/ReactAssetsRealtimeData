{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Observable_1 = require('../Observable');\n\nfunction dispatch(state) {\n  var obj = state.obj,\n      keys = state.keys,\n      length = state.length,\n      index = state.index,\n      subscriber = state.subscriber;\n\n  if (index === length) {\n    subscriber.complete();\n    return;\n  }\n\n  var key = keys[index];\n  subscriber.next([key, obj[key]]);\n  state.index = index + 1;\n  this.schedule(state);\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar PairsObservable = function (_super) {\n  __extends(PairsObservable, _super);\n\n  function PairsObservable(obj, scheduler) {\n    _super.call(this);\n\n    this.obj = obj;\n    this.scheduler = scheduler;\n    this.keys = Object.keys(obj);\n  }\n  /**\n   * Convert an object into an observable sequence of [key, value] pairs\n   * using an optional IScheduler to enumerate the object.\n   *\n   * @example <caption>Converts a javascript object to an Observable</caption>\n   * var obj = {\n   *   foo: 42,\n   *   bar: 56,\n   *   baz: 78\n   * };\n   *\n   * var source = Rx.Observable.pairs(obj);\n   *\n   * var subscription = source.subscribe(\n   *   function (x) {\n   *     console.log('Next: %s', x);\n   *   },\n   *   function (err) {\n   *     console.log('Error: %s', err);\n   *   },\n   *   function () {\n   *     console.log('Completed');\n   *   });\n   *\n   * @param {Object} obj The object to inspect and turn into an\n   * Observable sequence.\n   * @param {Scheduler} [scheduler] An optional IScheduler to run the\n   * enumeration of the input sequence on.\n   * @returns {(Observable<Array<string | T>>)} An observable sequence of\n   * [key, value] pairs from the object.\n   */\n\n\n  PairsObservable.create = function (obj, scheduler) {\n    return new PairsObservable(obj, scheduler);\n  };\n  /** @deprecated internal use only */\n\n\n  PairsObservable.prototype._subscribe = function (subscriber) {\n    var _a = this,\n        keys = _a.keys,\n        scheduler = _a.scheduler;\n\n    var length = keys.length;\n\n    if (scheduler) {\n      return scheduler.schedule(dispatch, 0, {\n        obj: this.obj,\n        keys: keys,\n        length: length,\n        index: 0,\n        subscriber: subscriber\n      });\n    } else {\n      for (var idx = 0; idx < length; idx++) {\n        var key = keys[idx];\n        subscriber.next([key, this.obj[key]]);\n      }\n\n      subscriber.complete();\n    }\n  };\n\n  return PairsObservable;\n}(Observable_1.Observable);\n\nexports.PairsObservable = PairsObservable;","map":{"version":3,"sources":["../../src/observable/PairsObservable.ts"],"names":[],"mappings":";;;;;;;;;;;;AAEA,IAAA,YAAA,GAAA,OAAA,CAA2B,eAA3B,CAAA;;AAYA,SAAA,QAAA,CAAoD,KAApD,EAA0E;AACjE,MAAA,GAAA,GAAA,KAAA,CAAA,GAAA;AAAA,MAAK,IAAA,GAAA,KAAA,CAAA,IAAL;AAAA,MAAW,MAAA,GAAA,KAAA,CAAA,MAAX;AAAA,MAAmB,KAAA,GAAA,KAAA,CAAA,KAAnB;AAAA,MAA0B,UAAA,GAAA,KAAA,CAAA,UAA1B;;AAEP,MAAI,KAAK,KAAK,MAAd,EAAsB;AACpB,IAAA,UAAU,CAAC,QAAX;AACA;AACD;;AAED,MAAM,GAAG,GAAG,IAAI,CAAC,KAAD,CAAhB;AACA,EAAA,UAAU,CAAC,IAAX,CAAgB,CAAC,GAAD,EAAM,GAAG,CAAC,GAAD,CAAT,CAAhB;AAEA,EAAA,KAAK,CAAC,KAAN,GAAc,KAAK,GAAG,CAAtB;AAEA,OAAK,QAAL,CAAc,KAAd;AACD;AAED;;;;;;;AAKA,IAAA,eAAA,GAAA,UAAA,MAAA,EAAA;AAAwC,EAAA,SAAA,CAAA,eAAA,EAAA,MAAA,CAAA;;AAsCtC,WAAA,eAAA,CAAoB,GAApB,EAAyC,SAAzC,EAA+D;AAC7D,IAAA,MAAA,CAAA,IAAA,CAAA,IAAA;;AADkB,SAAA,GAAA,GAAA,GAAA;AAAqB,SAAA,SAAA,GAAA,SAAA;AAEvC,SAAK,IAAL,GAAY,MAAM,CAAC,IAAP,CAAY,GAAZ,CAAZ;AACD;AAtCD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BO,EAAA,eAAA,CAAA,MAAA,GAAP,UAAiB,GAAjB,EAA8B,SAA9B,EAAoD;AAClD,WAAO,IAAI,eAAJ,CAAuB,GAAvB,EAA4B,SAA5B,CAAP;AACD,GAFM;AASP;;;AAAqC,EAAA,eAAA,CAAA,SAAA,CAAA,UAAA,GAAA,UAAW,UAAX,EAAoD;AACvF,QAAA,EAAA,GAAA,IAAA;AAAA,QAAO,IAAA,GAAA,EAAA,CAAA,IAAP;AAAA,QAAa,SAAA,GAAA,EAAA,CAAA,SAAb;;AACA,QAAM,MAAM,GAAG,IAAI,CAAC,MAApB;;AAEA,QAAI,SAAJ,EAAe;AACb,aAAO,SAAS,CAAC,QAAV,CAAmB,QAAnB,EAA6B,CAA7B,EAAgC;AACrC,QAAA,GAAG,EAAE,KAAK,GAD2B;AACtB,QAAA,IAAA,EAAA,IADsB;AAChB,QAAA,MAAA,EAAA,MADgB;AACR,QAAA,KAAK,EAAE,CADC;AACE,QAAA,UAAA,EAAA;AADF,OAAhC,CAAP;AAGD,KAJD,MAIO;AACL,WAAK,IAAI,GAAG,GAAG,CAAf,EAAkB,GAAG,GAAG,MAAxB,EAAgC,GAAG,EAAnC,EAAuC;AACrC,YAAM,GAAG,GAAG,IAAI,CAAC,GAAD,CAAhB;AACA,QAAA,UAAU,CAAC,IAAX,CAAgB,CAAC,GAAD,EAAM,KAAK,GAAL,CAAS,GAAT,CAAN,CAAhB;AACD;;AACD,MAAA,UAAU,CAAC,QAAX;AACD;AACF,GAfoC;;AAgBvC,SAAA,eAAA;AAAC,CA3DD,CAAwC,YAAA,CAAA,UAAxC,CAAA;;AAAa,OAAA,CAAA,eAAA,GAAe,eAAf","sourcesContent":["import { IScheduler } from '../Scheduler';\r\nimport { Action } from '../scheduler/Action';\r\nimport { Observable } from '../Observable';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { TeardownLogic } from '../Subscription';\r\n\r\ninterface PairsContext<T> {\r\n  obj: Object;\r\n  keys: Array<string>;\r\n  length: number;\r\n  index: number;\r\n  subscriber: Subscriber<Array<string | T>>;\r\n}\r\n\r\nfunction dispatch<T>(this: Action<PairsContext<T>>, state: PairsContext<T>) {\r\n  const {obj, keys, length, index, subscriber} = state;\r\n\r\n  if (index === length) {\r\n    subscriber.complete();\r\n    return;\r\n  }\r\n\r\n  const key = keys[index];\r\n  subscriber.next([key, obj[key]]);\r\n\r\n  state.index = index + 1;\r\n\r\n  this.schedule(state);\r\n}\r\n\r\n/**\r\n * We need this JSDoc comment for affecting ESDoc.\r\n * @extends {Ignored}\r\n * @hide true\r\n */\r\nexport class PairsObservable<T> extends Observable<Array<string | T>> {\r\n  private keys: Array<string>;\r\n\r\n  /**\r\n   * Convert an object into an observable sequence of [key, value] pairs\r\n   * using an optional IScheduler to enumerate the object.\r\n   *\r\n   * @example <caption>Converts a javascript object to an Observable</caption>\r\n   * var obj = {\r\n   *   foo: 42,\r\n   *   bar: 56,\r\n   *   baz: 78\r\n   * };\r\n   *\r\n   * var source = Rx.Observable.pairs(obj);\r\n   *\r\n   * var subscription = source.subscribe(\r\n   *   function (x) {\r\n   *     console.log('Next: %s', x);\r\n   *   },\r\n   *   function (err) {\r\n   *     console.log('Error: %s', err);\r\n   *   },\r\n   *   function () {\r\n   *     console.log('Completed');\r\n   *   });\r\n   *\r\n   * @param {Object} obj The object to inspect and turn into an\r\n   * Observable sequence.\r\n   * @param {Scheduler} [scheduler] An optional IScheduler to run the\r\n   * enumeration of the input sequence on.\r\n   * @returns {(Observable<Array<string | T>>)} An observable sequence of\r\n   * [key, value] pairs from the object.\r\n   */\r\n  static create<T>(obj: Object, scheduler?: IScheduler): Observable<Array<string | T>> {\r\n    return new PairsObservable<T>(obj, scheduler);\r\n  }\r\n\r\n  constructor(private obj: Object, private scheduler?: IScheduler) {\r\n    super();\r\n    this.keys = Object.keys(obj);\r\n  }\r\n\r\n  /** @deprecated internal use only */ _subscribe(subscriber: Subscriber<Array<string | T>>): TeardownLogic {\r\n    const {keys, scheduler} = this;\r\n    const length = keys.length;\r\n\r\n    if (scheduler) {\r\n      return scheduler.schedule(dispatch, 0, {\r\n        obj: this.obj, keys, length, index: 0, subscriber\r\n      });\r\n    } else {\r\n      for (let idx = 0; idx < length; idx++) {\r\n        const key = keys[idx];\r\n        subscriber.next([key, this.obj[key]]);\r\n      }\r\n      subscriber.complete();\r\n    }\r\n  }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}