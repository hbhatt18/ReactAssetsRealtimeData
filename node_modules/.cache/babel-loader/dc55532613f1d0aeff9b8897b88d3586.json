{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar isNumeric_1 = require('../util/isNumeric');\n\nvar Observable_1 = require('../Observable');\n\nvar async_1 = require('../scheduler/async');\n\nvar isScheduler_1 = require('../util/isScheduler');\n\nvar isDate_1 = require('../util/isDate');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar TimerObservable = function (_super) {\n  __extends(TimerObservable, _super);\n\n  function TimerObservable(dueTime, period, scheduler) {\n    if (dueTime === void 0) {\n      dueTime = 0;\n    }\n\n    _super.call(this);\n\n    this.period = -1;\n    this.dueTime = 0;\n\n    if (isNumeric_1.isNumeric(period)) {\n      this.period = Number(period) < 1 && 1 || Number(period);\n    } else if (isScheduler_1.isScheduler(period)) {\n      scheduler = period;\n    }\n\n    if (!isScheduler_1.isScheduler(scheduler)) {\n      scheduler = async_1.async;\n    }\n\n    this.scheduler = scheduler;\n    this.dueTime = isDate_1.isDate(dueTime) ? +dueTime - this.scheduler.now() : dueTime;\n  }\n  /**\n   * Creates an Observable that starts emitting after an `initialDelay` and\n   * emits ever increasing numbers after each `period` of time thereafter.\n   *\n   * <span class=\"informal\">Its like {@link interval}, but you can specify when\n   * should the emissions start.</span>\n   *\n   * <img src=\"./img/timer.png\" width=\"100%\">\n   *\n   * `timer` returns an Observable that emits an infinite sequence of ascending\n   * integers, with a constant interval of time, `period` of your choosing\n   * between those emissions. The first emission happens after the specified\n   * `initialDelay`. The initial delay may be a {@link Date}. By default, this\n   * operator uses the `async` IScheduler to provide a notion of time, but you\n   * may pass any IScheduler to it. If `period` is not specified, the output\n   * Observable emits only one value, `0`. Otherwise, it emits an infinite\n   * sequence.\n   *\n   * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>\n   * var numbers = Rx.Observable.timer(3000, 1000);\n   * numbers.subscribe(x => console.log(x));\n   *\n   * @example <caption>Emits one number after five seconds</caption>\n   * var numbers = Rx.Observable.timer(5000);\n   * numbers.subscribe(x => console.log(x));\n   *\n   * @see {@link interval}\n   * @see {@link delay}\n   *\n   * @param {number|Date} initialDelay The initial delay time to wait before\n   * emitting the first value of `0`.\n   * @param {number} [period] The period of time between emissions of the\n   * subsequent numbers.\n   * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\n   * the emission of values, and providing a notion of \"time\".\n   * @return {Observable} An Observable that emits a `0` after the\n   * `initialDelay` and ever increasing numbers after each `period` of time\n   * thereafter.\n   * @static true\n   * @name timer\n   * @owner Observable\n   */\n\n\n  TimerObservable.create = function (initialDelay, period, scheduler) {\n    if (initialDelay === void 0) {\n      initialDelay = 0;\n    }\n\n    return new TimerObservable(initialDelay, period, scheduler);\n  };\n\n  TimerObservable.dispatch = function (state) {\n    var index = state.index,\n        period = state.period,\n        subscriber = state.subscriber;\n    var action = this;\n    subscriber.next(index);\n\n    if (subscriber.closed) {\n      return;\n    } else if (period === -1) {\n      return subscriber.complete();\n    }\n\n    state.index = index + 1;\n    action.schedule(state, period);\n  };\n  /** @deprecated internal use only */\n\n\n  TimerObservable.prototype._subscribe = function (subscriber) {\n    var index = 0;\n\n    var _a = this,\n        period = _a.period,\n        dueTime = _a.dueTime,\n        scheduler = _a.scheduler;\n\n    return scheduler.schedule(TimerObservable.dispatch, dueTime, {\n      index: index,\n      period: period,\n      subscriber: subscriber\n    });\n  };\n\n  return TimerObservable;\n}(Observable_1.Observable);\n\nexports.TimerObservable = TimerObservable;","map":{"version":3,"sources":["../../src/observable/TimerObservable.ts"],"names":[],"mappings":"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","sourcesContent":["import { isNumeric } from '../util/isNumeric';\nimport { IScheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { async } from '../scheduler/async';\nimport { isScheduler } from '../util/isScheduler';\nimport { isDate } from '../util/isDate';\nimport { TeardownLogic } from '../Subscription';\nimport { Subscriber } from '../Subscriber';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class TimerObservable extends Observable<number> {\n\n  /**\n   * Creates an Observable that starts emitting after an `initialDelay` and\n   * emits ever increasing numbers after each `period` of time thereafter.\n   *\n   * <span class=\"informal\">Its like {@link interval}, but you can specify when\n   * should the emissions start.</span>\n   *\n   * <img src=\"./img/timer.png\" width=\"100%\">\n   *\n   * `timer` returns an Observable that emits an infinite sequence of ascending\n   * integers, with a constant interval of time, `period` of your choosing\n   * between those emissions. The first emission happens after the specified\n   * `initialDelay`. The initial delay may be a {@link Date}. By default, this\n   * operator uses the `async` IScheduler to provide a notion of time, but you\n   * may pass any IScheduler to it. If `period` is not specified, the output\n   * Observable emits only one value, `0`. Otherwise, it emits an infinite\n   * sequence.\n   *\n   * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>\n   * var numbers = Rx.Observable.timer(3000, 1000);\n   * numbers.subscribe(x => console.log(x));\n   *\n   * @example <caption>Emits one number after five seconds</caption>\n   * var numbers = Rx.Observable.timer(5000);\n   * numbers.subscribe(x => console.log(x));\n   *\n   * @see {@link interval}\n   * @see {@link delay}\n   *\n   * @param {number|Date} initialDelay The initial delay time to wait before\n   * emitting the first value of `0`.\n   * @param {number} [period] The period of time between emissions of the\n   * subsequent numbers.\n   * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\n   * the emission of values, and providing a notion of \"time\".\n   * @return {Observable} An Observable that emits a `0` after the\n   * `initialDelay` and ever increasing numbers after each `period` of time\n   * thereafter.\n   * @static true\n   * @name timer\n   * @owner Observable\n   */\n  static create(initialDelay: number | Date = 0,\n                period?: number | IScheduler,\n                scheduler?: IScheduler): Observable<number> {\n    return new TimerObservable(initialDelay, period, scheduler);\n  }\n\n  static dispatch(state: any) {\n\n    const { index, period, subscriber } = state;\n    const action = (<any> this);\n\n    subscriber.next(index);\n\n    if (subscriber.closed) {\n      return;\n    } else if (period === -1) {\n      return subscriber.complete();\n    }\n\n    state.index = index + 1;\n    action.schedule(state, period);\n  }\n\n  private period: number = -1;\n  private dueTime: number = 0;\n  private scheduler: IScheduler;\n\n  constructor(dueTime: number | Date = 0,\n              period?: number | IScheduler,\n              scheduler?: IScheduler) {\n    super();\n\n    if (isNumeric(period)) {\n      this.period = Number(period) < 1 && 1 || Number(period);\n    } else if (isScheduler(period)) {\n      scheduler = <IScheduler> period;\n    }\n\n    if (!isScheduler(scheduler)) {\n      scheduler = async;\n    }\n\n    this.scheduler = scheduler;\n    this.dueTime = isDate(dueTime) ?\n      (+dueTime - this.scheduler.now()) :\n      (<number> dueTime);\n  }\n\n  /** @deprecated internal use only */ _subscribe(subscriber: Subscriber<number>): TeardownLogic {\n    const index = 0;\n    const { period, dueTime, scheduler } = this;\n\n    return scheduler.schedule(TimerObservable.dispatch, dueTime, {\n      index, period, subscriber\n    });\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}