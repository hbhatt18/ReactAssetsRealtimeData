{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar async_1 = require('../scheduler/async');\n\nvar Subscriber_1 = require('../Subscriber');\n\nvar isScheduler_1 = require('../util/isScheduler');\n/* tslint:enable:max-line-length */\n\n/**\n * Buffers the source Observable values for a specific time period.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * those arrays periodically in time.</span>\n *\n * <img src=\"./img/bufferTime.png\" width=\"100%\">\n *\n * Buffers values from the source for a specific time duration `bufferTimeSpan`.\n * Unless the optional argument `bufferCreationInterval` is given, it emits and\n * resets the buffer every `bufferTimeSpan` milliseconds. If\n * `bufferCreationInterval` is given, this operator opens the buffer every\n * `bufferCreationInterval` milliseconds and closes (emits and resets) the\n * buffer every `bufferTimeSpan` milliseconds. When the optional argument\n * `maxBufferSize` is specified, the buffer will be closed either after\n * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\n *\n * @example <caption>Every second, emit an array of the recent click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(1000);\n * buffered.subscribe(x => console.log(x));\n *\n * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(2000, 5000);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link windowTime}\n *\n * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\n * @param {number} [bufferCreationInterval] The interval at which to start new\n * buffers.\n * @param {number} [maxBufferSize] The maximum buffer size.\n * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine buffer boundaries.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferTime\n * @owner Observable\n */\n\n\nfunction bufferTime(bufferTimeSpan) {\n  var length = arguments.length;\n  var scheduler = async_1.async;\n\n  if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {\n    scheduler = arguments[arguments.length - 1];\n    length--;\n  }\n\n  var bufferCreationInterval = null;\n\n  if (length >= 2) {\n    bufferCreationInterval = arguments[1];\n  }\n\n  var maxBufferSize = Number.POSITIVE_INFINITY;\n\n  if (length >= 3) {\n    maxBufferSize = arguments[2];\n  }\n\n  return function bufferTimeOperatorFunction(source) {\n    return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n  };\n}\n\nexports.bufferTime = bufferTime;\n\nvar BufferTimeOperator = function () {\n  function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n    this.bufferTimeSpan = bufferTimeSpan;\n    this.bufferCreationInterval = bufferCreationInterval;\n    this.maxBufferSize = maxBufferSize;\n    this.scheduler = scheduler;\n  }\n\n  BufferTimeOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));\n  };\n\n  return BufferTimeOperator;\n}();\n\nvar Context = function () {\n  function Context() {\n    this.buffer = [];\n  }\n\n  return Context;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar BufferTimeSubscriber = function (_super) {\n  __extends(BufferTimeSubscriber, _super);\n\n  function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n    _super.call(this, destination);\n\n    this.bufferTimeSpan = bufferTimeSpan;\n    this.bufferCreationInterval = bufferCreationInterval;\n    this.maxBufferSize = maxBufferSize;\n    this.scheduler = scheduler;\n    this.contexts = [];\n    var context = this.openContext();\n    this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n\n    if (this.timespanOnly) {\n      var timeSpanOnlyState = {\n        subscriber: this,\n        context: context,\n        bufferTimeSpan: bufferTimeSpan\n      };\n      this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    } else {\n      var closeState = {\n        subscriber: this,\n        context: context\n      };\n      var creationState = {\n        bufferTimeSpan: bufferTimeSpan,\n        bufferCreationInterval: bufferCreationInterval,\n        subscriber: this,\n        scheduler: scheduler\n      };\n      this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\n      this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\n    }\n  }\n\n  BufferTimeSubscriber.prototype._next = function (value) {\n    var contexts = this.contexts;\n    var len = contexts.length;\n    var filledBufferContext;\n\n    for (var i = 0; i < len; i++) {\n      var context = contexts[i];\n      var buffer = context.buffer;\n      buffer.push(value);\n\n      if (buffer.length == this.maxBufferSize) {\n        filledBufferContext = context;\n      }\n    }\n\n    if (filledBufferContext) {\n      this.onBufferFull(filledBufferContext);\n    }\n  };\n\n  BufferTimeSubscriber.prototype._error = function (err) {\n    this.contexts.length = 0;\n\n    _super.prototype._error.call(this, err);\n  };\n\n  BufferTimeSubscriber.prototype._complete = function () {\n    var _a = this,\n        contexts = _a.contexts,\n        destination = _a.destination;\n\n    while (contexts.length > 0) {\n      var context = contexts.shift();\n      destination.next(context.buffer);\n    }\n\n    _super.prototype._complete.call(this);\n  };\n  /** @deprecated internal use only */\n\n\n  BufferTimeSubscriber.prototype._unsubscribe = function () {\n    this.contexts = null;\n  };\n\n  BufferTimeSubscriber.prototype.onBufferFull = function (context) {\n    this.closeContext(context);\n    var closeAction = context.closeAction;\n    closeAction.unsubscribe();\n    this.remove(closeAction);\n\n    if (!this.closed && this.timespanOnly) {\n      context = this.openContext();\n      var bufferTimeSpan = this.bufferTimeSpan;\n      var timeSpanOnlyState = {\n        subscriber: this,\n        context: context,\n        bufferTimeSpan: bufferTimeSpan\n      };\n      this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    }\n  };\n\n  BufferTimeSubscriber.prototype.openContext = function () {\n    var context = new Context();\n    this.contexts.push(context);\n    return context;\n  };\n\n  BufferTimeSubscriber.prototype.closeContext = function (context) {\n    this.destination.next(context.buffer);\n    var contexts = this.contexts;\n    var spliceIndex = contexts ? contexts.indexOf(context) : -1;\n\n    if (spliceIndex >= 0) {\n      contexts.splice(contexts.indexOf(context), 1);\n    }\n  };\n\n  return BufferTimeSubscriber;\n}(Subscriber_1.Subscriber);\n\nfunction dispatchBufferTimeSpanOnly(state) {\n  var subscriber = state.subscriber;\n  var prevContext = state.context;\n\n  if (prevContext) {\n    subscriber.closeContext(prevContext);\n  }\n\n  if (!subscriber.closed) {\n    state.context = subscriber.openContext();\n    state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n  }\n}\n\nfunction dispatchBufferCreation(state) {\n  var bufferCreationInterval = state.bufferCreationInterval,\n      bufferTimeSpan = state.bufferTimeSpan,\n      subscriber = state.subscriber,\n      scheduler = state.scheduler;\n  var context = subscriber.openContext();\n  var action = this;\n\n  if (!subscriber.closed) {\n    subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, {\n      subscriber: subscriber,\n      context: context\n    }));\n    action.schedule(state, bufferCreationInterval);\n  }\n}\n\nfunction dispatchBufferClose(arg) {\n  var subscriber = arg.subscriber,\n      context = arg.context;\n  subscriber.closeContext(context);\n}","map":{"version":3,"sources":["../../src/operators/bufferTime.ts"],"names":[],"mappings":"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","sourcesContent":["import { IScheduler } from '../Scheduler';\nimport { Action } from '../scheduler/Action';\nimport { Operator } from '../Operator';\nimport { async } from '../scheduler/async';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { isScheduler } from '../util/isScheduler';\nimport { OperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function bufferTime<T>(bufferTimeSpan: number, scheduler?: IScheduler): OperatorFunction<T, T[]>;\nexport function bufferTime<T>(bufferTimeSpan: number, bufferCreationInterval: number, scheduler?: IScheduler): OperatorFunction<T, T[]>;\nexport function bufferTime<T>(bufferTimeSpan: number, bufferCreationInterval: number, maxBufferSize: number, scheduler?: IScheduler): OperatorFunction<T, T[]>;\n/* tslint:enable:max-line-length */\n\n/**\n * Buffers the source Observable values for a specific time period.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * those arrays periodically in time.</span>\n *\n * <img src=\"./img/bufferTime.png\" width=\"100%\">\n *\n * Buffers values from the source for a specific time duration `bufferTimeSpan`.\n * Unless the optional argument `bufferCreationInterval` is given, it emits and\n * resets the buffer every `bufferTimeSpan` milliseconds. If\n * `bufferCreationInterval` is given, this operator opens the buffer every\n * `bufferCreationInterval` milliseconds and closes (emits and resets) the\n * buffer every `bufferTimeSpan` milliseconds. When the optional argument\n * `maxBufferSize` is specified, the buffer will be closed either after\n * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\n *\n * @example <caption>Every second, emit an array of the recent click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(1000);\n * buffered.subscribe(x => console.log(x));\n *\n * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var buffered = clicks.bufferTime(2000, 5000);\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link windowTime}\n *\n * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\n * @param {number} [bufferCreationInterval] The interval at which to start new\n * buffers.\n * @param {number} [maxBufferSize] The maximum buffer size.\n * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine buffer boundaries.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferTime\n * @owner Observable\n */\nexport function bufferTime<T>(bufferTimeSpan: number): OperatorFunction<T, T[]> {\n  let length: number = arguments.length;\n\n  let scheduler: IScheduler = async;\n  if (isScheduler(arguments[arguments.length - 1])) {\n    scheduler = arguments[arguments.length - 1];\n    length--;\n  }\n\n  let bufferCreationInterval: number = null;\n  if (length >= 2) {\n    bufferCreationInterval = arguments[1];\n  }\n\n  let maxBufferSize: number = Number.POSITIVE_INFINITY;\n  if (length >= 3) {\n    maxBufferSize = arguments[2];\n  }\n\n  return function bufferTimeOperatorFunction(source: Observable<T>) {\n    return source.lift(new BufferTimeOperator<T>(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n  };\n}\n\nclass BufferTimeOperator<T> implements Operator<T, T[]> {\n  constructor(private bufferTimeSpan: number,\n              private bufferCreationInterval: number,\n              private maxBufferSize: number,\n              private scheduler: IScheduler) {\n  }\n\n  call(subscriber: Subscriber<T[]>, source: any): any {\n    return source.subscribe(new BufferTimeSubscriber(\n      subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler\n    ));\n  }\n}\n\nclass Context<T> {\n  buffer: T[] = [];\n  closeAction: Subscription;\n}\n\ntype CreationState<T> = {\n  bufferTimeSpan: number;\n  bufferCreationInterval: number,\n  subscriber: BufferTimeSubscriber<T>;\n  scheduler: IScheduler;\n};\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass BufferTimeSubscriber<T> extends Subscriber<T> {\n  private contexts: Array<Context<T>> = [];\n  private timespanOnly: boolean;\n\n  constructor(destination: Subscriber<T[]>,\n              private bufferTimeSpan: number,\n              private bufferCreationInterval: number,\n              private maxBufferSize: number,\n              private scheduler: IScheduler) {\n    super(destination);\n    const context = this.openContext();\n    this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n    if (this.timespanOnly) {\n      const timeSpanOnlyState = { subscriber: this, context, bufferTimeSpan };\n      this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    } else {\n      const closeState = { subscriber: this, context };\n      const creationState: CreationState<T> = { bufferTimeSpan, bufferCreationInterval, subscriber: this, scheduler };\n      this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\n      this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\n    }\n  }\n\n  protected _next(value: T) {\n    const contexts = this.contexts;\n    const len = contexts.length;\n    let filledBufferContext: Context<T>;\n    for (let i = 0; i < len; i++) {\n      const context = contexts[i];\n      const buffer = context.buffer;\n      buffer.push(value);\n      if (buffer.length == this.maxBufferSize) {\n        filledBufferContext = context;\n      }\n    }\n\n    if (filledBufferContext) {\n      this.onBufferFull(filledBufferContext);\n    }\n  }\n\n  protected _error(err: any) {\n    this.contexts.length = 0;\n    super._error(err);\n  }\n\n  protected _complete() {\n    const { contexts, destination } = this;\n    while (contexts.length > 0) {\n      const context = contexts.shift();\n      destination.next(context.buffer);\n    }\n    super._complete();\n  }\n\n  /** @deprecated internal use only */ _unsubscribe() {\n    this.contexts = null;\n  }\n\n  protected onBufferFull(context: Context<T>) {\n    this.closeContext(context);\n    const closeAction = context.closeAction;\n    closeAction.unsubscribe();\n    this.remove(closeAction);\n\n    if (!this.closed && this.timespanOnly) {\n      context = this.openContext();\n      const bufferTimeSpan = this.bufferTimeSpan;\n      const timeSpanOnlyState = { subscriber: this, context, bufferTimeSpan };\n      this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    }\n  }\n\n  openContext(): Context<T> {\n    const context: Context<T> = new Context<T>();\n    this.contexts.push(context);\n    return context;\n  }\n\n  closeContext(context: Context<T>) {\n    this.destination.next(context.buffer);\n    const contexts = this.contexts;\n\n    const spliceIndex = contexts ? contexts.indexOf(context) : -1;\n    if (spliceIndex >= 0) {\n      contexts.splice(contexts.indexOf(context), 1);\n    }\n  }\n}\n\nfunction dispatchBufferTimeSpanOnly(this: Action<any>, state: any) {\n  const subscriber: BufferTimeSubscriber<any> = state.subscriber;\n\n  const prevContext = state.context;\n  if (prevContext) {\n    subscriber.closeContext(prevContext);\n  }\n\n  if (!subscriber.closed) {\n    state.context = subscriber.openContext();\n    state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n  }\n}\n\ninterface DispatchArg<T> {\n  subscriber: BufferTimeSubscriber<T>;\n  context: Context<T>;\n}\n\nfunction dispatchBufferCreation<T>(this: Action<CreationState<T>>, state: CreationState<T>) {\n  const { bufferCreationInterval, bufferTimeSpan, subscriber, scheduler } = state;\n  const context = subscriber.openContext();\n  const action = <Action<CreationState<T>>>this;\n  if (!subscriber.closed) {\n    subscriber.add(context.closeAction = scheduler.schedule<DispatchArg<T>>(dispatchBufferClose, bufferTimeSpan, { subscriber, context }));\n    action.schedule(state, bufferCreationInterval);\n  }\n}\n\nfunction dispatchBufferClose<T>(arg: DispatchArg<T>) {\n  const { subscriber, context } = arg;\n  subscriber.closeContext(context);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}