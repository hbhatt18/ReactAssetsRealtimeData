{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Observable_1 = require('../Observable');\n\nvar EmptyObservable_1 = require('./EmptyObservable');\n\nvar isArray_1 = require('../util/isArray');\n\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n\nvar OuterSubscriber_1 = require('../OuterSubscriber');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar ForkJoinObservable = function (_super) {\n  __extends(ForkJoinObservable, _super);\n\n  function ForkJoinObservable(sources, resultSelector) {\n    _super.call(this);\n\n    this.sources = sources;\n    this.resultSelector = resultSelector;\n  }\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Joins last values emitted by passed Observables.\n   *\n   * <span class=\"informal\">Wait for Observables to complete and then combine last values they emitted.</span>\n   *\n   * <img src=\"./img/forkJoin.png\" width=\"100%\">\n   *\n   * `forkJoin` is an operator that takes any number of Observables which can be passed either as an array\n   * or directly as arguments. If no input Observables are provided, resulting stream will complete\n   * immediately.\n   *\n   * `forkJoin` will wait for all passed Observables to complete and then it will emit an array with last\n   * values from corresponding Observables. So if you pass `n` Observables to the operator, resulting\n   * array will have `n` values, where first value is the last thing emitted by the first Observable,\n   * second value is the last thing emitted by the second Observable and so on. That means `forkJoin` will\n   * not emit more than once and it will complete after that. If you need to emit combined values not only\n   * at the end of lifecycle of passed Observables, but also throughout it, try out {@link combineLatest}\n   * or {@link zip} instead.\n   *\n   * In order for resulting array to have the same length as the number of input Observables, whenever any of\n   * that Observables completes without emitting any value, `forkJoin` will complete at that moment as well\n   * and it will not emit anything either, even if it already has some last values from other Observables.\n   * Conversely, if there is an Observable that never completes, `forkJoin` will never complete as well,\n   * unless at any point some other Observable completes without emitting value, which brings us back to\n   * the previous case. Overall, in order for `forkJoin` to emit a value, all Observables passed as arguments\n   * have to emit something at least once and complete.\n   *\n   * If any input Observable errors at some point, `forkJoin` will error as well and all other Observables\n   * will be immediately unsubscribed.\n   *\n   * Optionally `forkJoin` accepts project function, that will be called with values which normally\n   * would land in emitted array. Whatever is returned by project function, will appear in output\n   * Observable instead. This means that default project can be thought of as a function that takes\n   * all its arguments and puts them into an array. Note that project function will be called only\n   * when output Observable is supposed to emit a result.\n   *\n   * @example <caption>Use forkJoin with operator emitting immediately</caption>\n   * const observable = Rx.Observable.forkJoin(\n   *   Rx.Observable.of(1, 2, 3, 4),\n   *   Rx.Observable.of(5, 6, 7, 8)\n   * );\n   * observable.subscribe(\n   *   value => console.log(value),\n   *   err => {},\n   *   () => console.log('This is how it ends!')\n   * );\n   *\n   * // Logs:\n   * // [4, 8]\n   * // \"This is how it ends!\"\n   *\n   *\n   * @example <caption>Use forkJoin with operator emitting after some time</caption>\n   * const observable = Rx.Observable.forkJoin(\n   *   Rx.Observable.interval(1000).take(3), // emit 0, 1, 2 every second and complete\n   *   Rx.Observable.interval(500).take(4) // emit 0, 1, 2, 3 every half a second and complete\n   * );\n   * observable.subscribe(\n   *   value => console.log(value),\n   *   err => {},\n   *   () => console.log('This is how it ends!')\n   * );\n   *\n   * // Logs:\n   * // [2, 3] after 3 seconds\n   * // \"This is how it ends!\" immediately after\n   *\n   *\n   * @example <caption>Use forkJoin with project function</caption>\n   * const observable = Rx.Observable.forkJoin(\n   *   Rx.Observable.interval(1000).take(3), // emit 0, 1, 2 every second and complete\n   *   Rx.Observable.interval(500).take(4), // emit 0, 1, 2, 3 every half a second and complete\n   *   (n, m) => n + m\n   * );\n   * observable.subscribe(\n   *   value => console.log(value),\n   *   err => {},\n   *   () => console.log('This is how it ends!')\n   * );\n   *\n   * // Logs:\n   * // 5 after 3 seconds\n   * // \"This is how it ends!\" immediately after\n   *\n   * @see {@link combineLatest}\n   * @see {@link zip}\n   *\n   * @param {...SubscribableOrPromise} sources Any number of Observables provided either as an array or as an arguments\n   * passed directly to the operator.\n   * @param {function} [project] Function that takes values emitted by input Observables and returns value\n   * that will appear in resulting Observable instead of default array.\n   * @return {Observable} Observable emitting either an array of last values emitted by passed Observables\n   * or value from project function.\n   * @static true\n   * @name forkJoin\n   * @owner Observable\n   */\n\n\n  ForkJoinObservable.create = function () {\n    var sources = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      sources[_i - 0] = arguments[_i];\n    }\n\n    if (sources === null || arguments.length === 0) {\n      return new EmptyObservable_1.EmptyObservable();\n    }\n\n    var resultSelector = null;\n\n    if (typeof sources[sources.length - 1] === 'function') {\n      resultSelector = sources.pop();\n    } // if the first and only other argument besides the resultSelector is an array\n    // assume it's been called with `forkJoin([obs1, obs2, obs3], resultSelector)`\n\n\n    if (sources.length === 1 && isArray_1.isArray(sources[0])) {\n      sources = sources[0];\n    }\n\n    if (sources.length === 0) {\n      return new EmptyObservable_1.EmptyObservable();\n    }\n\n    return new ForkJoinObservable(sources, resultSelector);\n  };\n  /** @deprecated internal use only */\n\n\n  ForkJoinObservable.prototype._subscribe = function (subscriber) {\n    return new ForkJoinSubscriber(subscriber, this.sources, this.resultSelector);\n  };\n\n  return ForkJoinObservable;\n}(Observable_1.Observable);\n\nexports.ForkJoinObservable = ForkJoinObservable;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nvar ForkJoinSubscriber = function (_super) {\n  __extends(ForkJoinSubscriber, _super);\n\n  function ForkJoinSubscriber(destination, sources, resultSelector) {\n    _super.call(this, destination);\n\n    this.sources = sources;\n    this.resultSelector = resultSelector;\n    this.completed = 0;\n    this.haveValues = 0;\n    var len = sources.length;\n    this.total = len;\n    this.values = new Array(len);\n\n    for (var i = 0; i < len; i++) {\n      var source = sources[i];\n      var innerSubscription = subscribeToResult_1.subscribeToResult(this, source, null, i);\n\n      if (innerSubscription) {\n        innerSubscription.outerIndex = i;\n        this.add(innerSubscription);\n      }\n    }\n  }\n\n  ForkJoinSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this.values[outerIndex] = innerValue;\n\n    if (!innerSub._hasValue) {\n      innerSub._hasValue = true;\n      this.haveValues++;\n    }\n  };\n\n  ForkJoinSubscriber.prototype.notifyComplete = function (innerSub) {\n    var destination = this.destination;\n\n    var _a = this,\n        haveValues = _a.haveValues,\n        resultSelector = _a.resultSelector,\n        values = _a.values;\n\n    var len = values.length;\n\n    if (!innerSub._hasValue) {\n      destination.complete();\n      return;\n    }\n\n    this.completed++;\n\n    if (this.completed !== len) {\n      return;\n    }\n\n    if (haveValues === len) {\n      var value = resultSelector ? resultSelector.apply(this, values) : values;\n      destination.next(value);\n    }\n\n    destination.complete();\n  };\n\n  return ForkJoinSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);","map":{"version":3,"sources":["../../src/observable/ForkJoinObservable.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,IAAA,YAAA,GAAA,OAAA,CAAkD,eAAlD,CAAA;;AAGA,IAAA,iBAAA,GAAA,OAAA,CAAgC,mBAAhC,CAAA;;AACA,IAAA,SAAA,GAAA,OAAA,CAAwB,iBAAxB,CAAA;;AAEA,IAAA,mBAAA,GAAA,OAAA,CAAkC,2BAAlC,CAAA;;AACA,IAAA,iBAAA,GAAA,OAAA,CAAgC,oBAAhC,CAAA;AAGA;;;;;;;AAKA,IAAA,kBAAA,GAAA,UAAA,MAAA,EAAA;AAA2C,EAAA,SAAA,CAAA,kBAAA,EAAA,MAAA,CAAA;;AACzC,WAAA,kBAAA,CAAoB,OAApB,EACoB,cADpB,EACiE;AAC/D,IAAA,MAAA,CAAA,IAAA,CAAA,IAAA;;AAFkB,SAAA,OAAA,GAAA,OAAA;AACA,SAAA,cAAA,GAAA,cAAA;AAEnB;AAoBD;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiGO,EAAA,kBAAA,CAAA,MAAA,GAAP,YAAA;AAAiB,QAAA,OAAA,GAAA,EAAA;;SAAA,IAAA,EAAA,GAAA,C,EAAA,EAAA,GAAA,SAAA,CAAA,M,EAAA,EAAA,E,EAEgD;AAFhD,MAAA,OAAA,CAAA,EAAA,GAAA,CAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;;AAGf,QAAI,OAAO,KAAK,IAAZ,IAAoB,SAAS,CAAC,MAAV,KAAqB,CAA7C,EAAgD;AAC9C,aAAO,IAAI,iBAAA,CAAA,eAAJ,EAAP;AACD;;AAED,QAAI,cAAc,GAAmC,IAArD;;AACA,QAAI,OAAO,OAAO,CAAC,OAAO,CAAC,MAAR,GAAiB,CAAlB,CAAd,KAAuC,UAA3C,EAAuD;AACrD,MAAA,cAAc,GAAmC,OAAO,CAAC,GAAR,EAAjD;AACD,KAVH,CAYE;AACA;;;AACA,QAAI,OAAO,CAAC,MAAR,KAAmB,CAAnB,IAAwB,SAAA,CAAA,OAAA,CAAQ,OAAO,CAAC,CAAD,CAAf,CAA5B,EAAiD;AAC/C,MAAA,OAAO,GAAsC,OAAO,CAAC,CAAD,CAApD;AACD;;AAED,QAAI,OAAO,CAAC,MAAR,KAAmB,CAAvB,EAA0B;AACxB,aAAO,IAAI,iBAAA,CAAA,eAAJ,EAAP;AACD;;AAED,WAAO,IAAI,kBAAJ,CAA0D,OAA1D,EAAmE,cAAnE,CAAP;AACD,GAvBM;AAyBP;;;AAAqC,EAAA,kBAAA,CAAA,SAAA,CAAA,UAAA,GAAA,UAAW,UAAX,EAAsC;AACzE,WAAO,IAAI,kBAAJ,CAAuB,UAAvB,EAAmC,KAAK,OAAxC,EAAiD,KAAK,cAAtD,CAAP;AACD,GAFoC;;AAGvC,SAAA,kBAAA;AAAC,CAvJD,CAA2C,YAAA,CAAA,UAA3C,CAAA;;AAAa,OAAA,CAAA,kBAAA,GAAkB,kBAAlB;AAyJb;;;;;;AAKA,IAAA,kBAAA,GAAA,UAAA,MAAA,EAAA;AAAoC,EAAA,SAAA,CAAA,kBAAA,EAAA,MAAA,CAAA;;AAMlC,WAAA,kBAAA,CAAY,WAAZ,EACoB,OADpB,EAEoB,cAFpB,EAEiE;AAC/D,IAAA,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,WAAN;;AAFkB,SAAA,OAAA,GAAA,OAAA;AACA,SAAA,cAAA,GAAA,cAAA;AAPZ,SAAA,SAAA,GAAY,CAAZ;AAGA,SAAA,UAAA,GAAa,CAAb;AAON,QAAM,GAAG,GAAG,OAAO,CAAC,MAApB;AACA,SAAK,KAAL,GAAa,GAAb;AACA,SAAK,MAAL,GAAc,IAAI,KAAJ,CAAU,GAAV,CAAd;;AAEA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,GAApB,EAAyB,CAAC,EAA1B,EAA8B;AAC5B,UAAM,MAAM,GAAG,OAAO,CAAC,CAAD,CAAtB;AACA,UAAM,iBAAiB,GAAG,mBAAA,CAAA,iBAAA,CAAkB,IAAlB,EAAwB,MAAxB,EAAgC,IAAhC,EAAsC,CAAtC,CAA1B;;AAEA,UAAI,iBAAJ,EAAuB;AACd,QAAA,iBAAkB,CAAC,UAAnB,GAAgC,CAAhC;AACP,aAAK,GAAL,CAAS,iBAAT;AACD;AACF;AACF;;AAED,EAAA,kBAAA,CAAA,SAAA,CAAA,UAAA,GAAA,UAAW,UAAX,EAA4B,UAA5B,EACW,UADX,EAC+B,UAD/B,EAEW,QAFX,EAE0C;AACxC,SAAK,MAAL,CAAY,UAAZ,IAA0B,UAA1B;;AACA,QAAI,CAAO,QAAS,CAAC,SAArB,EAAgC;AACxB,MAAA,QAAS,CAAC,SAAV,GAAsB,IAAtB;AACN,WAAK,UAAL;AACD;AACF,GARD;;AAUA,EAAA,kBAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UAAe,QAAf,EAA8C;AAC5C,QAAM,WAAW,GAAG,KAAK,WAAzB;;AACA,QAAA,EAAA,GAAA,IAAA;AAAA,QAAQ,UAAA,GAAA,EAAA,CAAA,UAAR;AAAA,QAAoB,cAAA,GAAA,EAAA,CAAA,cAApB;AAAA,QAAoC,MAAA,GAAA,EAAA,CAAA,MAApC;;AACA,QAAM,GAAG,GAAG,MAAM,CAAC,MAAnB;;AAEA,QAAI,CAAO,QAAS,CAAC,SAArB,EAAgC;AAC9B,MAAA,WAAW,CAAC,QAAZ;AACA;AACD;;AAED,SAAK,SAAL;;AAEA,QAAI,KAAK,SAAL,KAAmB,GAAvB,EAA4B;AAC1B;AACD;;AAED,QAAI,UAAU,KAAK,GAAnB,EAAwB;AACtB,UAAM,KAAK,GAAG,cAAc,GAAG,cAAc,CAAC,KAAf,CAAqB,IAArB,EAA2B,MAA3B,CAAH,GAAwC,MAApE;AACA,MAAA,WAAW,CAAC,IAAZ,CAAiB,KAAjB;AACD;;AAED,IAAA,WAAW,CAAC,QAAZ;AACD,GAtBD;;AAuBF,SAAA,kBAAA;AAAC,CA3DD,CAAoC,iBAAA,CAAA,eAApC,CAAA","sourcesContent":["import { Observable, SubscribableOrPromise } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { EmptyObservable } from './EmptyObservable';\nimport { isArray } from '../util/isArray';\n\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class ForkJoinObservable<T> extends Observable<T> {\n  constructor(private sources: Array<SubscribableOrPromise<any>>,\n              private resultSelector?: (...values: Array<any>) => T) {\n    super();\n  }\n\n  /* tslint:disable:max-line-length */\n  static create<T, T2>(v1: SubscribableOrPromise<T>, v2: SubscribableOrPromise<T2>): Observable<[T, T2]>;\n  static create<T, T2, T3>(v1: SubscribableOrPromise<T>, v2: SubscribableOrPromise<T2>, v3: SubscribableOrPromise<T3>): Observable<[T, T2, T3]>;\n  static create<T, T2, T3, T4>(v1: SubscribableOrPromise<T>, v2: SubscribableOrPromise<T2>, v3: SubscribableOrPromise<T3>, v4: SubscribableOrPromise<T4>): Observable<[T, T2, T3, T4]>;\n  static create<T, T2, T3, T4, T5>(v1: SubscribableOrPromise<T>, v2: SubscribableOrPromise<T2>, v3: SubscribableOrPromise<T3>, v4: SubscribableOrPromise<T4>, v5: SubscribableOrPromise<T5>): Observable<[T, T2, T3, T4, T5]>;\n  static create<T, T2, T3, T4, T5, T6>(v1: SubscribableOrPromise<T>, v2: SubscribableOrPromise<T2>, v3: SubscribableOrPromise<T3>, v4: SubscribableOrPromise<T4>, v5: SubscribableOrPromise<T5>, v6: SubscribableOrPromise<T6>): Observable<[T, T2, T3, T4, T5, T6]>;\n  static create<T, R>(v1: SubscribableOrPromise<T>, project: (v1: T) => R): Observable<R>;\n  static create<T, T2, R>(v1: SubscribableOrPromise<T>, v2: SubscribableOrPromise<T2>, project: (v1: T, v2: T2) => R): Observable<R>;\n  static create<T, T2, T3, R>(v1: SubscribableOrPromise<T>, v2: SubscribableOrPromise<T2>, v3: SubscribableOrPromise<T3>, project: (v1: T, v2: T2, v3: T3) => R): Observable<R>;\n  static create<T, T2, T3, T4, R>(v1: SubscribableOrPromise<T>, v2: SubscribableOrPromise<T2>, v3: SubscribableOrPromise<T3>, v4: SubscribableOrPromise<T4>, project: (v1: T, v2: T2, v3: T3, v4: T4) => R): Observable<R>;\n  static create<T, T2, T3, T4, T5, R>(v1: SubscribableOrPromise<T>, v2: SubscribableOrPromise<T2>, v3: SubscribableOrPromise<T3>, v4: SubscribableOrPromise<T4>, v5: SubscribableOrPromise<T5>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R): Observable<R>;\n  static create<T, T2, T3, T4, T5, T6, R>(v1: SubscribableOrPromise<T>, v2: SubscribableOrPromise<T2>, v3: SubscribableOrPromise<T3>, v4: SubscribableOrPromise<T4>, v5: SubscribableOrPromise<T5>, v6: SubscribableOrPromise<T6>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R): Observable<R>;\n  static create<T>(sources: SubscribableOrPromise<T>[]): Observable<T[]>;\n  static create<R>(sources: SubscribableOrPromise<any>[]): Observable<R>;\n  static create<T, R>(sources: SubscribableOrPromise<T>[], project: (...values: Array<T>) => R): Observable<R>;\n  static create<R>(sources: SubscribableOrPromise<any>[], project: (...values: Array<any>) => R): Observable<R>;\n  static create<T>(...sources: SubscribableOrPromise<T>[]): Observable<T[]>;\n  static create<R>(...sources: SubscribableOrPromise<any>[]): Observable<R>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Joins last values emitted by passed Observables.\n   *\n   * <span class=\"informal\">Wait for Observables to complete and then combine last values they emitted.</span>\n   *\n   * <img src=\"./img/forkJoin.png\" width=\"100%\">\n   *\n   * `forkJoin` is an operator that takes any number of Observables which can be passed either as an array\n   * or directly as arguments. If no input Observables are provided, resulting stream will complete\n   * immediately.\n   *\n   * `forkJoin` will wait for all passed Observables to complete and then it will emit an array with last\n   * values from corresponding Observables. So if you pass `n` Observables to the operator, resulting\n   * array will have `n` values, where first value is the last thing emitted by the first Observable,\n   * second value is the last thing emitted by the second Observable and so on. That means `forkJoin` will\n   * not emit more than once and it will complete after that. If you need to emit combined values not only\n   * at the end of lifecycle of passed Observables, but also throughout it, try out {@link combineLatest}\n   * or {@link zip} instead.\n   *\n   * In order for resulting array to have the same length as the number of input Observables, whenever any of\n   * that Observables completes without emitting any value, `forkJoin` will complete at that moment as well\n   * and it will not emit anything either, even if it already has some last values from other Observables.\n   * Conversely, if there is an Observable that never completes, `forkJoin` will never complete as well,\n   * unless at any point some other Observable completes without emitting value, which brings us back to\n   * the previous case. Overall, in order for `forkJoin` to emit a value, all Observables passed as arguments\n   * have to emit something at least once and complete.\n   *\n   * If any input Observable errors at some point, `forkJoin` will error as well and all other Observables\n   * will be immediately unsubscribed.\n   *\n   * Optionally `forkJoin` accepts project function, that will be called with values which normally\n   * would land in emitted array. Whatever is returned by project function, will appear in output\n   * Observable instead. This means that default project can be thought of as a function that takes\n   * all its arguments and puts them into an array. Note that project function will be called only\n   * when output Observable is supposed to emit a result.\n   *\n   * @example <caption>Use forkJoin with operator emitting immediately</caption>\n   * const observable = Rx.Observable.forkJoin(\n   *   Rx.Observable.of(1, 2, 3, 4),\n   *   Rx.Observable.of(5, 6, 7, 8)\n   * );\n   * observable.subscribe(\n   *   value => console.log(value),\n   *   err => {},\n   *   () => console.log('This is how it ends!')\n   * );\n   *\n   * // Logs:\n   * // [4, 8]\n   * // \"This is how it ends!\"\n   *\n   *\n   * @example <caption>Use forkJoin with operator emitting after some time</caption>\n   * const observable = Rx.Observable.forkJoin(\n   *   Rx.Observable.interval(1000).take(3), // emit 0, 1, 2 every second and complete\n   *   Rx.Observable.interval(500).take(4) // emit 0, 1, 2, 3 every half a second and complete\n   * );\n   * observable.subscribe(\n   *   value => console.log(value),\n   *   err => {},\n   *   () => console.log('This is how it ends!')\n   * );\n   *\n   * // Logs:\n   * // [2, 3] after 3 seconds\n   * // \"This is how it ends!\" immediately after\n   *\n   *\n   * @example <caption>Use forkJoin with project function</caption>\n   * const observable = Rx.Observable.forkJoin(\n   *   Rx.Observable.interval(1000).take(3), // emit 0, 1, 2 every second and complete\n   *   Rx.Observable.interval(500).take(4), // emit 0, 1, 2, 3 every half a second and complete\n   *   (n, m) => n + m\n   * );\n   * observable.subscribe(\n   *   value => console.log(value),\n   *   err => {},\n   *   () => console.log('This is how it ends!')\n   * );\n   *\n   * // Logs:\n   * // 5 after 3 seconds\n   * // \"This is how it ends!\" immediately after\n   *\n   * @see {@link combineLatest}\n   * @see {@link zip}\n   *\n   * @param {...SubscribableOrPromise} sources Any number of Observables provided either as an array or as an arguments\n   * passed directly to the operator.\n   * @param {function} [project] Function that takes values emitted by input Observables and returns value\n   * that will appear in resulting Observable instead of default array.\n   * @return {Observable} Observable emitting either an array of last values emitted by passed Observables\n   * or value from project function.\n   * @static true\n   * @name forkJoin\n   * @owner Observable\n   */\n  static create<T>(...sources: Array<SubscribableOrPromise<any> |\n                                  Array<SubscribableOrPromise<any>> |\n                                  ((...values: Array<any>) => any)>): Observable<T> {\n    if (sources === null || arguments.length === 0) {\n      return new EmptyObservable<T>();\n    }\n\n    let resultSelector: (...values: Array<any>) => any = null;\n    if (typeof sources[sources.length - 1] === 'function') {\n      resultSelector = <(...values: Array<any>) => any>sources.pop();\n    }\n\n    // if the first and only other argument besides the resultSelector is an array\n    // assume it's been called with `forkJoin([obs1, obs2, obs3], resultSelector)`\n    if (sources.length === 1 && isArray(sources[0])) {\n      sources = <Array<SubscribableOrPromise<any>>>sources[0];\n    }\n\n    if (sources.length === 0) {\n      return new EmptyObservable<T>();\n    }\n\n    return new ForkJoinObservable(<Array<SubscribableOrPromise<any>>>sources, resultSelector);\n  }\n\n  /** @deprecated internal use only */ _subscribe(subscriber: Subscriber<any>): Subscription {\n    return new ForkJoinSubscriber(subscriber, this.sources, this.resultSelector);\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass ForkJoinSubscriber<T> extends OuterSubscriber<T, T> {\n  private completed = 0;\n  private total: number;\n  private values: any[];\n  private haveValues = 0;\n\n  constructor(destination: Subscriber<T>,\n              private sources: Array<SubscribableOrPromise<any>>,\n              private resultSelector?: (...values: Array<any>) => T) {\n    super(destination);\n\n    const len = sources.length;\n    this.total = len;\n    this.values = new Array(len);\n\n    for (let i = 0; i < len; i++) {\n      const source = sources[i];\n      const innerSubscription = subscribeToResult(this, source, null, i);\n\n      if (innerSubscription) {\n        (<any> innerSubscription).outerIndex = i;\n        this.add(innerSubscription);\n      }\n    }\n  }\n\n  notifyNext(outerValue: any, innerValue: T,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, T>): void {\n    this.values[outerIndex] = innerValue;\n    if (!(<any>innerSub)._hasValue) {\n      (<any>innerSub)._hasValue = true;\n      this.haveValues++;\n    }\n  }\n\n  notifyComplete(innerSub: InnerSubscriber<T, T>): void {\n    const destination = this.destination;\n    const { haveValues, resultSelector, values } = this;\n    const len = values.length;\n\n    if (!(<any>innerSub)._hasValue) {\n      destination.complete();\n      return;\n    }\n\n    this.completed++;\n\n    if (this.completed !== len) {\n      return;\n    }\n\n    if (haveValues === len) {\n      const value = resultSelector ? resultSelector.apply(this, values) : values;\n      destination.next(value);\n    }\n\n    destination.complete();\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}