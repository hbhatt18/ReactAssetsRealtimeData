{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar ArrayObservable_1 = require('../observable/ArrayObservable');\n\nvar isArray_1 = require('../util/isArray');\n\nvar Subscriber_1 = require('../Subscriber');\n\nvar OuterSubscriber_1 = require('../OuterSubscriber');\n\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n\nvar iterator_1 = require('../symbol/iterator');\n/* tslint:enable:max-line-length */\n\n/**\n * @param observables\n * @return {Observable<R>}\n * @method zip\n * @owner Observable\n */\n\n\nfunction zip() {\n  var observables = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    observables[_i - 0] = arguments[_i];\n  }\n\n  return function zipOperatorFunction(source) {\n    return source.lift.call(zipStatic.apply(void 0, [source].concat(observables)));\n  };\n}\n\nexports.zip = zip;\n/* tslint:enable:max-line-length */\n\n/**\n * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each\n * of its input Observables.\n *\n * If the latest parameter is a function, this function is used to compute the created value from the input values.\n * Otherwise, an array of the input values is returned.\n *\n * @example <caption>Combine age and name from different sources</caption>\n *\n * let age$ = Observable.of<number>(27, 25, 29);\n * let name$ = Observable.of<string>('Foo', 'Bar', 'Beer');\n * let isDev$ = Observable.of<boolean>(true, true, false);\n *\n * Observable\n *     .zip(age$,\n *          name$,\n *          isDev$,\n *          (age: number, name: string, isDev: boolean) => ({ age, name, isDev }))\n *     .subscribe(x => console.log(x));\n *\n * // outputs\n * // { age: 27, name: 'Foo', isDev: true }\n * // { age: 25, name: 'Bar', isDev: true }\n * // { age: 29, name: 'Beer', isDev: false }\n *\n * @param observables\n * @return {Observable<R>}\n * @static true\n * @name zip\n * @owner Observable\n */\n\nfunction zipStatic() {\n  var observables = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    observables[_i - 0] = arguments[_i];\n  }\n\n  var project = observables[observables.length - 1];\n\n  if (typeof project === 'function') {\n    observables.pop();\n  }\n\n  return new ArrayObservable_1.ArrayObservable(observables).lift(new ZipOperator(project));\n}\n\nexports.zipStatic = zipStatic;\n\nvar ZipOperator = function () {\n  function ZipOperator(project) {\n    this.project = project;\n  }\n\n  ZipOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new ZipSubscriber(subscriber, this.project));\n  };\n\n  return ZipOperator;\n}();\n\nexports.ZipOperator = ZipOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nvar ZipSubscriber = function (_super) {\n  __extends(ZipSubscriber, _super);\n\n  function ZipSubscriber(destination, project, values) {\n    if (values === void 0) {\n      values = Object.create(null);\n    }\n\n    _super.call(this, destination);\n\n    this.iterators = [];\n    this.active = 0;\n    this.project = typeof project === 'function' ? project : null;\n    this.values = values;\n  }\n\n  ZipSubscriber.prototype._next = function (value) {\n    var iterators = this.iterators;\n\n    if (isArray_1.isArray(value)) {\n      iterators.push(new StaticArrayIterator(value));\n    } else if (typeof value[iterator_1.iterator] === 'function') {\n      iterators.push(new StaticIterator(value[iterator_1.iterator]()));\n    } else {\n      iterators.push(new ZipBufferIterator(this.destination, this, value));\n    }\n  };\n\n  ZipSubscriber.prototype._complete = function () {\n    var iterators = this.iterators;\n    var len = iterators.length;\n\n    if (len === 0) {\n      this.destination.complete();\n      return;\n    }\n\n    this.active = len;\n\n    for (var i = 0; i < len; i++) {\n      var iterator = iterators[i];\n\n      if (iterator.stillUnsubscribed) {\n        this.add(iterator.subscribe(iterator, i));\n      } else {\n        this.active--; // not an observable\n      }\n    }\n  };\n\n  ZipSubscriber.prototype.notifyInactive = function () {\n    this.active--;\n\n    if (this.active === 0) {\n      this.destination.complete();\n    }\n  };\n\n  ZipSubscriber.prototype.checkIterators = function () {\n    var iterators = this.iterators;\n    var len = iterators.length;\n    var destination = this.destination; // abort if not all of them have values\n\n    for (var i = 0; i < len; i++) {\n      var iterator = iterators[i];\n\n      if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {\n        return;\n      }\n    }\n\n    var shouldComplete = false;\n    var args = [];\n\n    for (var i = 0; i < len; i++) {\n      var iterator = iterators[i];\n      var result = iterator.next(); // check to see if it's completed now that you've gotten\n      // the next value.\n\n      if (iterator.hasCompleted()) {\n        shouldComplete = true;\n      }\n\n      if (result.done) {\n        destination.complete();\n        return;\n      }\n\n      args.push(result.value);\n    }\n\n    if (this.project) {\n      this._tryProject(args);\n    } else {\n      destination.next(args);\n    }\n\n    if (shouldComplete) {\n      destination.complete();\n    }\n  };\n\n  ZipSubscriber.prototype._tryProject = function (args) {\n    var result;\n\n    try {\n      result = this.project.apply(this, args);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    this.destination.next(result);\n  };\n\n  return ZipSubscriber;\n}(Subscriber_1.Subscriber);\n\nexports.ZipSubscriber = ZipSubscriber;\n\nvar StaticIterator = function () {\n  function StaticIterator(iterator) {\n    this.iterator = iterator;\n    this.nextResult = iterator.next();\n  }\n\n  StaticIterator.prototype.hasValue = function () {\n    return true;\n  };\n\n  StaticIterator.prototype.next = function () {\n    var result = this.nextResult;\n    this.nextResult = this.iterator.next();\n    return result;\n  };\n\n  StaticIterator.prototype.hasCompleted = function () {\n    var nextResult = this.nextResult;\n    return nextResult && nextResult.done;\n  };\n\n  return StaticIterator;\n}();\n\nvar StaticArrayIterator = function () {\n  function StaticArrayIterator(array) {\n    this.array = array;\n    this.index = 0;\n    this.length = 0;\n    this.length = array.length;\n  }\n\n  StaticArrayIterator.prototype[iterator_1.iterator] = function () {\n    return this;\n  };\n\n  StaticArrayIterator.prototype.next = function (value) {\n    var i = this.index++;\n    var array = this.array;\n    return i < this.length ? {\n      value: array[i],\n      done: false\n    } : {\n      value: null,\n      done: true\n    };\n  };\n\n  StaticArrayIterator.prototype.hasValue = function () {\n    return this.array.length > this.index;\n  };\n\n  StaticArrayIterator.prototype.hasCompleted = function () {\n    return this.array.length === this.index;\n  };\n\n  return StaticArrayIterator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar ZipBufferIterator = function (_super) {\n  __extends(ZipBufferIterator, _super);\n\n  function ZipBufferIterator(destination, parent, observable) {\n    _super.call(this, destination);\n\n    this.parent = parent;\n    this.observable = observable;\n    this.stillUnsubscribed = true;\n    this.buffer = [];\n    this.isComplete = false;\n  }\n\n  ZipBufferIterator.prototype[iterator_1.iterator] = function () {\n    return this;\n  }; // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next\n  //    this is legit because `next()` will never be called by a subscription in this case.\n\n\n  ZipBufferIterator.prototype.next = function () {\n    var buffer = this.buffer;\n\n    if (buffer.length === 0 && this.isComplete) {\n      return {\n        value: null,\n        done: true\n      };\n    } else {\n      return {\n        value: buffer.shift(),\n        done: false\n      };\n    }\n  };\n\n  ZipBufferIterator.prototype.hasValue = function () {\n    return this.buffer.length > 0;\n  };\n\n  ZipBufferIterator.prototype.hasCompleted = function () {\n    return this.buffer.length === 0 && this.isComplete;\n  };\n\n  ZipBufferIterator.prototype.notifyComplete = function () {\n    if (this.buffer.length > 0) {\n      this.isComplete = true;\n      this.parent.notifyInactive();\n    } else {\n      this.destination.complete();\n    }\n  };\n\n  ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this.buffer.push(innerValue);\n    this.parent.checkIterators();\n  };\n\n  ZipBufferIterator.prototype.subscribe = function (value, index) {\n    return subscribeToResult_1.subscribeToResult(this, this.observable, this, index);\n  };\n\n  return ZipBufferIterator;\n}(OuterSubscriber_1.OuterSubscriber);","map":{"version":3,"sources":["../../src/operators/zip.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observable, ObservableInput } from '../Observable';\nimport { ArrayObservable } from '../observable/ArrayObservable';\nimport { isArray } from '../util/isArray';\nimport { Operator } from '../Operator';\nimport { PartialObserver } from '../Observer';\nimport { Subscriber } from '../Subscriber';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { OperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function zip<T, R>(project: (v1: T) => R): OperatorFunction<T, R>;\nexport function zip<T, T2, R>(v2: ObservableInput<T2>, project: (v1: T, v2: T2) => R): OperatorFunction<T, R>;\nexport function zip<T, T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, project: (v1: T, v2: T2, v3: T3) => R): OperatorFunction<T, R>;\nexport function zip<T, T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, project: (v1: T, v2: T2, v3: T3, v4: T4) => R): OperatorFunction<T, R>;\nexport function zip<T, T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R): OperatorFunction<T, R>;\nexport function zip<T, T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R): OperatorFunction<T, R> ;\nexport function zip<T, T2>(v2: ObservableInput<T2>): OperatorFunction<T, [T, T2]>;\nexport function zip<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): OperatorFunction<T, [T, T2, T3]>;\nexport function zip<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): OperatorFunction<T, [T, T2, T3, T4]>;\nexport function zip<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): OperatorFunction<T, [T, T2, T3, T4, T5]>;\nexport function zip<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): OperatorFunction<T, [T, T2, T3, T4, T5, T6]> ;\nexport function zip<T, R>(...observables: Array<ObservableInput<T> | ((...values: Array<T>) => R)>): OperatorFunction<T, R>;\nexport function zip<T, R>(array: Array<ObservableInput<T>>): OperatorFunction<T, R>;\nexport function zip<T, TOther, R>(array: Array<ObservableInput<TOther>>, project: (v1: T, ...values: Array<TOther>) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * @param observables\n * @return {Observable<R>}\n * @method zip\n * @owner Observable\n */\nexport function zip<T, R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): OperatorFunction<T, R> {\n  return function zipOperatorFunction(source: Observable<T>) {\n    return source.lift.call(zipStatic<R>(source, ...observables));\n  };\n}\n\n/* tslint:disable:max-line-length */\nexport function zipStatic<T, R>(v1: ObservableInput<T>, project: (v1: T) => R): Observable<R>;\nexport function zipStatic<T, T2, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, project: (v1: T, v2: T2) => R): Observable<R>;\nexport function zipStatic<T, T2, T3, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, project: (v1: T, v2: T2, v3: T3) => R): Observable<R>;\nexport function zipStatic<T, T2, T3, T4, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, project: (v1: T, v2: T2, v3: T3, v4: T4) => R): Observable<R>;\nexport function zipStatic<T, T2, T3, T4, T5, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R): Observable<R>;\nexport function zipStatic<T, T2, T3, T4, T5, T6, R>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R): Observable<R>;\n\nexport function zipStatic<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>): Observable<[T, T2]>;\nexport function zipStatic<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<[T, T2, T3]>;\nexport function zipStatic<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<[T, T2, T3, T4]>;\nexport function zipStatic<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<[T, T2, T3, T4, T5]>;\nexport function zipStatic<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<[T, T2, T3, T4, T5, T6]>;\n\nexport function zipStatic<T>(array: ObservableInput<T>[]): Observable<T[]>;\nexport function zipStatic<R>(array: ObservableInput<any>[]): Observable<R>;\nexport function zipStatic<T, R>(array: ObservableInput<T>[], project: (...values: Array<T>) => R): Observable<R>;\nexport function zipStatic<R>(array: ObservableInput<any>[], project: (...values: Array<any>) => R): Observable<R>;\n\nexport function zipStatic<T>(...observables: Array<ObservableInput<T>>): Observable<T[]>;\nexport function zipStatic<T, R>(...observables: Array<ObservableInput<T> | ((...values: Array<T>) => R)>): Observable<R>;\nexport function zipStatic<R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each\n * of its input Observables.\n *\n * If the latest parameter is a function, this function is used to compute the created value from the input values.\n * Otherwise, an array of the input values is returned.\n *\n * @example <caption>Combine age and name from different sources</caption>\n *\n * let age$ = Observable.of<number>(27, 25, 29);\n * let name$ = Observable.of<string>('Foo', 'Bar', 'Beer');\n * let isDev$ = Observable.of<boolean>(true, true, false);\n *\n * Observable\n *     .zip(age$,\n *          name$,\n *          isDev$,\n *          (age: number, name: string, isDev: boolean) => ({ age, name, isDev }))\n *     .subscribe(x => console.log(x));\n *\n * // outputs\n * // { age: 27, name: 'Foo', isDev: true }\n * // { age: 25, name: 'Bar', isDev: true }\n * // { age: 29, name: 'Beer', isDev: false }\n *\n * @param observables\n * @return {Observable<R>}\n * @static true\n * @name zip\n * @owner Observable\n */\nexport function zipStatic<T, R>(...observables: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): Observable<R> {\n  const project = <((...ys: Array<any>) => R)> observables[observables.length - 1];\n  if (typeof project === 'function') {\n    observables.pop();\n  }\n  return new ArrayObservable(observables).lift(new ZipOperator(project));\n}\n\nexport class ZipOperator<T, R> implements Operator<T, R> {\n\n  project: (...values: Array<any>) => R;\n\n  constructor(project?: (...values: Array<any>) => R) {\n    this.project = project;\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new ZipSubscriber(subscriber, this.project));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class ZipSubscriber<T, R> extends Subscriber<T> {\n  private values: any;\n  private project: (...values: Array<any>) => R;\n  private iterators: LookAheadIterator<any>[] = [];\n  private active = 0;\n\n  constructor(destination: Subscriber<R>,\n              project?: (...values: Array<any>) => R,\n              values: any = Object.create(null)) {\n    super(destination);\n    this.project = (typeof project === 'function') ? project : null;\n    this.values = values;\n  }\n\n  protected _next(value: any) {\n    const iterators = this.iterators;\n    if (isArray(value)) {\n      iterators.push(new StaticArrayIterator(value));\n    } else if (typeof value[Symbol_iterator] === 'function') {\n      iterators.push(new StaticIterator(value[Symbol_iterator]()));\n    } else {\n      iterators.push(new ZipBufferIterator(this.destination, this, value));\n    }\n  }\n\n  protected _complete() {\n    const iterators = this.iterators;\n    const len = iterators.length;\n\n    if (len === 0) {\n      this.destination.complete();\n      return;\n    }\n\n    this.active = len;\n    for (let i = 0; i < len; i++) {\n      let iterator: ZipBufferIterator<any, any> = <any>iterators[i];\n      if (iterator.stillUnsubscribed) {\n        this.add(iterator.subscribe(iterator, i));\n      } else {\n        this.active--; // not an observable\n      }\n    }\n  }\n\n  notifyInactive() {\n    this.active--;\n    if (this.active === 0) {\n      this.destination.complete();\n    }\n  }\n\n  checkIterators() {\n    const iterators = this.iterators;\n    const len = iterators.length;\n    const destination = this.destination;\n\n    // abort if not all of them have values\n    for (let i = 0; i < len; i++) {\n      let iterator = iterators[i];\n      if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {\n        return;\n      }\n    }\n\n    let shouldComplete = false;\n    const args: any[] = [];\n    for (let i = 0; i < len; i++) {\n      let iterator = iterators[i];\n      let result = iterator.next();\n\n      // check to see if it's completed now that you've gotten\n      // the next value.\n      if (iterator.hasCompleted()) {\n        shouldComplete = true;\n      }\n\n      if (result.done) {\n        destination.complete();\n        return;\n      }\n\n      args.push(result.value);\n    }\n\n    if (this.project) {\n      this._tryProject(args);\n    } else {\n      destination.next(args);\n    }\n\n    if (shouldComplete) {\n      destination.complete();\n    }\n  }\n\n  protected _tryProject(args: any[]) {\n    let result: any;\n    try {\n      result = this.project.apply(this, args);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(result);\n  }\n}\n\ninterface LookAheadIterator<T> extends Iterator<T> {\n  hasValue(): boolean;\n  hasCompleted(): boolean;\n}\n\nclass StaticIterator<T> implements LookAheadIterator<T> {\n  private nextResult: IteratorResult<T>;\n\n  constructor(private iterator: Iterator<T>) {\n    this.nextResult = iterator.next();\n  }\n\n  hasValue() {\n    return true;\n  }\n\n  next(): IteratorResult<T> {\n    const result = this.nextResult;\n    this.nextResult = this.iterator.next();\n    return result;\n  }\n\n  hasCompleted() {\n    const nextResult = this.nextResult;\n    return nextResult && nextResult.done;\n  }\n}\n\nclass StaticArrayIterator<T> implements LookAheadIterator<T> {\n  private index = 0;\n  private length = 0;\n\n  constructor(private array: T[]) {\n    this.length = array.length;\n  }\n\n  [Symbol_iterator]() {\n    return this;\n  }\n\n  next(value?: any): IteratorResult<T> {\n    const i = this.index++;\n    const array = this.array;\n    return i < this.length ? { value: array[i], done: false } : { value: null, done: true };\n  }\n\n  hasValue() {\n    return this.array.length > this.index;\n  }\n\n  hasCompleted() {\n    return this.array.length === this.index;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass ZipBufferIterator<T, R> extends OuterSubscriber<T, R> implements LookAheadIterator<T> {\n  stillUnsubscribed = true;\n  buffer: T[] = [];\n  isComplete = false;\n\n  constructor(destination: PartialObserver<T>,\n              private parent: ZipSubscriber<T, R>,\n              private observable: Observable<T>) {\n    super(destination);\n  }\n\n  [Symbol_iterator]() {\n    return this;\n  }\n\n  // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next\n  //    this is legit because `next()` will never be called by a subscription in this case.\n  next(): IteratorResult<T> {\n    const buffer = this.buffer;\n    if (buffer.length === 0 && this.isComplete) {\n      return { value: null, done: true };\n    } else {\n      return { value: buffer.shift(), done: false };\n    }\n  }\n\n  hasValue() {\n    return this.buffer.length > 0;\n  }\n\n  hasCompleted() {\n    return this.buffer.length === 0 && this.isComplete;\n  }\n\n  notifyComplete() {\n    if (this.buffer.length > 0) {\n      this.isComplete = true;\n      this.parent.notifyInactive();\n    } else {\n      this.destination.complete();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: any,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.buffer.push(innerValue);\n    this.parent.checkIterators();\n  }\n\n  subscribe(value: any, index: number) {\n    return subscribeToResult<any, any>(this, this.observable, this, index);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}