{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscription_1 = require('../Subscription');\n\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n\nvar OuterSubscriber_1 = require('../OuterSubscriber');\n/**\n * Buffers the source Observable values starting from an emission from\n * `openings` and ending when the output of `closingSelector` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array. Starts\n * collecting only when `opening` emits, and calls the `closingSelector`\n * function to get an Observable that tells when to close the buffer.</span>\n *\n * <img src=\"./img/bufferToggle.png\" width=\"100%\">\n *\n * Buffers values from the source by opening the buffer via signals from an\n * Observable provided to `openings`, and closing and sending the buffers when\n * a Subscribable or Promise returned by the `closingSelector` function emits.\n *\n * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var openings = Rx.Observable.interval(1000);\n * var buffered = clicks.bufferToggle(openings, i =>\n *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n * );\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferWhen}\n * @see {@link windowToggle}\n *\n * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new\n * buffers.\n * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns a Subscribable or Promise,\n * which, when it emits, signals that the associated buffer should be emitted\n * and cleared.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferToggle\n * @owner Observable\n */\n\n\nfunction bufferToggle(openings, closingSelector) {\n  return function bufferToggleOperatorFunction(source) {\n    return source.lift(new BufferToggleOperator(openings, closingSelector));\n  };\n}\n\nexports.bufferToggle = bufferToggle;\n\nvar BufferToggleOperator = function () {\n  function BufferToggleOperator(openings, closingSelector) {\n    this.openings = openings;\n    this.closingSelector = closingSelector;\n  }\n\n  BufferToggleOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));\n  };\n\n  return BufferToggleOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar BufferToggleSubscriber = function (_super) {\n  __extends(BufferToggleSubscriber, _super);\n\n  function BufferToggleSubscriber(destination, openings, closingSelector) {\n    _super.call(this, destination);\n\n    this.openings = openings;\n    this.closingSelector = closingSelector;\n    this.contexts = [];\n    this.add(subscribeToResult_1.subscribeToResult(this, openings));\n  }\n\n  BufferToggleSubscriber.prototype._next = function (value) {\n    var contexts = this.contexts;\n    var len = contexts.length;\n\n    for (var i = 0; i < len; i++) {\n      contexts[i].buffer.push(value);\n    }\n  };\n\n  BufferToggleSubscriber.prototype._error = function (err) {\n    var contexts = this.contexts;\n\n    while (contexts.length > 0) {\n      var context = contexts.shift();\n      context.subscription.unsubscribe();\n      context.buffer = null;\n      context.subscription = null;\n    }\n\n    this.contexts = null;\n\n    _super.prototype._error.call(this, err);\n  };\n\n  BufferToggleSubscriber.prototype._complete = function () {\n    var contexts = this.contexts;\n\n    while (contexts.length > 0) {\n      var context = contexts.shift();\n      this.destination.next(context.buffer);\n      context.subscription.unsubscribe();\n      context.buffer = null;\n      context.subscription = null;\n    }\n\n    this.contexts = null;\n\n    _super.prototype._complete.call(this);\n  };\n\n  BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);\n  };\n\n  BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {\n    this.closeBuffer(innerSub.context);\n  };\n\n  BufferToggleSubscriber.prototype.openBuffer = function (value) {\n    try {\n      var closingSelector = this.closingSelector;\n      var closingNotifier = closingSelector.call(this, value);\n\n      if (closingNotifier) {\n        this.trySubscribe(closingNotifier);\n      }\n    } catch (err) {\n      this._error(err);\n    }\n  };\n\n  BufferToggleSubscriber.prototype.closeBuffer = function (context) {\n    var contexts = this.contexts;\n\n    if (contexts && context) {\n      var buffer = context.buffer,\n          subscription = context.subscription;\n      this.destination.next(buffer);\n      contexts.splice(contexts.indexOf(context), 1);\n      this.remove(subscription);\n      subscription.unsubscribe();\n    }\n  };\n\n  BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {\n    var contexts = this.contexts;\n    var buffer = [];\n    var subscription = new Subscription_1.Subscription();\n    var context = {\n      buffer: buffer,\n      subscription: subscription\n    };\n    contexts.push(context);\n    var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);\n\n    if (!innerSubscription || innerSubscription.closed) {\n      this.closeBuffer(context);\n    } else {\n      innerSubscription.context = context;\n      this.add(innerSubscription);\n      subscription.add(innerSubscription);\n    }\n  };\n\n  return BufferToggleSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);","map":{"version":3,"sources":["../../src/operators/bufferToggle.ts"],"names":[],"mappings":"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","sourcesContent":["import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable, SubscribableOrPromise } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { OperatorFunction } from '../interfaces';\n\n/**\n * Buffers the source Observable values starting from an emission from\n * `openings` and ending when the output of `closingSelector` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array. Starts\n * collecting only when `opening` emits, and calls the `closingSelector`\n * function to get an Observable that tells when to close the buffer.</span>\n *\n * <img src=\"./img/bufferToggle.png\" width=\"100%\">\n *\n * Buffers values from the source by opening the buffer via signals from an\n * Observable provided to `openings`, and closing and sending the buffers when\n * a Subscribable or Promise returned by the `closingSelector` function emits.\n *\n * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var openings = Rx.Observable.interval(1000);\n * var buffered = clicks.bufferToggle(openings, i =>\n *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n * );\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferWhen}\n * @see {@link windowToggle}\n *\n * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new\n * buffers.\n * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns a Subscribable or Promise,\n * which, when it emits, signals that the associated buffer should be emitted\n * and cleared.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferToggle\n * @owner Observable\n */\nexport function bufferToggle<T, O>(\n  openings: SubscribableOrPromise<O>,\n  closingSelector: (value: O) => SubscribableOrPromise<any>\n): OperatorFunction<T, T[]> {\n  return function bufferToggleOperatorFunction(source: Observable<T>) {\n    return source.lift(new BufferToggleOperator<T, O>(openings, closingSelector));\n  };\n}\n\nclass BufferToggleOperator<T, O> implements Operator<T, T[]> {\n\n  constructor(private openings: SubscribableOrPromise<O>,\n              private closingSelector: (value: O) => SubscribableOrPromise<any>) {\n  }\n\n  call(subscriber: Subscriber<T[]>, source: any): any {\n    return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));\n  }\n}\n\ninterface BufferContext<T> {\n  buffer: T[];\n  subscription: Subscription;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass BufferToggleSubscriber<T, O> extends OuterSubscriber<T, O> {\n  private contexts: Array<BufferContext<T>> = [];\n\n  constructor(destination: Subscriber<T[]>,\n              private openings: SubscribableOrPromise<O>,\n              private closingSelector: (value: O) => SubscribableOrPromise<any> | void) {\n    super(destination);\n    this.add(subscribeToResult(this, openings));\n  }\n\n  protected _next(value: T): void {\n    const contexts = this.contexts;\n    const len = contexts.length;\n    for (let i = 0; i < len; i++) {\n      contexts[i].buffer.push(value);\n    }\n  }\n\n  protected _error(err: any): void {\n    const contexts = this.contexts;\n    while (contexts.length > 0) {\n      const context = contexts.shift();\n      context.subscription.unsubscribe();\n      context.buffer = null;\n      context.subscription = null;\n    }\n    this.contexts = null;\n    super._error(err);\n  }\n\n  protected _complete(): void {\n    const contexts = this.contexts;\n    while (contexts.length > 0) {\n      const context = contexts.shift();\n      this.destination.next(context.buffer);\n      context.subscription.unsubscribe();\n      context.buffer = null;\n      context.subscription = null;\n    }\n    this.contexts = null;\n    super._complete();\n  }\n\n  notifyNext(outerValue: any, innerValue: O,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, O>): void {\n    outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);\n  }\n\n  notifyComplete(innerSub: InnerSubscriber<T, O>): void {\n    this.closeBuffer((<any> innerSub).context);\n  }\n\n  private openBuffer(value: O): void {\n    try {\n      const closingSelector = this.closingSelector;\n      const closingNotifier = closingSelector.call(this, value);\n      if (closingNotifier) {\n        this.trySubscribe(closingNotifier);\n      }\n    } catch (err) {\n      this._error(err);\n    }\n  }\n\n  private closeBuffer(context: BufferContext<T>): void {\n    const contexts = this.contexts;\n\n    if (contexts && context) {\n      const { buffer, subscription } = context;\n      this.destination.next(buffer);\n      contexts.splice(contexts.indexOf(context), 1);\n      this.remove(subscription);\n      subscription.unsubscribe();\n    }\n  }\n\n  private trySubscribe(closingNotifier: any): void {\n    const contexts = this.contexts;\n\n    const buffer: Array<T> = [];\n    const subscription = new Subscription();\n    const context = { buffer, subscription };\n    contexts.push(context);\n\n    const innerSubscription = subscribeToResult(this, closingNotifier, <any>context);\n\n    if (!innerSubscription || innerSubscription.closed) {\n      this.closeBuffer(context);\n    } else {\n      (<any> innerSubscription).context = context;\n\n      this.add(innerSubscription);\n      subscription.add(innerSubscription);\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}