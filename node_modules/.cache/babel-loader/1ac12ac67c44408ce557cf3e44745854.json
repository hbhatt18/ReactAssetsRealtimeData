{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar isFunction_1 = require('../util/isFunction');\n\nvar Observable_1 = require('../Observable');\n\nvar Subscription_1 = require('../Subscription');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar FromEventPatternObservable = function (_super) {\n  __extends(FromEventPatternObservable, _super);\n\n  function FromEventPatternObservable(addHandler, removeHandler, selector) {\n    _super.call(this);\n\n    this.addHandler = addHandler;\n    this.removeHandler = removeHandler;\n    this.selector = selector;\n  }\n  /**\n   * Creates an Observable from an API based on addHandler/removeHandler\n   * functions.\n   *\n   * <span class=\"informal\">Converts any addHandler/removeHandler API to an\n   * Observable.</span>\n   *\n   * <img src=\"./img/fromEventPattern.png\" width=\"100%\">\n   *\n   * Creates an Observable by using the `addHandler` and `removeHandler`\n   * functions to add and remove the handlers, with an optional selector\n   * function to project the event arguments to a result. The `addHandler` is\n   * called when the output Observable is subscribed, and `removeHandler` is\n   * called when the Subscription is unsubscribed.\n   *\n   * @example <caption>Emits clicks happening on the DOM document</caption>\n   * function addClickHandler(handler) {\n   *   document.addEventListener('click', handler);\n   * }\n   *\n   * function removeClickHandler(handler) {\n   *   document.removeEventListener('click', handler);\n   * }\n   *\n   * var clicks = Rx.Observable.fromEventPattern(\n   *   addClickHandler,\n   *   removeClickHandler\n   * );\n   * clicks.subscribe(x => console.log(x));\n   *\n   * @see {@link from}\n   * @see {@link fromEvent}\n   *\n   * @param {function(handler: Function): any} addHandler A function that takes\n   * a `handler` function as argument and attaches it somehow to the actual\n   * source of events.\n   * @param {function(handler: Function, signal?: any): void} [removeHandler] An optional function that\n   * takes a `handler` function as argument and removes it in case it was\n   * previously attached using `addHandler`. if addHandler returns signal to teardown when remove,\n   * removeHandler function will forward it.\n   * @param {function(...args: any): T} [selector] An optional function to\n   * post-process results. It takes the arguments from the event handler and\n   * should return a single value.\n   * @return {Observable<T>}\n   * @static true\n   * @name fromEventPattern\n   * @owner Observable\n   */\n\n\n  FromEventPatternObservable.create = function (addHandler, removeHandler, selector) {\n    return new FromEventPatternObservable(addHandler, removeHandler, selector);\n  };\n  /** @deprecated internal use only */\n\n\n  FromEventPatternObservable.prototype._subscribe = function (subscriber) {\n    var _this = this;\n\n    var removeHandler = this.removeHandler;\n    var handler = !!this.selector ? function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i - 0] = arguments[_i];\n      }\n\n      _this._callSelector(subscriber, args);\n    } : function (e) {\n      subscriber.next(e);\n    };\n\n    var retValue = this._callAddHandler(handler, subscriber);\n\n    if (!isFunction_1.isFunction(removeHandler)) {\n      return;\n    }\n\n    subscriber.add(new Subscription_1.Subscription(function () {\n      //TODO: determine whether or not to forward to error handler\n      removeHandler(handler, retValue);\n    }));\n  };\n\n  FromEventPatternObservable.prototype._callSelector = function (subscriber, args) {\n    try {\n      var result = this.selector.apply(this, args);\n      subscriber.next(result);\n    } catch (e) {\n      subscriber.error(e);\n    }\n  };\n\n  FromEventPatternObservable.prototype._callAddHandler = function (handler, errorSubscriber) {\n    try {\n      return this.addHandler(handler) || null;\n    } catch (e) {\n      errorSubscriber.error(e);\n    }\n  };\n\n  return FromEventPatternObservable;\n}(Observable_1.Observable);\n\nexports.FromEventPatternObservable = FromEventPatternObservable;","map":{"version":3,"sources":["../../src/observable/FromEventPatternObservable.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,IAAA,YAAA,GAAA,OAAA,CAA2B,oBAA3B,CAAA;;AACA,IAAA,YAAA,GAAA,OAAA,CAA2B,eAA3B,CAAA;;AACA,IAAA,cAAA,GAAA,OAAA,CAA6B,iBAA7B,CAAA;AAGA;;;;;;;AAKA,IAAA,0BAAA,GAAA,UAAA,MAAA,EAAA;AAAmD,EAAA,SAAA,CAAA,0BAAA,EAAA,MAAA,CAAA;;AAwDjD,WAAA,0BAAA,CAAoB,UAApB,EACoB,aADpB,EAEoB,QAFpB,EAEyD;AACvD,IAAA,MAAA,CAAA,IAAA,CAAA,IAAA;;AAHkB,SAAA,UAAA,GAAA,UAAA;AACA,SAAA,aAAA,GAAA,aAAA;AACA,SAAA,QAAA,GAAA,QAAA;AAEnB;AA1DD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgDO,EAAA,0BAAA,CAAA,MAAA,GAAP,UAAiB,UAAjB,EACiB,aADjB,EAEiB,QAFjB,EAEsD;AACpD,WAAO,IAAI,0BAAJ,CAA+B,UAA/B,EAA2C,aAA3C,EAA0D,QAA1D,CAAP;AACD,GAJM;AAYP;;;AAAqC,EAAA,0BAAA,CAAA,SAAA,CAAA,UAAA,GAAA,UAAW,UAAX,EAAoC;AAApC,QAAA,KAAA,GAAA,IAAA;;AACnC,QAAM,aAAa,GAAG,KAAK,aAA3B;AAEA,QAAM,OAAO,GAAG,CAAC,CAAC,KAAK,QAAP,GAAkB,YAAA;AAAC,UAAA,IAAA,GAAA,EAAA;;WAAA,IAAA,EAAA,GAAA,C,EAAA,EAAA,GAAA,SAAA,CAAA,M,EAAA,EAAA,E,EAAmB;AAAnB,QAAA,IAAA,CAAA,EAAA,GAAA,CAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;;AACjC,MAAA,KAAI,CAAC,aAAL,CAAmB,UAAnB,EAA+B,IAA/B;AACD,KAFe,GAEZ,UAAS,CAAT,EAAe;AAAI,MAAA,UAAU,CAAC,IAAX,CAAgB,CAAhB;AAAqB,KAF5C;;AAIA,QAAM,QAAQ,GAAG,KAAK,eAAL,CAAqB,OAArB,EAA8B,UAA9B,CAAjB;;AAEA,QAAI,CAAC,YAAA,CAAA,UAAA,CAAW,aAAX,CAAL,EAAgC;AAC9B;AACD;;AAED,IAAA,UAAU,CAAC,GAAX,CAAe,IAAI,cAAA,CAAA,YAAJ,CAAiB,YAAA;AAC9B;AACA,MAAA,aAAa,CAAC,OAAD,EAAU,QAAV,CAAb;AACD,KAHc,CAAf;AAID,GAjBoC;;AAmB7B,EAAA,0BAAA,CAAA,SAAA,CAAA,aAAA,GAAR,UAAsB,UAAtB,EAAiD,IAAjD,EAAiE;AAC/D,QAAI;AACF,UAAM,MAAM,GAAM,KAAK,QAAL,CAAa,KAAb,CAAA,IAAA,EAAiB,IAAjB,CAAlB;AACA,MAAA,UAAU,CAAC,IAAX,CAAgB,MAAhB;AAEF,KAJA,CAIA,OAAO,CAAP,EAAU;AACR,MAAA,UAAU,CAAC,KAAX,CAAiB,CAAjB;AACD;AACF,GARO;;AAUA,EAAA,0BAAA,CAAA,SAAA,CAAA,eAAA,GAAR,UAAwB,OAAxB,EAAmD,eAAnD,EAAiF;AAC/E,QAAI;AACF,aAAO,KAAK,UAAL,CAAgB,OAAhB,KAA4B,IAAnC;AAEF,KAHA,CAGA,OAAO,CAAP,EAAU;AACR,MAAA,eAAe,CAAC,KAAhB,CAAsB,CAAtB;AACD;AACF,GAPO;;AAQV,SAAA,0BAAA;AAAC,CAnGD,CAAmD,YAAA,CAAA,UAAnD,CAAA;;AAAa,OAAA,CAAA,0BAAA,GAA0B,0BAA1B","sourcesContent":["import { isFunction } from '../util/isFunction';\nimport { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { Subscriber } from '../Subscriber';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class FromEventPatternObservable<T> extends Observable<T> {\n\n  /**\n   * Creates an Observable from an API based on addHandler/removeHandler\n   * functions.\n   *\n   * <span class=\"informal\">Converts any addHandler/removeHandler API to an\n   * Observable.</span>\n   *\n   * <img src=\"./img/fromEventPattern.png\" width=\"100%\">\n   *\n   * Creates an Observable by using the `addHandler` and `removeHandler`\n   * functions to add and remove the handlers, with an optional selector\n   * function to project the event arguments to a result. The `addHandler` is\n   * called when the output Observable is subscribed, and `removeHandler` is\n   * called when the Subscription is unsubscribed.\n   *\n   * @example <caption>Emits clicks happening on the DOM document</caption>\n   * function addClickHandler(handler) {\n   *   document.addEventListener('click', handler);\n   * }\n   *\n   * function removeClickHandler(handler) {\n   *   document.removeEventListener('click', handler);\n   * }\n   *\n   * var clicks = Rx.Observable.fromEventPattern(\n   *   addClickHandler,\n   *   removeClickHandler\n   * );\n   * clicks.subscribe(x => console.log(x));\n   *\n   * @see {@link from}\n   * @see {@link fromEvent}\n   *\n   * @param {function(handler: Function): any} addHandler A function that takes\n   * a `handler` function as argument and attaches it somehow to the actual\n   * source of events.\n   * @param {function(handler: Function, signal?: any): void} [removeHandler] An optional function that\n   * takes a `handler` function as argument and removes it in case it was\n   * previously attached using `addHandler`. if addHandler returns signal to teardown when remove,\n   * removeHandler function will forward it.\n   * @param {function(...args: any): T} [selector] An optional function to\n   * post-process results. It takes the arguments from the event handler and\n   * should return a single value.\n   * @return {Observable<T>}\n   * @static true\n   * @name fromEventPattern\n   * @owner Observable\n   */\n  static create<T>(addHandler: (handler: Function) => any,\n                   removeHandler?: (handler: Function, signal?: any) => void,\n                   selector?: (...args: Array<any>) => T) {\n    return new FromEventPatternObservable(addHandler, removeHandler, selector);\n  }\n\n  constructor(private addHandler: (handler: Function) => any,\n              private removeHandler?: (handler: Function, signal?: any) => void,\n              private selector?: (...args: Array<any>) => T) {\n    super();\n  }\n\n  /** @deprecated internal use only */ _subscribe(subscriber: Subscriber<T>) {\n    const removeHandler = this.removeHandler;\n\n    const handler = !!this.selector ? (...args: Array<any>) => {\n      this._callSelector(subscriber, args);\n    } : function(e: any) { subscriber.next(e); };\n\n    const retValue = this._callAddHandler(handler, subscriber);\n\n    if (!isFunction(removeHandler)) {\n      return;\n    }\n\n    subscriber.add(new Subscription(() => {\n      //TODO: determine whether or not to forward to error handler\n      removeHandler(handler, retValue) ;\n    }));\n  }\n\n  private _callSelector(subscriber: Subscriber<T>, args: Array<any>): void {\n    try {\n      const result: T = this.selector(...args);\n      subscriber.next(result);\n    }\n    catch (e) {\n      subscriber.error(e);\n    }\n  }\n\n  private _callAddHandler(handler: (e: any) => void, errorSubscriber: Subscriber<T>): any | null {\n    try {\n      return this.addHandler(handler) || null;\n    }\n    catch (e) {\n      errorSubscriber.error(e);\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}