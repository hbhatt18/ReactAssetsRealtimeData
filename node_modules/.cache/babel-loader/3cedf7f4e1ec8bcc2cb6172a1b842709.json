{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = require('../Subscriber');\n\nvar async_1 = require('../scheduler/async');\n\nvar throttle_1 = require('./throttle');\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for `duration` milliseconds, then repeats this process.\n *\n * <span class=\"informal\">Lets a value pass, then ignores source values for the\n * next `duration` milliseconds.</span>\n *\n * <img src=\"./img/throttleTime.png\" width=\"100%\">\n *\n * `throttleTime` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled. After `duration` milliseconds (or the time unit determined\n * internally by the optional `scheduler`) has passed, the timer is disabled,\n * and this process repeats for the next source value. Optionally takes a\n * {@link IScheduler} for managing timers.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.throttleTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {number} duration Time to wait before emitting another value after\n * emitting the last value, measured in milliseconds or the time unit determined\n * internally by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the throttling.\n * @return {Observable<T>} An Observable that performs the throttle operation to\n * limit the rate of emissions from the source.\n * @method throttleTime\n * @owner Observable\n */\n\n\nfunction throttleTime(duration, scheduler, config) {\n  if (scheduler === void 0) {\n    scheduler = async_1.async;\n  }\n\n  if (config === void 0) {\n    config = throttle_1.defaultThrottleConfig;\n  }\n\n  return function (source) {\n    return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing));\n  };\n}\n\nexports.throttleTime = throttleTime;\n\nvar ThrottleTimeOperator = function () {\n  function ThrottleTimeOperator(duration, scheduler, leading, trailing) {\n    this.duration = duration;\n    this.scheduler = scheduler;\n    this.leading = leading;\n    this.trailing = trailing;\n  }\n\n  ThrottleTimeOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));\n  };\n\n  return ThrottleTimeOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar ThrottleTimeSubscriber = function (_super) {\n  __extends(ThrottleTimeSubscriber, _super);\n\n  function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {\n    _super.call(this, destination);\n\n    this.duration = duration;\n    this.scheduler = scheduler;\n    this.leading = leading;\n    this.trailing = trailing;\n    this._hasTrailingValue = false;\n    this._trailingValue = null;\n  }\n\n  ThrottleTimeSubscriber.prototype._next = function (value) {\n    if (this.throttled) {\n      if (this.trailing) {\n        this._trailingValue = value;\n        this._hasTrailingValue = true;\n      }\n    } else {\n      this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, {\n        subscriber: this\n      }));\n\n      if (this.leading) {\n        this.destination.next(value);\n      }\n    }\n  };\n\n  ThrottleTimeSubscriber.prototype.clearThrottle = function () {\n    var throttled = this.throttled;\n\n    if (throttled) {\n      if (this.trailing && this._hasTrailingValue) {\n        this.destination.next(this._trailingValue);\n        this._trailingValue = null;\n        this._hasTrailingValue = false;\n      }\n\n      throttled.unsubscribe();\n      this.remove(throttled);\n      this.throttled = null;\n    }\n  };\n\n  return ThrottleTimeSubscriber;\n}(Subscriber_1.Subscriber);\n\nfunction dispatchNext(arg) {\n  var subscriber = arg.subscriber;\n  subscriber.clearThrottle();\n}","map":{"version":3,"sources":["../../src/operators/throttleTime.ts"],"names":[],"mappings":";;;;;;;;;;;;AACA,IAAA,YAAA,GAAA,OAAA,CAA2B,eAA3B,CAAA;;AAGA,IAAA,OAAA,GAAA,OAAA,CAAsB,oBAAtB,CAAA;;AAEA,IAAA,UAAA,GAAA,OAAA,CAAsD,YAAtD,CAAA;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCA,SAAA,YAAA,CAAgC,QAAhC,EACgC,SADhC,EAEgC,MAFhC,EAE8E;AAD9C,MAAA,SAAA,KAAA,KAAA,CAAA,EAA6B;AAA7B,IAAA,SAAA,GAAA,OAAA,CAAA,KAAA;AAA6B;;AAC7B,MAAA,MAAA,KAAA,KAAA,CAAA,EAA8C;AAA9C,IAAA,MAAA,GAAA,UAAA,CAAA,qBAAA;AAA8C;;AAC5E,SAAO,UAAC,MAAD,EAAsB;AAAK,WAAA,MAAM,CAAC,IAAP,CAAY,IAAI,oBAAJ,CAAyB,QAAzB,EAAmC,SAAnC,EAA8C,MAAM,CAAC,OAArD,EAA8D,MAAM,CAAhF,QAAY,CAAZ,CAAA;AAA2F,GAA7H;AACD;;AAJe,OAAA,CAAA,YAAA,GAAY,YAAZ;;AAMhB,IAAA,oBAAA,GAAA,YAAA;AACE,WAAA,oBAAA,CAAoB,QAApB,EACoB,SADpB,EAEoB,OAFpB,EAGoB,QAHpB,EAGqC;AAHjB,SAAA,QAAA,GAAA,QAAA;AACA,SAAA,SAAA,GAAA,SAAA;AACA,SAAA,OAAA,GAAA,OAAA;AACA,SAAA,QAAA,GAAA,QAAA;AACnB;;AAED,EAAA,oBAAA,CAAA,SAAA,CAAA,IAAA,GAAA,UAAK,UAAL,EAAgC,MAAhC,EAA2C;AACzC,WAAO,MAAM,CAAC,SAAP,CACL,IAAI,sBAAJ,CAA2B,UAA3B,EAAuC,KAAK,QAA5C,EAAsD,KAAK,SAA3D,EAAsE,KAAK,OAA3E,EAAoF,KAAK,QAAzF,CADK,CAAP;AAGD,GAJD;;AAKF,SAAA,oBAAA;AAAC,CAZD,EAAA;AAcA;;;;;;;AAKA,IAAA,sBAAA,GAAA,UAAA,MAAA,EAAA;AAAwC,EAAA,SAAA,CAAA,sBAAA,EAAA,MAAA,CAAA;;AAKtC,WAAA,sBAAA,CAAY,WAAZ,EACoB,QADpB,EAEoB,SAFpB,EAGoB,OAHpB,EAIoB,QAJpB,EAIqC;AACnC,IAAA,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,WAAN;;AAJkB,SAAA,QAAA,GAAA,QAAA;AACA,SAAA,SAAA,GAAA,SAAA;AACA,SAAA,OAAA,GAAA,OAAA;AACA,SAAA,QAAA,GAAA,QAAA;AAPZ,SAAA,iBAAA,GAA6B,KAA7B;AACA,SAAA,cAAA,GAAoB,IAApB;AAQP;;AAES,EAAA,sBAAA,CAAA,SAAA,CAAA,KAAA,GAAV,UAAgB,KAAhB,EAAwB;AACtB,QAAI,KAAK,SAAT,EAAoB;AAClB,UAAI,KAAK,QAAT,EAAmB;AACjB,aAAK,cAAL,GAAsB,KAAtB;AACA,aAAK,iBAAL,GAAyB,IAAzB;AACD;AACF,KALD,MAKO;AACL,WAAK,GAAL,CAAS,KAAK,SAAL,GAAiB,KAAK,SAAL,CAAe,QAAf,CAAwB,YAAxB,EAAsC,KAAK,QAA3C,EAAqD;AAAE,QAAA,UAAU,EAAE;AAAd,OAArD,CAA1B;;AACA,UAAI,KAAK,OAAT,EAAkB;AAChB,aAAK,WAAL,CAAiB,IAAjB,CAAsB,KAAtB;AACD;AACF;AACF,GAZS;;AAcV,EAAA,sBAAA,CAAA,SAAA,CAAA,aAAA,GAAA,YAAA;AACE,QAAM,SAAS,GAAG,KAAK,SAAvB;;AACA,QAAI,SAAJ,EAAe;AACb,UAAI,KAAK,QAAL,IAAiB,KAAK,iBAA1B,EAA6C;AAC3C,aAAK,WAAL,CAAiB,IAAjB,CAAsB,KAAK,cAA3B;AACA,aAAK,cAAL,GAAsB,IAAtB;AACA,aAAK,iBAAL,GAAyB,KAAzB;AACD;;AACD,MAAA,SAAS,CAAC,WAAV;AACA,WAAK,MAAL,CAAY,SAAZ;AACA,WAAK,SAAL,GAAiB,IAAjB;AACD;AACF,GAZD;;AAaF,SAAA,sBAAA;AAAC,CAxCD,CAAwC,YAAA,CAAA,UAAxC,CAAA;;AA8CA,SAAA,YAAA,CAAyB,GAAzB,EAA4C;AAClC,MAAA,UAAA,GAAA,GAAA,CAAA,UAAA;AACR,EAAA,UAAU,CAAC,aAAX;AACD","sourcesContent":["import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { IScheduler } from '../Scheduler';\nimport { Subscription, TeardownLogic } from '../Subscription';\nimport { async } from '../scheduler/async';\nimport { Observable } from '../Observable';\nimport { ThrottleConfig, defaultThrottleConfig } from './throttle';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for `duration` milliseconds, then repeats this process.\n *\n * <span class=\"informal\">Lets a value pass, then ignores source values for the\n * next `duration` milliseconds.</span>\n *\n * <img src=\"./img/throttleTime.png\" width=\"100%\">\n *\n * `throttleTime` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled. After `duration` milliseconds (or the time unit determined\n * internally by the optional `scheduler`) has passed, the timer is disabled,\n * and this process repeats for the next source value. Optionally takes a\n * {@link IScheduler} for managing timers.\n *\n * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.throttleTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {number} duration Time to wait before emitting another value after\n * emitting the last value, measured in milliseconds or the time unit determined\n * internally by the optional `scheduler`.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the throttling.\n * @return {Observable<T>} An Observable that performs the throttle operation to\n * limit the rate of emissions from the source.\n * @method throttleTime\n * @owner Observable\n */\nexport function throttleTime<T>(duration: number,\n                                scheduler: IScheduler = async,\n                                config: ThrottleConfig = defaultThrottleConfig): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing));\n}\n\nclass ThrottleTimeOperator<T> implements Operator<T, T> {\n  constructor(private duration: number,\n              private scheduler: IScheduler,\n              private leading: boolean,\n              private trailing: boolean) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(\n      new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing)\n    );\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass ThrottleTimeSubscriber<T> extends Subscriber<T> {\n  private throttled: Subscription;\n  private _hasTrailingValue: boolean = false;\n  private _trailingValue: T = null;\n\n  constructor(destination: Subscriber<T>,\n              private duration: number,\n              private scheduler: IScheduler,\n              private leading: boolean,\n              private trailing: boolean) {\n    super(destination);\n  }\n\n  protected _next(value: T) {\n    if (this.throttled) {\n      if (this.trailing) {\n        this._trailingValue = value;\n        this._hasTrailingValue = true;\n      }\n    } else {\n      this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));\n      if (this.leading) {\n        this.destination.next(value);\n      }\n    }\n  }\n\n  clearThrottle() {\n    const throttled = this.throttled;\n    if (throttled) {\n      if (this.trailing && this._hasTrailingValue) {\n        this.destination.next(this._trailingValue);\n        this._trailingValue = null;\n        this._hasTrailingValue = false;\n      }\n      throttled.unsubscribe();\n      this.remove(throttled);\n      this.throttled = null;\n    }\n  }\n}\n\ninterface DispatchArg<T> {\n  subscriber: ThrottleTimeSubscriber<T>;\n}\n\nfunction dispatchNext<T>(arg: DispatchArg<T>) {\n  const { subscriber } = arg;\n  subscriber.clearThrottle();\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}