{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Observable_1 = require('../Observable');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar RangeObservable = function (_super) {\n  __extends(RangeObservable, _super);\n\n  function RangeObservable(start, count, scheduler) {\n    _super.call(this);\n\n    this.start = start;\n    this._count = count;\n    this.scheduler = scheduler;\n  }\n  /**\n   * Creates an Observable that emits a sequence of numbers within a specified\n   * range.\n   *\n   * <span class=\"informal\">Emits a sequence of numbers in a range.</span>\n   *\n   * <img src=\"./img/range.png\" width=\"100%\">\n   *\n   * `range` operator emits a range of sequential integers, in order, where you\n   * select the `start` of the range and its `length`. By default, uses no\n   * IScheduler and just delivers the notifications synchronously, but may use\n   * an optional IScheduler to regulate those deliveries.\n   *\n   * @example <caption>Emits the numbers 1 to 10</caption>\n   * var numbers = Rx.Observable.range(1, 10);\n   * numbers.subscribe(x => console.log(x));\n   *\n   * @see {@link timer}\n   * @see {@link interval}\n   *\n   * @param {number} [start=0] The value of the first integer in the sequence.\n   * @param {number} [count=0] The number of sequential integers to generate.\n   * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n   * the emissions of the notifications.\n   * @return {Observable} An Observable of numbers that emits a finite range of\n   * sequential integers.\n   * @static true\n   * @name range\n   * @owner Observable\n   */\n\n\n  RangeObservable.create = function (start, count, scheduler) {\n    if (start === void 0) {\n      start = 0;\n    }\n\n    if (count === void 0) {\n      count = 0;\n    }\n\n    return new RangeObservable(start, count, scheduler);\n  };\n\n  RangeObservable.dispatch = function (state) {\n    var start = state.start,\n        index = state.index,\n        count = state.count,\n        subscriber = state.subscriber;\n\n    if (index >= count) {\n      subscriber.complete();\n      return;\n    }\n\n    subscriber.next(start);\n\n    if (subscriber.closed) {\n      return;\n    }\n\n    state.index = index + 1;\n    state.start = start + 1;\n    this.schedule(state);\n  };\n  /** @deprecated internal use only */\n\n\n  RangeObservable.prototype._subscribe = function (subscriber) {\n    var index = 0;\n    var start = this.start;\n    var count = this._count;\n    var scheduler = this.scheduler;\n\n    if (scheduler) {\n      return scheduler.schedule(RangeObservable.dispatch, 0, {\n        index: index,\n        count: count,\n        start: start,\n        subscriber: subscriber\n      });\n    } else {\n      do {\n        if (index++ >= count) {\n          subscriber.complete();\n          break;\n        }\n\n        subscriber.next(start++);\n\n        if (subscriber.closed) {\n          break;\n        }\n      } while (true);\n    }\n  };\n\n  return RangeObservable;\n}(Observable_1.Observable);\n\nexports.RangeObservable = RangeObservable;","map":{"version":3,"sources":["../../src/observable/RangeObservable.ts"],"names":[],"mappings":";;;;;;;;;;;;AACA,IAAA,YAAA,GAAA,OAAA,CAA2B,eAA3B,CAAA;AAIA;;;;;;;AAKA,IAAA,eAAA,GAAA,UAAA,MAAA,EAAA;AAAqC,EAAA,SAAA,CAAA,eAAA,EAAA,MAAA,CAAA;;AA+DnC,WAAA,eAAA,CAAY,KAAZ,EACY,KADZ,EAEY,SAFZ,EAEkC;AAChC,IAAA,MAAA,CAAA,IAAA,CAAA,IAAA;;AACA,SAAK,KAAL,GAAa,KAAb;AACA,SAAK,MAAL,GAAc,KAAd;AACA,SAAK,SAAL,GAAiB,SAAjB;AACD;AApED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BO,EAAA,eAAA,CAAA,MAAA,GAAP,UAAc,KAAd,EACc,KADd,EAEc,SAFd,EAEoC;AAFtB,QAAA,KAAA,KAAA,KAAA,CAAA,EAAiB;AAAjB,MAAA,KAAA,GAAA,CAAA;AAAiB;;AACjB,QAAA,KAAA,KAAA,KAAA,CAAA,EAAiB;AAAjB,MAAA,KAAA,GAAA,CAAA;AAAiB;;AAE7B,WAAO,IAAI,eAAJ,CAAoB,KAApB,EAA2B,KAA3B,EAAkC,SAAlC,CAAP;AACD,GAJM;;AAMA,EAAA,eAAA,CAAA,QAAA,GAAP,UAAgB,KAAhB,EAA0B;AAEhB,QAAA,KAAA,GAAA,KAAA,CAAA,KAAA;AAAA,QAAO,KAAA,GAAA,KAAA,CAAA,KAAP;AAAA,QAAc,KAAA,GAAA,KAAA,CAAA,KAAd;AAAA,QAAqB,UAAA,GAAA,KAAA,CAAA,UAArB;;AAER,QAAI,KAAK,IAAI,KAAb,EAAoB;AAClB,MAAA,UAAU,CAAC,QAAX;AACA;AACD;;AAED,IAAA,UAAU,CAAC,IAAX,CAAgB,KAAhB;;AAEA,QAAI,UAAU,CAAC,MAAf,EAAuB;AACrB;AACD;;AAED,IAAA,KAAK,CAAC,KAAN,GAAc,KAAK,GAAG,CAAtB;AACA,IAAA,KAAK,CAAC,KAAN,GAAc,KAAK,GAAG,CAAtB;AAEO,SAAM,QAAN,CAAe,KAAf;AACR,GAnBM;AAkCP;;;AAAqC,EAAA,eAAA,CAAA,SAAA,CAAA,UAAA,GAAA,UAAW,UAAX,EAAyC;AAC5E,QAAI,KAAK,GAAG,CAAZ;AACA,QAAI,KAAK,GAAG,KAAK,KAAjB;AACA,QAAM,KAAK,GAAG,KAAK,MAAnB;AACA,QAAM,SAAS,GAAG,KAAK,SAAvB;;AAEA,QAAI,SAAJ,EAAe;AACb,aAAO,SAAS,CAAC,QAAV,CAAmB,eAAe,CAAC,QAAnC,EAA6C,CAA7C,EAAgD;AACrD,QAAA,KAAA,EAAA,KADqD;AAC9C,QAAA,KAAA,EAAA,KAD8C;AACvC,QAAA,KAAA,EAAA,KADuC;AAChC,QAAA,UAAA,EAAA;AADgC,OAAhD,CAAP;AAGD,KAJD,MAIO;AACL,SAAG;AACD,YAAI,KAAK,MAAM,KAAf,EAAsB;AACpB,UAAA,UAAU,CAAC,QAAX;AACA;AACD;;AACD,QAAA,UAAU,CAAC,IAAX,CAAgB,KAAK,EAArB;;AACA,YAAI,UAAU,CAAC,MAAf,EAAuB;AACrB;AACD;AACF,OATD,QASS,IATT;AAUD;AACF,GAtBoC;;AAuBvC,SAAA,eAAA;AAAC,CA/FD,CAAqC,YAAA,CAAA,UAArC,CAAA;;AAAa,OAAA,CAAA,eAAA,GAAe,eAAf","sourcesContent":["import { IScheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { TeardownLogic } from '../Subscription';\nimport { Subscriber } from '../Subscriber';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class RangeObservable extends Observable<number> {\n\n  /**\n   * Creates an Observable that emits a sequence of numbers within a specified\n   * range.\n   *\n   * <span class=\"informal\">Emits a sequence of numbers in a range.</span>\n   *\n   * <img src=\"./img/range.png\" width=\"100%\">\n   *\n   * `range` operator emits a range of sequential integers, in order, where you\n   * select the `start` of the range and its `length`. By default, uses no\n   * IScheduler and just delivers the notifications synchronously, but may use\n   * an optional IScheduler to regulate those deliveries.\n   *\n   * @example <caption>Emits the numbers 1 to 10</caption>\n   * var numbers = Rx.Observable.range(1, 10);\n   * numbers.subscribe(x => console.log(x));\n   *\n   * @see {@link timer}\n   * @see {@link interval}\n   *\n   * @param {number} [start=0] The value of the first integer in the sequence.\n   * @param {number} [count=0] The number of sequential integers to generate.\n   * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n   * the emissions of the notifications.\n   * @return {Observable} An Observable of numbers that emits a finite range of\n   * sequential integers.\n   * @static true\n   * @name range\n   * @owner Observable\n   */\n  static create(start: number = 0,\n                count: number = 0,\n                scheduler?: IScheduler): Observable<number> {\n    return new RangeObservable(start, count, scheduler);\n  }\n\n  static dispatch(state: any) {\n\n    const { start, index, count, subscriber } = state;\n\n    if (index >= count) {\n      subscriber.complete();\n      return;\n    }\n\n    subscriber.next(start);\n\n    if (subscriber.closed) {\n      return;\n    }\n\n    state.index = index + 1;\n    state.start = start + 1;\n\n    (<any> this).schedule(state);\n  }\n\n  private start: number;\n  private _count: number;\n  private scheduler: IScheduler;\n\n  constructor(start: number,\n              count: number,\n              scheduler?: IScheduler) {\n    super();\n    this.start = start;\n    this._count = count;\n    this.scheduler = scheduler;\n  }\n\n  /** @deprecated internal use only */ _subscribe(subscriber: Subscriber<number>): TeardownLogic {\n    let index = 0;\n    let start = this.start;\n    const count = this._count;\n    const scheduler = this.scheduler;\n\n    if (scheduler) {\n      return scheduler.schedule(RangeObservable.dispatch, 0, {\n        index, count, start, subscriber\n      });\n    } else {\n      do {\n        if (index++ >= count) {\n          subscriber.complete();\n          break;\n        }\n        subscriber.next(start++);\n        if (subscriber.closed) {\n          break;\n        }\n      } while (true);\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}