{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Observable_1 = require('../Observable');\n\nvar Notification_1 = require('../Notification');\n\nvar ColdObservable_1 = require('./ColdObservable');\n\nvar HotObservable_1 = require('./HotObservable');\n\nvar SubscriptionLog_1 = require('./SubscriptionLog');\n\nvar VirtualTimeScheduler_1 = require('../scheduler/VirtualTimeScheduler');\n\nvar defaultMaxFrame = 750;\n\nvar TestScheduler = function (_super) {\n  __extends(TestScheduler, _super);\n\n  function TestScheduler(assertDeepEqual) {\n    _super.call(this, VirtualTimeScheduler_1.VirtualAction, defaultMaxFrame);\n\n    this.assertDeepEqual = assertDeepEqual;\n    this.hotObservables = [];\n    this.coldObservables = [];\n    this.flushTests = [];\n  }\n\n  TestScheduler.prototype.createTime = function (marbles) {\n    var indexOf = marbles.indexOf('|');\n\n    if (indexOf === -1) {\n      throw new Error('marble diagram for time should have a completion marker \"|\"');\n    }\n\n    return indexOf * TestScheduler.frameTimeFactor;\n  };\n\n  TestScheduler.prototype.createColdObservable = function (marbles, values, error) {\n    if (marbles.indexOf('^') !== -1) {\n      throw new Error('cold observable cannot have subscription offset \"^\"');\n    }\n\n    if (marbles.indexOf('!') !== -1) {\n      throw new Error('cold observable cannot have unsubscription marker \"!\"');\n    }\n\n    var messages = TestScheduler.parseMarbles(marbles, values, error);\n    var cold = new ColdObservable_1.ColdObservable(messages, this);\n    this.coldObservables.push(cold);\n    return cold;\n  };\n\n  TestScheduler.prototype.createHotObservable = function (marbles, values, error) {\n    if (marbles.indexOf('!') !== -1) {\n      throw new Error('hot observable cannot have unsubscription marker \"!\"');\n    }\n\n    var messages = TestScheduler.parseMarbles(marbles, values, error);\n    var subject = new HotObservable_1.HotObservable(messages, this);\n    this.hotObservables.push(subject);\n    return subject;\n  };\n\n  TestScheduler.prototype.materializeInnerObservable = function (observable, outerFrame) {\n    var _this = this;\n\n    var messages = [];\n    observable.subscribe(function (value) {\n      messages.push({\n        frame: _this.frame - outerFrame,\n        notification: Notification_1.Notification.createNext(value)\n      });\n    }, function (err) {\n      messages.push({\n        frame: _this.frame - outerFrame,\n        notification: Notification_1.Notification.createError(err)\n      });\n    }, function () {\n      messages.push({\n        frame: _this.frame - outerFrame,\n        notification: Notification_1.Notification.createComplete()\n      });\n    });\n    return messages;\n  };\n\n  TestScheduler.prototype.expectObservable = function (observable, unsubscriptionMarbles) {\n    var _this = this;\n\n    if (unsubscriptionMarbles === void 0) {\n      unsubscriptionMarbles = null;\n    }\n\n    var actual = [];\n    var flushTest = {\n      actual: actual,\n      ready: false\n    };\n    var unsubscriptionFrame = TestScheduler.parseMarblesAsSubscriptions(unsubscriptionMarbles).unsubscribedFrame;\n    var subscription;\n    this.schedule(function () {\n      subscription = observable.subscribe(function (x) {\n        var value = x; // Support Observable-of-Observables\n\n        if (x instanceof Observable_1.Observable) {\n          value = _this.materializeInnerObservable(value, _this.frame);\n        }\n\n        actual.push({\n          frame: _this.frame,\n          notification: Notification_1.Notification.createNext(value)\n        });\n      }, function (err) {\n        actual.push({\n          frame: _this.frame,\n          notification: Notification_1.Notification.createError(err)\n        });\n      }, function () {\n        actual.push({\n          frame: _this.frame,\n          notification: Notification_1.Notification.createComplete()\n        });\n      });\n    }, 0);\n\n    if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {\n      this.schedule(function () {\n        return subscription.unsubscribe();\n      }, unsubscriptionFrame);\n    }\n\n    this.flushTests.push(flushTest);\n    return {\n      toBe: function (marbles, values, errorValue) {\n        flushTest.ready = true;\n        flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true);\n      }\n    };\n  };\n\n  TestScheduler.prototype.expectSubscriptions = function (actualSubscriptionLogs) {\n    var flushTest = {\n      actual: actualSubscriptionLogs,\n      ready: false\n    };\n    this.flushTests.push(flushTest);\n    return {\n      toBe: function (marbles) {\n        var marblesArray = typeof marbles === 'string' ? [marbles] : marbles;\n        flushTest.ready = true;\n        flushTest.expected = marblesArray.map(function (marbles) {\n          return TestScheduler.parseMarblesAsSubscriptions(marbles);\n        });\n      }\n    };\n  };\n\n  TestScheduler.prototype.flush = function () {\n    var hotObservables = this.hotObservables;\n\n    while (hotObservables.length > 0) {\n      hotObservables.shift().setup();\n    }\n\n    _super.prototype.flush.call(this);\n\n    var readyFlushTests = this.flushTests.filter(function (test) {\n      return test.ready;\n    });\n\n    while (readyFlushTests.length > 0) {\n      var test = readyFlushTests.shift();\n      this.assertDeepEqual(test.actual, test.expected);\n    }\n  };\n\n  TestScheduler.parseMarblesAsSubscriptions = function (marbles) {\n    if (typeof marbles !== 'string') {\n      return new SubscriptionLog_1.SubscriptionLog(Number.POSITIVE_INFINITY);\n    }\n\n    var len = marbles.length;\n    var groupStart = -1;\n    var subscriptionFrame = Number.POSITIVE_INFINITY;\n    var unsubscriptionFrame = Number.POSITIVE_INFINITY;\n\n    for (var i = 0; i < len; i++) {\n      var frame = i * this.frameTimeFactor;\n      var c = marbles[i];\n\n      switch (c) {\n        case '-':\n        case ' ':\n          break;\n\n        case '(':\n          groupStart = frame;\n          break;\n\n        case ')':\n          groupStart = -1;\n          break;\n\n        case '^':\n          if (subscriptionFrame !== Number.POSITIVE_INFINITY) {\n            throw new Error('found a second subscription point \\'^\\' in a ' + 'subscription marble diagram. There can only be one.');\n          }\n\n          subscriptionFrame = groupStart > -1 ? groupStart : frame;\n          break;\n\n        case '!':\n          if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {\n            throw new Error('found a second subscription point \\'^\\' in a ' + 'subscription marble diagram. There can only be one.');\n          }\n\n          unsubscriptionFrame = groupStart > -1 ? groupStart : frame;\n          break;\n\n        default:\n          throw new Error('there can only be \\'^\\' and \\'!\\' markers in a ' + 'subscription marble diagram. Found instead \\'' + c + '\\'.');\n      }\n    }\n\n    if (unsubscriptionFrame < 0) {\n      return new SubscriptionLog_1.SubscriptionLog(subscriptionFrame);\n    } else {\n      return new SubscriptionLog_1.SubscriptionLog(subscriptionFrame, unsubscriptionFrame);\n    }\n  };\n\n  TestScheduler.parseMarbles = function (marbles, values, errorValue, materializeInnerObservables) {\n    if (materializeInnerObservables === void 0) {\n      materializeInnerObservables = false;\n    }\n\n    if (marbles.indexOf('!') !== -1) {\n      throw new Error('conventional marble diagrams cannot have the ' + 'unsubscription marker \"!\"');\n    }\n\n    var len = marbles.length;\n    var testMessages = [];\n    var subIndex = marbles.indexOf('^');\n    var frameOffset = subIndex === -1 ? 0 : subIndex * -this.frameTimeFactor;\n    var getValue = typeof values !== 'object' ? function (x) {\n      return x;\n    } : function (x) {\n      // Support Observable-of-Observables\n      if (materializeInnerObservables && values[x] instanceof ColdObservable_1.ColdObservable) {\n        return values[x].messages;\n      }\n\n      return values[x];\n    };\n    var groupStart = -1;\n\n    for (var i = 0; i < len; i++) {\n      var frame = i * this.frameTimeFactor + frameOffset;\n      var notification = void 0;\n      var c = marbles[i];\n\n      switch (c) {\n        case '-':\n        case ' ':\n          break;\n\n        case '(':\n          groupStart = frame;\n          break;\n\n        case ')':\n          groupStart = -1;\n          break;\n\n        case '|':\n          notification = Notification_1.Notification.createComplete();\n          break;\n\n        case '^':\n          break;\n\n        case '#':\n          notification = Notification_1.Notification.createError(errorValue || 'error');\n          break;\n\n        default:\n          notification = Notification_1.Notification.createNext(getValue(c));\n          break;\n      }\n\n      if (notification) {\n        testMessages.push({\n          frame: groupStart > -1 ? groupStart : frame,\n          notification: notification\n        });\n      }\n    }\n\n    return testMessages;\n  };\n\n  return TestScheduler;\n}(VirtualTimeScheduler_1.VirtualTimeScheduler);\n\nexports.TestScheduler = TestScheduler;","map":{"version":3,"sources":["../../src/testing/TestScheduler.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observable } from '../Observable';\nimport { Notification } from '../Notification';\nimport { ColdObservable } from './ColdObservable';\nimport { HotObservable } from './HotObservable';\nimport { TestMessage } from './TestMessage';\nimport { SubscriptionLog } from './SubscriptionLog';\nimport { Subscription } from '../Subscription';\nimport { VirtualTimeScheduler, VirtualAction } from '../scheduler/VirtualTimeScheduler';\n\nconst defaultMaxFrame: number = 750;\n\ninterface FlushableTest {\n  ready: boolean;\n  actual?: any[];\n  expected?: any[];\n}\n\nexport type observableToBeFn = (marbles: string, values?: any, errorValue?: any) => void;\nexport type subscriptionLogsToBeFn = (marbles: string | string[]) => void;\n\nexport class TestScheduler extends VirtualTimeScheduler {\n  private hotObservables: HotObservable<any>[] = [];\n  private coldObservables: ColdObservable<any>[] = [];\n  private flushTests: FlushableTest[] = [];\n\n  constructor(public assertDeepEqual: (actual: any, expected: any) => boolean | void) {\n    super(VirtualAction, defaultMaxFrame);\n  }\n\n  createTime(marbles: string): number {\n    const indexOf: number = marbles.indexOf('|');\n    if (indexOf === -1) {\n      throw new Error('marble diagram for time should have a completion marker \"|\"');\n    }\n    return indexOf * TestScheduler.frameTimeFactor;\n  }\n\n  createColdObservable<T>(marbles: string, values?: any, error?: any): ColdObservable<T> {\n    if (marbles.indexOf('^') !== -1) {\n      throw new Error('cold observable cannot have subscription offset \"^\"');\n    }\n    if (marbles.indexOf('!') !== -1) {\n      throw new Error('cold observable cannot have unsubscription marker \"!\"');\n    }\n    const messages = TestScheduler.parseMarbles(marbles, values, error);\n    const cold = new ColdObservable<T>(messages, this);\n    this.coldObservables.push(cold);\n    return cold;\n  }\n\n  createHotObservable<T>(marbles: string, values?: any, error?: any): HotObservable<T> {\n    if (marbles.indexOf('!') !== -1) {\n      throw new Error('hot observable cannot have unsubscription marker \"!\"');\n    }\n    const messages = TestScheduler.parseMarbles(marbles, values, error);\n    const subject = new HotObservable<T>(messages, this);\n    this.hotObservables.push(subject);\n    return subject;\n  }\n\n  private materializeInnerObservable(observable: Observable<any>,\n                                     outerFrame: number): TestMessage[] {\n    const messages: TestMessage[] = [];\n    observable.subscribe((value) => {\n      messages.push({ frame: this.frame - outerFrame, notification: Notification.createNext(value) });\n    }, (err) => {\n      messages.push({ frame: this.frame - outerFrame, notification: Notification.createError(err) });\n    }, () => {\n      messages.push({ frame: this.frame - outerFrame, notification: Notification.createComplete() });\n    });\n    return messages;\n  }\n\n  expectObservable(observable: Observable<any>,\n                   unsubscriptionMarbles: string = null): ({ toBe: observableToBeFn }) {\n    const actual: TestMessage[] = [];\n    const flushTest: FlushableTest = { actual, ready: false };\n    const unsubscriptionFrame = TestScheduler\n      .parseMarblesAsSubscriptions(unsubscriptionMarbles).unsubscribedFrame;\n    let subscription: Subscription;\n\n    this.schedule(() => {\n      subscription = observable.subscribe(x => {\n        let value = x;\n        // Support Observable-of-Observables\n        if (x instanceof Observable) {\n          value = this.materializeInnerObservable(value, this.frame);\n        }\n        actual.push({ frame: this.frame, notification: Notification.createNext(value) });\n      }, (err) => {\n        actual.push({ frame: this.frame, notification: Notification.createError(err) });\n      }, () => {\n        actual.push({ frame: this.frame, notification: Notification.createComplete() });\n      });\n    }, 0);\n\n    if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {\n      this.schedule(() => subscription.unsubscribe(), unsubscriptionFrame);\n    }\n\n    this.flushTests.push(flushTest);\n\n    return {\n      toBe(marbles: string, values?: any, errorValue?: any) {\n        flushTest.ready = true;\n        flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true);\n      }\n    };\n  }\n\n  expectSubscriptions(actualSubscriptionLogs: SubscriptionLog[]): ({ toBe: subscriptionLogsToBeFn }) {\n    const flushTest: FlushableTest = { actual: actualSubscriptionLogs, ready: false };\n    this.flushTests.push(flushTest);\n    return {\n      toBe(marbles: string | string[]) {\n        const marblesArray: string[] = (typeof marbles === 'string') ? [marbles] : marbles;\n        flushTest.ready = true;\n        flushTest.expected = marblesArray.map(marbles =>\n          TestScheduler.parseMarblesAsSubscriptions(marbles)\n        );\n      }\n    };\n  }\n\n  flush() {\n    const hotObservables = this.hotObservables;\n    while (hotObservables.length > 0) {\n      hotObservables.shift().setup();\n    }\n\n    super.flush();\n    const readyFlushTests = this.flushTests.filter(test => test.ready);\n    while (readyFlushTests.length > 0) {\n      const test = readyFlushTests.shift();\n      this.assertDeepEqual(test.actual, test.expected);\n    }\n  }\n\n  static parseMarblesAsSubscriptions(marbles: string): SubscriptionLog {\n    if (typeof marbles !== 'string') {\n      return new SubscriptionLog(Number.POSITIVE_INFINITY);\n    }\n    const len = marbles.length;\n    let groupStart = -1;\n    let subscriptionFrame = Number.POSITIVE_INFINITY;\n    let unsubscriptionFrame = Number.POSITIVE_INFINITY;\n\n    for (let i = 0; i < len; i++) {\n      const frame = i * this.frameTimeFactor;\n      const c = marbles[i];\n      switch (c) {\n        case '-':\n        case ' ':\n          break;\n        case '(':\n          groupStart = frame;\n          break;\n        case ')':\n          groupStart = -1;\n          break;\n        case '^':\n          if (subscriptionFrame !== Number.POSITIVE_INFINITY) {\n            throw new Error('found a second subscription point \\'^\\' in a ' +\n              'subscription marble diagram. There can only be one.');\n          }\n          subscriptionFrame = groupStart > -1 ? groupStart : frame;\n          break;\n        case '!':\n          if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {\n            throw new Error('found a second subscription point \\'^\\' in a ' +\n              'subscription marble diagram. There can only be one.');\n          }\n          unsubscriptionFrame = groupStart > -1 ? groupStart : frame;\n          break;\n        default:\n          throw new Error('there can only be \\'^\\' and \\'!\\' markers in a ' +\n            'subscription marble diagram. Found instead \\'' + c + '\\'.');\n      }\n    }\n\n    if (unsubscriptionFrame < 0) {\n      return new SubscriptionLog(subscriptionFrame);\n    } else {\n      return new SubscriptionLog(subscriptionFrame, unsubscriptionFrame);\n    }\n  }\n\n  static parseMarbles(marbles: string,\n                      values?: any,\n                      errorValue?: any,\n                      materializeInnerObservables: boolean = false): TestMessage[] {\n    if (marbles.indexOf('!') !== -1) {\n      throw new Error('conventional marble diagrams cannot have the ' +\n        'unsubscription marker \"!\"');\n    }\n    const len = marbles.length;\n    const testMessages: TestMessage[] = [];\n    const subIndex = marbles.indexOf('^');\n    const frameOffset = subIndex === -1 ? 0 : (subIndex * -this.frameTimeFactor);\n    const getValue = typeof values !== 'object' ?\n      (x: any) => x :\n      (x: any) => {\n        // Support Observable-of-Observables\n        if (materializeInnerObservables && values[x] instanceof ColdObservable) {\n          return values[x].messages;\n        }\n        return values[x];\n      };\n    let groupStart = -1;\n\n    for (let i = 0; i < len; i++) {\n      const frame = i * this.frameTimeFactor + frameOffset;\n      let notification: Notification<any>;\n      const c = marbles[i];\n      switch (c) {\n        case '-':\n        case ' ':\n          break;\n        case '(':\n          groupStart = frame;\n          break;\n        case ')':\n          groupStart = -1;\n          break;\n        case '|':\n          notification = Notification.createComplete();\n          break;\n        case '^':\n          break;\n        case '#':\n          notification = Notification.createError(errorValue || 'error');\n          break;\n        default:\n          notification = Notification.createNext(getValue(c));\n          break;\n      }\n\n      if (notification) {\n        testMessages.push({ frame: groupStart > -1 ? groupStart : frame, notification });\n      }\n    }\n    return testMessages;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}