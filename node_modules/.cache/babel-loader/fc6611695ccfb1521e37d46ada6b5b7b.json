{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = require('../Subscriber');\n\nvar ArgumentOutOfRangeError_1 = require('../util/ArgumentOutOfRangeError');\n/**\n * Skip the last `count` values emitted by the source Observable.\n *\n * <img src=\"./img/skipLast.png\" width=\"100%\">\n *\n * `skipLast` returns an Observable that accumulates a queue with a length\n * enough to store the first `count` values. As more values are received,\n * values are taken from the front of the queue and produced on the result\n * sequence. This causes values to be delayed.\n *\n * @example <caption>Skip the last 2 values of an Observable with many values</caption>\n * var many = Rx.Observable.range(1, 5);\n * var skipLastTwo = many.skipLast(2);\n * skipLastTwo.subscribe(x => console.log(x));\n *\n * // Results in:\n * // 1 2 3\n *\n * @see {@link skip}\n * @see {@link skipUntil}\n * @see {@link skipWhile}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `skipLast(i)`, it throws\n * ArgumentOutOrRangeError if `i < 0`.\n *\n * @param {number} count Number of elements to skip from the end of the source Observable.\n * @returns {Observable<T>} An Observable that skips the last count values\n * emitted by the source Observable.\n * @method skipLast\n * @owner Observable\n */\n\n\nfunction skipLast(count) {\n  return function (source) {\n    return source.lift(new SkipLastOperator(count));\n  };\n}\n\nexports.skipLast = skipLast;\n\nvar SkipLastOperator = function () {\n  function SkipLastOperator(_skipCount) {\n    this._skipCount = _skipCount;\n\n    if (this._skipCount < 0) {\n      throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();\n    }\n  }\n\n  SkipLastOperator.prototype.call = function (subscriber, source) {\n    if (this._skipCount === 0) {\n      // If we don't want to skip any values then just subscribe\n      // to Subscriber without any further logic.\n      return source.subscribe(new Subscriber_1.Subscriber(subscriber));\n    } else {\n      return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));\n    }\n  };\n\n  return SkipLastOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar SkipLastSubscriber = function (_super) {\n  __extends(SkipLastSubscriber, _super);\n\n  function SkipLastSubscriber(destination, _skipCount) {\n    _super.call(this, destination);\n\n    this._skipCount = _skipCount;\n    this._count = 0;\n    this._ring = new Array(_skipCount);\n  }\n\n  SkipLastSubscriber.prototype._next = function (value) {\n    var skipCount = this._skipCount;\n    var count = this._count++;\n\n    if (count < skipCount) {\n      this._ring[count] = value;\n    } else {\n      var currentIndex = count % skipCount;\n      var ring = this._ring;\n      var oldValue = ring[currentIndex];\n      ring[currentIndex] = value;\n      this.destination.next(oldValue);\n    }\n  };\n\n  return SkipLastSubscriber;\n}(Subscriber_1.Subscriber);","map":{"version":3,"sources":["../../src/operators/skipLast.ts"],"names":[],"mappings":";;;;;;;;;;;;AACA,IAAA,YAAA,GAAA,OAAA,CAA2B,eAA3B,CAAA;;AACA,IAAA,yBAAA,GAAA,OAAA,CAAwC,iCAAxC,CAAA;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCA,SAAA,QAAA,CAA4B,KAA5B,EAAyC;AACvC,SAAO,UAAC,MAAD,EAAsB;AAAK,WAAA,MAAM,CAAC,IAAP,CAAY,IAAI,gBAAJ,CAAZ,KAAY,CAAZ,CAAA;AAAwC,GAA1E;AACD;;AAFe,OAAA,CAAA,QAAA,GAAQ,QAAR;;AAIhB,IAAA,gBAAA,GAAA,YAAA;AACE,WAAA,gBAAA,CAAoB,UAApB,EAAsC;AAAlB,SAAA,UAAA,GAAA,UAAA;;AAClB,QAAI,KAAK,UAAL,GAAkB,CAAtB,EAAyB;AACvB,YAAM,IAAI,yBAAA,CAAA,uBAAJ,EAAN;AACD;AACF;;AAED,EAAA,gBAAA,CAAA,SAAA,CAAA,IAAA,GAAA,UAAK,UAAL,EAAgC,MAAhC,EAA2C;AACzC,QAAI,KAAK,UAAL,KAAoB,CAAxB,EAA2B;AACzB;AACA;AACA,aAAO,MAAM,CAAC,SAAP,CAAiB,IAAI,YAAA,CAAA,UAAJ,CAAe,UAAf,CAAjB,CAAP;AACD,KAJD,MAIO;AACL,aAAO,MAAM,CAAC,SAAP,CAAiB,IAAI,kBAAJ,CAAuB,UAAvB,EAAmC,KAAK,UAAxC,CAAjB,CAAP;AACD;AACF,GARD;;AASF,SAAA,gBAAA;AAAC,CAhBD,EAAA;AAkBA;;;;;;;AAKA,IAAA,kBAAA,GAAA,UAAA,MAAA,EAAA;AAAoC,EAAA,SAAA,CAAA,kBAAA,EAAA,MAAA,CAAA;;AAIlC,WAAA,kBAAA,CAAY,WAAZ,EAAgD,UAAhD,EAAkE;AAChE,IAAA,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,WAAN;;AAD8C,SAAA,UAAA,GAAA,UAAA;AAFxC,SAAA,MAAA,GAAiB,CAAjB;AAIN,SAAK,KAAL,GAAa,IAAI,KAAJ,CAAa,UAAb,CAAb;AACD;;AAES,EAAA,kBAAA,CAAA,SAAA,CAAA,KAAA,GAAV,UAAgB,KAAhB,EAAwB;AACtB,QAAM,SAAS,GAAG,KAAK,UAAvB;AACA,QAAM,KAAK,GAAG,KAAK,MAAL,EAAd;;AAEA,QAAI,KAAK,GAAG,SAAZ,EAAuB;AACrB,WAAK,KAAL,CAAW,KAAX,IAAoB,KAApB;AACD,KAFD,MAEO;AACL,UAAM,YAAY,GAAG,KAAK,GAAG,SAA7B;AACA,UAAM,IAAI,GAAG,KAAK,KAAlB;AACA,UAAM,QAAQ,GAAG,IAAI,CAAC,YAAD,CAArB;AAEA,MAAA,IAAI,CAAC,YAAD,CAAJ,GAAqB,KAArB;AACA,WAAK,WAAL,CAAiB,IAAjB,CAAsB,QAAtB;AACD;AACF,GAdS;;AAeZ,SAAA,kBAAA;AAAC,CAxBD,CAAoC,YAAA,CAAA,UAApC,CAAA","sourcesContent":["import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nimport { Observable } from '../Observable';\nimport { TeardownLogic } from '../Subscription';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Skip the last `count` values emitted by the source Observable.\n *\n * <img src=\"./img/skipLast.png\" width=\"100%\">\n *\n * `skipLast` returns an Observable that accumulates a queue with a length\n * enough to store the first `count` values. As more values are received,\n * values are taken from the front of the queue and produced on the result\n * sequence. This causes values to be delayed.\n *\n * @example <caption>Skip the last 2 values of an Observable with many values</caption>\n * var many = Rx.Observable.range(1, 5);\n * var skipLastTwo = many.skipLast(2);\n * skipLastTwo.subscribe(x => console.log(x));\n *\n * // Results in:\n * // 1 2 3\n *\n * @see {@link skip}\n * @see {@link skipUntil}\n * @see {@link skipWhile}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `skipLast(i)`, it throws\n * ArgumentOutOrRangeError if `i < 0`.\n *\n * @param {number} count Number of elements to skip from the end of the source Observable.\n * @returns {Observable<T>} An Observable that skips the last count values\n * emitted by the source Observable.\n * @method skipLast\n * @owner Observable\n */\nexport function skipLast<T>(count: number): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new SkipLastOperator(count));\n}\n\nclass SkipLastOperator<T> implements Operator<T, T> {\n  constructor(private _skipCount: number) {\n    if (this._skipCount < 0) {\n      throw new ArgumentOutOfRangeError;\n    }\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    if (this._skipCount === 0) {\n      // If we don't want to skip any values then just subscribe\n      // to Subscriber without any further logic.\n      return source.subscribe(new Subscriber(subscriber));\n    } else {\n      return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));\n    }\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SkipLastSubscriber<T> extends Subscriber<T> {\n  private _ring: T[];\n  private _count: number = 0;\n\n  constructor(destination: Subscriber<T>, private _skipCount: number) {\n    super(destination);\n    this._ring = new Array<T>(_skipCount);\n  }\n\n  protected _next(value: T): void {\n    const skipCount = this._skipCount;\n    const count = this._count++;\n\n    if (count < skipCount) {\n      this._ring[count] = value;\n    } else {\n      const currentIndex = count % skipCount;\n      const ring = this._ring;\n      const oldValue = ring[currentIndex];\n\n      ring[currentIndex] = value;\n      this.destination.next(oldValue);\n    }\n  }\n}"],"sourceRoot":""},"metadata":{},"sourceType":"script"}