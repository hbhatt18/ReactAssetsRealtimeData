{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Observable_1 = require('../Observable');\n\nvar isScheduler_1 = require('../util/isScheduler');\n\nvar selfSelector = function (value) {\n  return value;\n};\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar GenerateObservable = function (_super) {\n  __extends(GenerateObservable, _super);\n\n  function GenerateObservable(initialState, condition, iterate, resultSelector, scheduler) {\n    _super.call(this);\n\n    this.initialState = initialState;\n    this.condition = condition;\n    this.iterate = iterate;\n    this.resultSelector = resultSelector;\n    this.scheduler = scheduler;\n  }\n\n  GenerateObservable.create = function (initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {\n    if (arguments.length == 1) {\n      return new GenerateObservable(initialStateOrOptions.initialState, initialStateOrOptions.condition, initialStateOrOptions.iterate, initialStateOrOptions.resultSelector || selfSelector, initialStateOrOptions.scheduler);\n    }\n\n    if (resultSelectorOrObservable === undefined || isScheduler_1.isScheduler(resultSelectorOrObservable)) {\n      return new GenerateObservable(initialStateOrOptions, condition, iterate, selfSelector, resultSelectorOrObservable);\n    }\n\n    return new GenerateObservable(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler);\n  };\n  /** @deprecated internal use only */\n\n\n  GenerateObservable.prototype._subscribe = function (subscriber) {\n    var state = this.initialState;\n\n    if (this.scheduler) {\n      return this.scheduler.schedule(GenerateObservable.dispatch, 0, {\n        subscriber: subscriber,\n        iterate: this.iterate,\n        condition: this.condition,\n        resultSelector: this.resultSelector,\n        state: state\n      });\n    }\n\n    var _a = this,\n        condition = _a.condition,\n        resultSelector = _a.resultSelector,\n        iterate = _a.iterate;\n\n    do {\n      if (condition) {\n        var conditionResult = void 0;\n\n        try {\n          conditionResult = condition(state);\n        } catch (err) {\n          subscriber.error(err);\n          return;\n        }\n\n        if (!conditionResult) {\n          subscriber.complete();\n          break;\n        }\n      }\n\n      var value = void 0;\n\n      try {\n        value = resultSelector(state);\n      } catch (err) {\n        subscriber.error(err);\n        return;\n      }\n\n      subscriber.next(value);\n\n      if (subscriber.closed) {\n        break;\n      }\n\n      try {\n        state = iterate(state);\n      } catch (err) {\n        subscriber.error(err);\n        return;\n      }\n    } while (true);\n  };\n\n  GenerateObservable.dispatch = function (state) {\n    var subscriber = state.subscriber,\n        condition = state.condition;\n\n    if (subscriber.closed) {\n      return;\n    }\n\n    if (state.needIterate) {\n      try {\n        state.state = state.iterate(state.state);\n      } catch (err) {\n        subscriber.error(err);\n        return;\n      }\n    } else {\n      state.needIterate = true;\n    }\n\n    if (condition) {\n      var conditionResult = void 0;\n\n      try {\n        conditionResult = condition(state.state);\n      } catch (err) {\n        subscriber.error(err);\n        return;\n      }\n\n      if (!conditionResult) {\n        subscriber.complete();\n        return;\n      }\n\n      if (subscriber.closed) {\n        return;\n      }\n    }\n\n    var value;\n\n    try {\n      value = state.resultSelector(state.state);\n    } catch (err) {\n      subscriber.error(err);\n      return;\n    }\n\n    if (subscriber.closed) {\n      return;\n    }\n\n    subscriber.next(value);\n\n    if (subscriber.closed) {\n      return;\n    }\n\n    return this.schedule(state);\n  };\n\n  return GenerateObservable;\n}(Observable_1.Observable);\n\nexports.GenerateObservable = GenerateObservable;","map":{"version":3,"sources":["../../src/observable/GenerateObservable.ts"],"names":[],"mappings":";;;;;;;;;;;;AAEA,IAAA,YAAA,GAAA,OAAA,CAA2B,eAA3B,CAAA;;AAGA,IAAA,aAAA,GAAA,OAAA,CAA4B,qBAA5B,CAAA;;AAEA,IAAM,YAAY,GAAG,UAAI,KAAJ,EAAY;AAAK,SAAA,KAAA;AAAK,CAA3C;AA4CA;;;;;;;AAKA,IAAA,kBAAA,GAAA,UAAA,MAAA,EAAA;AAA8C,EAAA,SAAA,CAAA,kBAAA,EAAA,MAAA,CAAA;;AAC5C,WAAA,kBAAA,CAAoB,YAApB,EACoB,SADpB,EAEoB,OAFpB,EAGoB,cAHpB,EAIoB,SAJpB,EAI0C;AACtC,IAAA,MAAA,CAAA,IAAA,CAAA,IAAA;;AALgB,SAAA,YAAA,GAAA,YAAA;AACA,SAAA,SAAA,GAAA,SAAA;AACA,SAAA,OAAA,GAAA,OAAA;AACA,SAAA,cAAA,GAAA,cAAA;AACA,SAAA,SAAA,GAAA,SAAA;AAEnB;;AA4GM,EAAA,kBAAA,CAAA,MAAA,GAAP,UAAoB,qBAApB,EACoB,SADpB,EAEoB,OAFpB,EAGoB,0BAHpB,EAIoB,SAJpB,EAI0C;AACxC,QAAI,SAAS,CAAC,MAAV,IAAoB,CAAxB,EAA2B;AACzB,aAAO,IAAI,kBAAJ,CACmB,qBAAsB,CAAC,YAD1C,EAEmB,qBAAsB,CAAC,SAF1C,EAGmB,qBAAsB,CAAC,OAH1C,EAImB,qBAAsB,CAAC,cAAvB,IAAyC,YAJ5D,EAKmB,qBAAsB,CAAC,SAL1C,CAAP;AAMD;;AAED,QAAI,0BAA0B,KAAK,SAA/B,IAA4C,aAAA,CAAA,WAAA,CAAY,0BAAZ,CAAhD,EAAyF;AACvF,aAAO,IAAI,kBAAJ,CACF,qBADE,EAEL,SAFK,EAGL,OAHK,EAIL,YAJK,EAKO,0BALP,CAAP;AAMD;;AAED,WAAO,IAAI,kBAAJ,CACF,qBADE,EAEL,SAFK,EAGL,OAHK,EAIa,0BAJb,EAKO,SALP,CAAP;AAMD,GA7BM;AA+BP;;;AAAqC,EAAA,kBAAA,CAAA,SAAA,CAAA,UAAA,GAAA,UAAW,UAAX,EAAsC;AACzE,QAAI,KAAK,GAAG,KAAK,YAAjB;;AACA,QAAI,KAAK,SAAT,EAAoB;AAClB,aAAO,KAAK,SAAL,CAAe,QAAf,CAA8C,kBAAkB,CAAC,QAAjE,EAA2E,CAA3E,EAA8E;AACnF,QAAA,UAAA,EAAA,UADmF;AAEnF,QAAA,OAAO,EAAE,KAAK,OAFqE;AAGnF,QAAA,SAAS,EAAE,KAAK,SAHmE;AAInF,QAAA,cAAc,EAAE,KAAK,cAJ8D;AAKnF,QAAA,KAAA,EAAA;AALmF,OAA9E,CAAP;AAMD;;AACD,QAAA,EAAA,GAAA,IAAA;AAAA,QAAQ,SAAA,GAAA,EAAA,CAAA,SAAR;AAAA,QAAmB,cAAA,GAAA,EAAA,CAAA,cAAnB;AAAA,QAAmC,OAAA,GAAA,EAAA,CAAA,OAAnC;;AACA,OAAG;AACD,UAAI,SAAJ,EAAe;AACb,YAAI,eAAe,GAAA,KAAA,CAAnB;;AACA,YAAI;AACF,UAAA,eAAe,GAAG,SAAS,CAAC,KAAD,CAA3B;AACA,SAFF,CAEE,OAAO,GAAP,EAAY;AACZ,UAAA,UAAU,CAAC,KAAX,CAAiB,GAAjB;AACA;AACD;;AACD,YAAI,CAAC,eAAL,EAAsB;AACpB,UAAA,UAAU,CAAC,QAAX;AACA;AACD;AACF;;AACD,UAAI,KAAK,GAAA,KAAA,CAAT;;AACA,UAAI;AACF,QAAA,KAAK,GAAG,cAAc,CAAC,KAAD,CAAtB;AACA,OAFF,CAEE,OAAO,GAAP,EAAY;AACZ,QAAA,UAAU,CAAC,KAAX,CAAiB,GAAjB;AACA;AACD;;AACD,MAAA,UAAU,CAAC,IAAX,CAAgB,KAAhB;;AACA,UAAI,UAAU,CAAC,MAAf,EAAuB;AACrB;AACD;;AACD,UAAI;AACF,QAAA,KAAK,GAAG,OAAO,CAAC,KAAD,CAAf;AACA,OAFF,CAEE,OAAO,GAAP,EAAY;AACZ,QAAA,UAAU,CAAC,KAAX,CAAiB,GAAjB;AACA;AACD;AACF,KA/BD,QA+BS,IA/BT;AAgCD,GA3CoC;;AA6CtB,EAAA,kBAAA,CAAA,QAAA,GAAf,UAA8B,KAA9B,EAAyD;AAC/C,QAAA,UAAA,GAAA,KAAA,CAAA,UAAA;AAAA,QAAY,SAAA,GAAA,KAAA,CAAA,SAAZ;;AACR,QAAI,UAAU,CAAC,MAAf,EAAuB;AACrB;AACD;;AACD,QAAI,KAAK,CAAC,WAAV,EAAuB;AACrB,UAAI;AACF,QAAA,KAAK,CAAC,KAAN,GAAc,KAAK,CAAC,OAAN,CAAc,KAAK,CAAC,KAApB,CAAd;AACA,OAFF,CAEE,OAAO,GAAP,EAAY;AACZ,QAAA,UAAU,CAAC,KAAX,CAAiB,GAAjB;AACA;AACD;AACF,KAPD,MAOO;AACL,MAAA,KAAK,CAAC,WAAN,GAAoB,IAApB;AACD;;AACD,QAAI,SAAJ,EAAe;AACb,UAAI,eAAe,GAAA,KAAA,CAAnB;;AACA,UAAI;AACF,QAAA,eAAe,GAAG,SAAS,CAAC,KAAK,CAAC,KAAP,CAA3B;AACA,OAFF,CAEE,OAAO,GAAP,EAAY;AACZ,QAAA,UAAU,CAAC,KAAX,CAAiB,GAAjB;AACA;AACD;;AACD,UAAI,CAAC,eAAL,EAAsB;AACpB,QAAA,UAAU,CAAC,QAAX;AACA;AACD;;AACD,UAAI,UAAU,CAAC,MAAf,EAAuB;AACrB;AACD;AACF;;AACD,QAAI,KAAJ;;AACA,QAAI;AACF,MAAA,KAAK,GAAG,KAAK,CAAC,cAAN,CAAqB,KAAK,CAAC,KAA3B,CAAR;AACA,KAFF,CAEE,OAAO,GAAP,EAAY;AACZ,MAAA,UAAU,CAAC,KAAX,CAAiB,GAAjB;AACA;AACD;;AACD,QAAI,UAAU,CAAC,MAAf,EAAuB;AACrB;AACD;;AACD,IAAA,UAAU,CAAC,IAAX,CAAgB,KAAhB;;AACA,QAAI,UAAU,CAAC,MAAf,EAAuB;AACrB;AACD;;AACD,WAA2C,KAAM,QAAN,CAAe,KAAf,CAA3C;AACD,GA9Cc;;AA+CjB,SAAA,kBAAA;AAAC,CA9OD,CAA8C,YAAA,CAAA,UAA9C,CAAA;;AAAa,OAAA,CAAA,kBAAA,GAAkB,kBAAlB","sourcesContent":["import { IScheduler } from '../Scheduler';\nimport { Action } from '../scheduler/Action';\nimport { Observable } from '../Observable' ;\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { isScheduler } from '../util/isScheduler';\n\nconst selfSelector = <T>(value: T) => value;\n\nexport type ConditionFunc<S> = (state: S) => boolean;\nexport type IterateFunc<S> = (state: S) => S;\nexport type ResultFunc<S, T> = (state: S) => T;\n\ninterface SchedulerState<T, S> {\n  needIterate?: boolean;\n  state: S;\n  subscriber: Subscriber<T>;\n  condition?: ConditionFunc<S>;\n  iterate: IterateFunc<S>;\n  resultSelector: ResultFunc<S, T>;\n}\n\nexport interface GenerateBaseOptions<S> {\n  /**\n   * Initial state.\n  */\n  initialState: S;\n  /**\n   * Condition function that accepts state and returns boolean.\n   * When it returns false, the generator stops.\n   * If not specified, a generator never stops.\n  */\n  condition?: ConditionFunc<S>;\n  /**\n   * Iterate function that accepts state and returns new state.\n   */\n  iterate: IterateFunc<S>;\n  /**\n   * IScheduler to use for generation process.\n   * By default, a generator starts immediately.\n  */\n  scheduler?: IScheduler;\n}\n\nexport interface GenerateOptions<T, S> extends GenerateBaseOptions<S> {\n  /**\n   * Result selection function that accepts state and returns a value to emit.\n   */\n  resultSelector: ResultFunc<S, T>;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class GenerateObservable<T, S> extends Observable<T> {\n  constructor(private initialState: S,\n              private condition: ConditionFunc<S>,\n              private iterate: IterateFunc<S>,\n              private resultSelector: ResultFunc<S, T>,\n              private scheduler?: IScheduler) {\n      super();\n  }\n\n  /**\n   * Generates an observable sequence by running a state-driven loop\n   * producing the sequence's elements, using the specified scheduler\n   * to send out observer messages.\n   *\n   * <img src=\"./img/generate.png\" width=\"100%\">\n   *\n   * @example <caption>Produces sequence of 0, 1, 2, ... 9, then completes.</caption>\n   * var res = Rx.Observable.generate(0, x => x < 10, x => x + 1, x => x);\n   *\n   * @example <caption>Using asap scheduler, produces sequence of 2, 3, 5, then completes.</caption>\n   * var res = Rx.Observable.generate(1, x => x < 5, x => x * 2, x => x + 1, Rx.Scheduler.asap);\n   *\n   * @see {@link from}\n   * @see {@link create}\n   *\n   * @param {S} initialState Initial state.\n   * @param {function (state: S): boolean} condition Condition to terminate generation (upon returning false).\n   * @param {function (state: S): S} iterate Iteration step function.\n   * @param {function (state: S): T} resultSelector Selector function for results produced in the sequence.\n   * @param {Scheduler} [scheduler] A {@link IScheduler} on which to run the generator loop. If not provided, defaults to emit immediately.\n   * @returns {Observable<T>} The generated sequence.\n   */\n  static create<T, S>(initialState: S,\n                      condition: ConditionFunc<S>,\n                      iterate: IterateFunc<S>,\n                      resultSelector: ResultFunc<S, T>,\n                      scheduler?: IScheduler): Observable<T>\n\n  /**\n   * Generates an observable sequence by running a state-driven loop\n   * producing the sequence's elements, using the specified scheduler\n   * to send out observer messages.\n   * The overload uses state as an emitted value.\n   *\n   * <img src=\"./img/generate.png\" width=\"100%\">\n   *\n   * @example <caption>Produces sequence of 0, 1, 2, ... 9, then completes.</caption>\n   * var res = Rx.Observable.generate(0, x => x < 10, x => x + 1);\n   *\n   * @example <caption>Using asap scheduler, produces sequence of 1, 2, 4, then completes.</caption>\n   * var res = Rx.Observable.generate(1, x => x < 5, x => x * 2, Rx.Scheduler.asap);\n   *\n   * @see {@link from}\n   * @see {@link create}\n   *\n   * @param {S} initialState Initial state.\n   * @param {function (state: S): boolean} condition Condition to terminate generation (upon returning false).\n   * @param {function (state: S): S} iterate Iteration step function.\n   * @param {Scheduler} [scheduler] A {@link IScheduler} on which to run the generator loop. If not provided, defaults to emit immediately.\n   * @returns {Observable<S>} The generated sequence.\n   */\n  static create<S>(initialState: S,\n                   condition: ConditionFunc<S>,\n                   iterate: IterateFunc<S>,\n                   scheduler?: IScheduler): Observable<S>\n\n  /**\n   * Generates an observable sequence by running a state-driven loop\n   * producing the sequence's elements, using the specified scheduler\n   * to send out observer messages.\n   * The overload accepts options object that might contain initial state, iterate,\n   * condition and scheduler.\n   *\n   * <img src=\"./img/generate.png\" width=\"100%\">\n   *\n   * @example <caption>Produces sequence of 0, 1, 2, ... 9, then completes.</caption>\n   * var res = Rx.Observable.generate({\n   *   initialState: 0,\n   *   condition: x => x < 10,\n   *   iterate: x => x + 1\n   * });\n   *\n   * @see {@link from}\n   * @see {@link create}\n   *\n   * @param {GenerateBaseOptions<S>} options Object that must contain initialState, iterate and might contain condition and scheduler.\n   * @returns {Observable<S>} The generated sequence.\n   */\n  static create<S>(options: GenerateBaseOptions<S>): Observable<S>\n\n  /**\n   * Generates an observable sequence by running a state-driven loop\n   * producing the sequence's elements, using the specified scheduler\n   * to send out observer messages.\n   * The overload accepts options object that might contain initial state, iterate,\n   * condition, result selector and scheduler.\n   *\n   * <img src=\"./img/generate.png\" width=\"100%\">\n   *\n   * @example <caption>Produces sequence of 0, 1, 2, ... 9, then completes.</caption>\n   * var res = Rx.Observable.generate({\n   *   initialState: 0,\n   *   condition: x => x < 10,\n   *   iterate: x => x + 1,\n   *   resultSelector: x => x\n   * });\n   *\n   * @see {@link from}\n   * @see {@link create}\n   *\n   * @param {GenerateOptions<T, S>} options Object that must contain initialState, iterate, resultSelector and might contain condition and scheduler.\n   * @returns {Observable<T>} The generated sequence.\n   */\n  static create<T, S>(options: GenerateOptions<T, S>): Observable<T>\n\n  static create<T, S>(initialStateOrOptions: S | GenerateOptions<T, S>,\n                      condition?: ConditionFunc<S>,\n                      iterate?: IterateFunc<S>,\n                      resultSelectorOrObservable?: (ResultFunc<S, T>) | IScheduler,\n                      scheduler?: IScheduler): Observable<T> {\n    if (arguments.length == 1) {\n      return new GenerateObservable<T, S>(\n        (<GenerateOptions<T, S>>initialStateOrOptions).initialState,\n        (<GenerateOptions<T, S>>initialStateOrOptions).condition,\n        (<GenerateOptions<T, S>>initialStateOrOptions).iterate,\n        (<GenerateOptions<T, S>>initialStateOrOptions).resultSelector || selfSelector as ResultFunc<S, T>,\n        (<GenerateOptions<T, S>>initialStateOrOptions).scheduler);\n    }\n\n    if (resultSelectorOrObservable === undefined || isScheduler(resultSelectorOrObservable)) {\n      return new GenerateObservable<T, S>(\n        <S>initialStateOrOptions,\n        condition,\n        iterate,\n        selfSelector as ResultFunc<S, T>,\n        <IScheduler>resultSelectorOrObservable);\n    }\n\n    return new GenerateObservable<T, S>(\n      <S>initialStateOrOptions,\n      condition,\n      iterate,\n      <ResultFunc<S, T>>resultSelectorOrObservable,\n      <IScheduler>scheduler);\n  }\n\n  /** @deprecated internal use only */ _subscribe(subscriber: Subscriber<any>): Subscription | Function | void {\n    let state = this.initialState;\n    if (this.scheduler) {\n      return this.scheduler.schedule<SchedulerState<T, S>>(GenerateObservable.dispatch, 0, {\n        subscriber,\n        iterate: this.iterate,\n        condition: this.condition,\n        resultSelector: this.resultSelector,\n        state });\n    }\n    const { condition, resultSelector, iterate } = this;\n    do {\n      if (condition) {\n        let conditionResult: boolean;\n        try {\n          conditionResult = condition(state);\n        } catch (err) {\n          subscriber.error(err);\n          return;\n        }\n        if (!conditionResult) {\n          subscriber.complete();\n          break;\n        }\n      }\n      let value: T;\n      try {\n        value = resultSelector(state);\n      } catch (err) {\n        subscriber.error(err);\n        return;\n      }\n      subscriber.next(value);\n      if (subscriber.closed) {\n        break;\n      }\n      try {\n        state = iterate(state);\n      } catch (err) {\n        subscriber.error(err);\n        return;\n      }\n    } while (true);\n  }\n\n  private static dispatch<T, S>(state: SchedulerState<T, S>): Subscription | void {\n    const { subscriber, condition } = state;\n    if (subscriber.closed) {\n      return;\n    }\n    if (state.needIterate) {\n      try {\n        state.state = state.iterate(state.state);\n      } catch (err) {\n        subscriber.error(err);\n        return;\n      }\n    } else {\n      state.needIterate = true;\n    }\n    if (condition) {\n      let conditionResult: boolean;\n      try {\n        conditionResult = condition(state.state);\n      } catch (err) {\n        subscriber.error(err);\n        return;\n      }\n      if (!conditionResult) {\n        subscriber.complete();\n        return;\n      }\n      if (subscriber.closed) {\n        return;\n      }\n    }\n    let value: T;\n    try {\n      value = state.resultSelector(state.state);\n    } catch (err) {\n      subscriber.error(err);\n      return;\n    }\n    if (subscriber.closed) {\n      return;\n    }\n    subscriber.next(value);\n    if (subscriber.closed) {\n      return;\n    }\n    return (<Action<SchedulerState<T, S>>><any>this).schedule(state);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}