{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Immediate_1 = require('../util/Immediate');\n\nvar AsyncAction_1 = require('./AsyncAction');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar AsapAction = function (_super) {\n  __extends(AsapAction, _super);\n\n  function AsapAction(scheduler, work) {\n    _super.call(this, scheduler, work);\n\n    this.scheduler = scheduler;\n    this.work = work;\n  }\n\n  AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    } // If delay is greater than 0, request as an async action.\n\n\n    if (delay !== null && delay > 0) {\n      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n    } // Push the action to the end of the scheduler queue.\n\n\n    scheduler.actions.push(this); // If a microtask has already been scheduled, don't schedule another\n    // one. If a microtask hasn't been scheduled yet, schedule one now. Return\n    // the current scheduled microtask id.\n\n    return scheduler.scheduled || (scheduler.scheduled = Immediate_1.Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));\n  };\n\n  AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    } // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n\n\n    if (delay !== null && delay > 0 || delay === null && this.delay > 0) {\n      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);\n    } // If the scheduler queue is empty, cancel the requested microtask and\n    // set the scheduled flag to undefined so the next AsapAction will schedule\n    // its own.\n\n\n    if (scheduler.actions.length === 0) {\n      Immediate_1.Immediate.clearImmediate(id);\n      scheduler.scheduled = undefined;\n    } // Return undefined so the action knows to request a new async id if it's rescheduled.\n\n\n    return undefined;\n  };\n\n  return AsapAction;\n}(AsyncAction_1.AsyncAction);\n\nexports.AsapAction = AsapAction;","map":{"version":3,"sources":["../../src/scheduler/AsapAction.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,IAAA,WAAA,GAAA,OAAA,CAA0B,mBAA1B,CAAA;;AACA,IAAA,aAAA,GAAA,OAAA,CAA4B,eAA5B,CAAA;AAGA;;;;;;;AAKA,IAAA,UAAA,GAAA,UAAA,MAAA,EAAA;AAAmC,EAAA,SAAA,CAAA,UAAA,EAAA,MAAA,CAAA;;AAEjC,WAAA,UAAA,CAAsB,SAAtB,EACsB,IADtB,EACoE;AAClE,IAAA,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,SAAN,EAAiB,IAAjB;;AAFoB,SAAA,SAAA,GAAA,SAAA;AACA,SAAA,IAAA,GAAA,IAAA;AAErB;;AAES,EAAA,UAAA,CAAA,SAAA,CAAA,cAAA,GAAV,UAAyB,SAAzB,EAAmD,EAAnD,EAA6D,KAA7D,EAA8E;AAAjB,QAAA,KAAA,KAAA,KAAA,CAAA,EAAiB;AAAjB,MAAA,KAAA,GAAA,CAAA;AAAiB,KAAA,CAC5E;;;AACA,QAAI,KAAK,KAAK,IAAV,IAAkB,KAAK,GAAG,CAA9B,EAAiC;AAC/B,aAAO,MAAA,CAAA,SAAA,CAAM,cAAN,CAAoB,IAApB,CAAoB,IAApB,EAAqB,SAArB,EAAgC,EAAhC,EAAoC,KAApC,CAAP;AACD,KAJ2E,CAK5E;;;AACA,IAAA,SAAS,CAAC,OAAV,CAAkB,IAAlB,CAAuB,IAAvB,EAN4E,CAO5E;AACA;AACA;;AACA,WAAO,SAAS,CAAC,SAAV,KAAwB,SAAS,CAAC,SAAV,GAAsB,WAAA,CAAA,SAAA,CAAU,YAAV,CACnD,SAAS,CAAC,KAAV,CAAgB,IAAhB,CAAqB,SAArB,EAAgC,IAAhC,CADmD,CAA9C,CAAP;AAGD,GAbS;;AAcA,EAAA,UAAA,CAAA,SAAA,CAAA,cAAA,GAAV,UAAyB,SAAzB,EAAmD,EAAnD,EAA6D,KAA7D,EAA8E;AAAjB,QAAA,KAAA,KAAA,KAAA,CAAA,EAAiB;AAAjB,MAAA,KAAA,GAAA,CAAA;AAAiB,KAAA,CAC5E;AACA;AACA;;;AACA,QAAK,KAAK,KAAK,IAAV,IAAkB,KAAK,GAAG,CAA3B,IAAkC,KAAK,KAAK,IAAV,IAAkB,KAAK,KAAL,GAAa,CAArE,EAAyE;AACvE,aAAO,MAAA,CAAA,SAAA,CAAM,cAAN,CAAoB,IAApB,CAAoB,IAApB,EAAqB,SAArB,EAAgC,EAAhC,EAAoC,KAApC,CAAP;AACD,KAN2E,CAO5E;AACA;AACA;;;AACA,QAAI,SAAS,CAAC,OAAV,CAAkB,MAAlB,KAA6B,CAAjC,EAAoC;AAClC,MAAA,WAAA,CAAA,SAAA,CAAU,cAAV,CAAyB,EAAzB;AACA,MAAA,SAAS,CAAC,SAAV,GAAsB,SAAtB;AACD,KAb2E,CAc5E;;;AACA,WAAO,SAAP;AACD,GAhBS;;AAiBZ,SAAA,UAAA;AAAC,CAtCD,CAAmC,aAAA,CAAA,WAAnC,CAAA;;AAAa,OAAA,CAAA,UAAA,GAAU,UAAV","sourcesContent":["import { Immediate } from '../util/Immediate';\nimport { AsyncAction } from './AsyncAction';\nimport { AsapScheduler } from './AsapScheduler';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class AsapAction<T> extends AsyncAction<T> {\n\n  constructor(protected scheduler: AsapScheduler,\n              protected work: (this: AsapAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  protected requestAsyncId(scheduler: AsapScheduler, id?: any, delay: number = 0): any {\n    // If delay is greater than 0, request as an async action.\n    if (delay !== null && delay > 0) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Push the action to the end of the scheduler queue.\n    scheduler.actions.push(this);\n    // If a microtask has already been scheduled, don't schedule another\n    // one. If a microtask hasn't been scheduled yet, schedule one now. Return\n    // the current scheduled microtask id.\n    return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(\n      scheduler.flush.bind(scheduler, null)\n    ));\n  }\n  protected recycleAsyncId(scheduler: AsapScheduler, id?: any, delay: number = 0): any {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n      return super.recycleAsyncId(scheduler, id, delay);\n    }\n    // If the scheduler queue is empty, cancel the requested microtask and\n    // set the scheduled flag to undefined so the next AsapAction will schedule\n    // its own.\n    if (scheduler.actions.length === 0) {\n      Immediate.clearImmediate(id);\n      scheduler.scheduled = undefined;\n    }\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\n    return undefined;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}