{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subject_1 = require('../Subject');\n\nvar Subscription_1 = require('../Subscription');\n\nvar tryCatch_1 = require('../util/tryCatch');\n\nvar errorObject_1 = require('../util/errorObject');\n\nvar OuterSubscriber_1 = require('../OuterSubscriber');\n\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Branch out the source Observable values as a nested Observable starting from\n * an emission from `openings` and ending when the output of `closingSelector`\n * emits.\n *\n * <span class=\"informal\">It's like {@link bufferToggle}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowToggle.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows that contain those items\n * emitted by the source Observable between the time when the `openings`\n * Observable emits an item and when the Observable returned by\n * `closingSelector` emits an item.\n *\n * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var openings = Rx.Observable.interval(1000);\n * var result = clicks.windowToggle(openings, i =>\n *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n * ).mergeAll();\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowWhen}\n * @see {@link bufferToggle}\n *\n * @param {Observable<O>} openings An observable of notifications to start new\n * windows.\n * @param {function(value: O): Observable} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns an Observable,\n * which, when it emits (either `next` or `complete`), signals that the\n * associated window should complete.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowToggle\n * @owner Observable\n */\n\n\nfunction windowToggle(openings, closingSelector) {\n  return function (source) {\n    return source.lift(new WindowToggleOperator(openings, closingSelector));\n  };\n}\n\nexports.windowToggle = windowToggle;\n\nvar WindowToggleOperator = function () {\n  function WindowToggleOperator(openings, closingSelector) {\n    this.openings = openings;\n    this.closingSelector = closingSelector;\n  }\n\n  WindowToggleOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));\n  };\n\n  return WindowToggleOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar WindowToggleSubscriber = function (_super) {\n  __extends(WindowToggleSubscriber, _super);\n\n  function WindowToggleSubscriber(destination, openings, closingSelector) {\n    _super.call(this, destination);\n\n    this.openings = openings;\n    this.closingSelector = closingSelector;\n    this.contexts = [];\n    this.add(this.openSubscription = subscribeToResult_1.subscribeToResult(this, openings, openings));\n  }\n\n  WindowToggleSubscriber.prototype._next = function (value) {\n    var contexts = this.contexts;\n\n    if (contexts) {\n      var len = contexts.length;\n\n      for (var i = 0; i < len; i++) {\n        contexts[i].window.next(value);\n      }\n    }\n  };\n\n  WindowToggleSubscriber.prototype._error = function (err) {\n    var contexts = this.contexts;\n    this.contexts = null;\n\n    if (contexts) {\n      var len = contexts.length;\n      var index = -1;\n\n      while (++index < len) {\n        var context = contexts[index];\n        context.window.error(err);\n        context.subscription.unsubscribe();\n      }\n    }\n\n    _super.prototype._error.call(this, err);\n  };\n\n  WindowToggleSubscriber.prototype._complete = function () {\n    var contexts = this.contexts;\n    this.contexts = null;\n\n    if (contexts) {\n      var len = contexts.length;\n      var index = -1;\n\n      while (++index < len) {\n        var context = contexts[index];\n        context.window.complete();\n        context.subscription.unsubscribe();\n      }\n    }\n\n    _super.prototype._complete.call(this);\n  };\n  /** @deprecated internal use only */\n\n\n  WindowToggleSubscriber.prototype._unsubscribe = function () {\n    var contexts = this.contexts;\n    this.contexts = null;\n\n    if (contexts) {\n      var len = contexts.length;\n      var index = -1;\n\n      while (++index < len) {\n        var context = contexts[index];\n        context.window.unsubscribe();\n        context.subscription.unsubscribe();\n      }\n    }\n  };\n\n  WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    if (outerValue === this.openings) {\n      var closingSelector = this.closingSelector;\n      var closingNotifier = tryCatch_1.tryCatch(closingSelector)(innerValue);\n\n      if (closingNotifier === errorObject_1.errorObject) {\n        return this.error(errorObject_1.errorObject.e);\n      } else {\n        var window_1 = new Subject_1.Subject();\n        var subscription = new Subscription_1.Subscription();\n        var context = {\n          window: window_1,\n          subscription: subscription\n        };\n        this.contexts.push(context);\n        var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);\n\n        if (innerSubscription.closed) {\n          this.closeWindow(this.contexts.length - 1);\n        } else {\n          innerSubscription.context = context;\n          subscription.add(innerSubscription);\n        }\n\n        this.destination.next(window_1);\n      }\n    } else {\n      this.closeWindow(this.contexts.indexOf(outerValue));\n    }\n  };\n\n  WindowToggleSubscriber.prototype.notifyError = function (err) {\n    this.error(err);\n  };\n\n  WindowToggleSubscriber.prototype.notifyComplete = function (inner) {\n    if (inner !== this.openSubscription) {\n      this.closeWindow(this.contexts.indexOf(inner.context));\n    }\n  };\n\n  WindowToggleSubscriber.prototype.closeWindow = function (index) {\n    if (index === -1) {\n      return;\n    }\n\n    var contexts = this.contexts;\n    var context = contexts[index];\n    var window = context.window,\n        subscription = context.subscription;\n    contexts.splice(index, 1);\n    window.complete();\n    subscription.unsubscribe();\n  };\n\n  return WindowToggleSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);","map":{"version":3,"sources":["../../src/operators/windowToggle.ts"],"names":[],"mappings":"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","sourcesContent":["import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\nimport { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OperatorFunction } from '../interfaces';\n\n/**\n * Branch out the source Observable values as a nested Observable starting from\n * an emission from `openings` and ending when the output of `closingSelector`\n * emits.\n *\n * <span class=\"informal\">It's like {@link bufferToggle}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowToggle.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows that contain those items\n * emitted by the source Observable between the time when the `openings`\n * Observable emits an item and when the Observable returned by\n * `closingSelector` emits an item.\n *\n * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var openings = Rx.Observable.interval(1000);\n * var result = clicks.windowToggle(openings, i =>\n *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n * ).mergeAll();\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowWhen}\n * @see {@link bufferToggle}\n *\n * @param {Observable<O>} openings An observable of notifications to start new\n * windows.\n * @param {function(value: O): Observable} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns an Observable,\n * which, when it emits (either `next` or `complete`), signals that the\n * associated window should complete.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowToggle\n * @owner Observable\n */\nexport function windowToggle<T, O>(openings: Observable<O>,\n                                   closingSelector: (openValue: O) => Observable<any>): OperatorFunction<T, Observable<T>> {\n  return (source: Observable<T>) => source.lift(new WindowToggleOperator<T, O>(openings, closingSelector));\n}\n\nclass WindowToggleOperator<T, O> implements Operator<T, Observable<T>> {\n\n  constructor(private openings: Observable<O>,\n              private closingSelector: (openValue: O) => Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<Observable<T>>, source: any): any {\n    return source.subscribe(new WindowToggleSubscriber(\n      subscriber, this.openings, this.closingSelector\n    ));\n  }\n}\n\ninterface WindowContext<T> {\n  window: Subject<T>;\n  subscription: Subscription;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass WindowToggleSubscriber<T, O> extends OuterSubscriber<T, any> {\n  private contexts: WindowContext<T>[] = [];\n  private openSubscription: Subscription;\n\n  constructor(destination: Subscriber<Observable<T>>,\n              private openings: Observable<O>,\n              private closingSelector: (openValue: O) => Observable<any>) {\n    super(destination);\n    this.add(this.openSubscription = subscribeToResult(this, openings, openings));\n  }\n\n  protected _next(value: T) {\n    const { contexts } = this;\n    if (contexts) {\n      const len = contexts.length;\n      for (let i = 0; i < len; i++) {\n        contexts[i].window.next(value);\n      }\n    }\n  }\n\n  protected _error(err: any) {\n\n    const { contexts } = this;\n    this.contexts = null;\n\n    if (contexts) {\n      const len = contexts.length;\n      let index = -1;\n\n      while (++index < len) {\n        const context = contexts[index];\n        context.window.error(err);\n        context.subscription.unsubscribe();\n      }\n    }\n\n    super._error(err);\n  }\n\n  protected _complete() {\n    const { contexts } = this;\n    this.contexts = null;\n    if (contexts) {\n      const len = contexts.length;\n      let index = -1;\n      while (++index < len) {\n        const context = contexts[index];\n        context.window.complete();\n        context.subscription.unsubscribe();\n      }\n    }\n    super._complete();\n  }\n\n  /** @deprecated internal use only */ _unsubscribe() {\n    const { contexts } = this;\n    this.contexts = null;\n    if (contexts) {\n      const len = contexts.length;\n      let index = -1;\n      while (++index < len) {\n        const context = contexts[index];\n        context.window.unsubscribe();\n        context.subscription.unsubscribe();\n      }\n    }\n  }\n\n  notifyNext(outerValue: any, innerValue: any,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, any>): void {\n\n    if (outerValue === this.openings) {\n\n      const { closingSelector } = this;\n      const closingNotifier = tryCatch(closingSelector)(innerValue);\n\n      if (closingNotifier === errorObject) {\n        return this.error(errorObject.e);\n      } else {\n        const window = new Subject<T>();\n        const subscription = new Subscription();\n        const context = { window, subscription };\n        this.contexts.push(context);\n        const innerSubscription = subscribeToResult(this, closingNotifier, context);\n\n        if (innerSubscription.closed) {\n          this.closeWindow(this.contexts.length - 1);\n        } else {\n          (<any> innerSubscription).context = context;\n          subscription.add(innerSubscription);\n        }\n\n        this.destination.next(window);\n\n      }\n    } else {\n      this.closeWindow(this.contexts.indexOf(outerValue));\n    }\n  }\n\n  notifyError(err: any): void {\n    this.error(err);\n  }\n\n  notifyComplete(inner: Subscription): void {\n    if (inner !== this.openSubscription) {\n      this.closeWindow(this.contexts.indexOf((<any> inner).context));\n    }\n  }\n\n  private closeWindow(index: number): void {\n    if (index === -1) {\n      return;\n    }\n\n    const { contexts } = this;\n    const context = contexts[index];\n    const { window, subscription } = context;\n    contexts.splice(index, 1);\n    window.complete();\n    subscription.unsubscribe();\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}