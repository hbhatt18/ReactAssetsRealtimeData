{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar OuterSubscriber_1 = require('../OuterSubscriber');\n\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable only if the previous projected Observable has completed.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link exhaust}.</span>\n *\n * <img src=\"./img/exhaustMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. When it projects a source value to\n * an Observable, the output Observable begins emitting the items emitted by\n * that projected Observable. However, `exhaustMap` ignores every new projected\n * Observable if the previous projected Observable has not yet completed. Once\n * that one completes, it will accept and flatten the next projected Observable\n * and repeat this process.\n *\n * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000).take(5));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaust}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable containing projected Observables\n * of each item of the source, ignoring projected Observables that start before\n * their preceding Observable has completed.\n * @method exhaustMap\n * @owner Observable\n */\n\n\nfunction exhaustMap(project, resultSelector) {\n  return function (source) {\n    return source.lift(new SwitchFirstMapOperator(project, resultSelector));\n  };\n}\n\nexports.exhaustMap = exhaustMap;\n\nvar SwitchFirstMapOperator = function () {\n  function SwitchFirstMapOperator(project, resultSelector) {\n    this.project = project;\n    this.resultSelector = resultSelector;\n  }\n\n  SwitchFirstMapOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new SwitchFirstMapSubscriber(subscriber, this.project, this.resultSelector));\n  };\n\n  return SwitchFirstMapOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar SwitchFirstMapSubscriber = function (_super) {\n  __extends(SwitchFirstMapSubscriber, _super);\n\n  function SwitchFirstMapSubscriber(destination, project, resultSelector) {\n    _super.call(this, destination);\n\n    this.project = project;\n    this.resultSelector = resultSelector;\n    this.hasSubscription = false;\n    this.hasCompleted = false;\n    this.index = 0;\n  }\n\n  SwitchFirstMapSubscriber.prototype._next = function (value) {\n    if (!this.hasSubscription) {\n      this.tryNext(value);\n    }\n  };\n\n  SwitchFirstMapSubscriber.prototype.tryNext = function (value) {\n    var index = this.index++;\n    var destination = this.destination;\n\n    try {\n      var result = this.project(value, index);\n      this.hasSubscription = true;\n      this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));\n    } catch (err) {\n      destination.error(err);\n    }\n  };\n\n  SwitchFirstMapSubscriber.prototype._complete = function () {\n    this.hasCompleted = true;\n\n    if (!this.hasSubscription) {\n      this.destination.complete();\n    }\n  };\n\n  SwitchFirstMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    var _a = this,\n        resultSelector = _a.resultSelector,\n        destination = _a.destination;\n\n    if (resultSelector) {\n      this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);\n    } else {\n      destination.next(innerValue);\n    }\n  };\n\n  SwitchFirstMapSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {\n    var _a = this,\n        resultSelector = _a.resultSelector,\n        destination = _a.destination;\n\n    try {\n      var result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n      destination.next(result);\n    } catch (err) {\n      destination.error(err);\n    }\n  };\n\n  SwitchFirstMapSubscriber.prototype.notifyError = function (err) {\n    this.destination.error(err);\n  };\n\n  SwitchFirstMapSubscriber.prototype.notifyComplete = function (innerSub) {\n    this.remove(innerSub);\n    this.hasSubscription = false;\n\n    if (this.hasCompleted) {\n      this.destination.complete();\n    }\n  };\n\n  return SwitchFirstMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);","map":{"version":3,"sources":["../../src/operators/exhaustMap.ts"],"names":[],"mappings":"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","sourcesContent":["import { Operator } from '../Operator';\nimport { Observable, ObservableInput } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function exhaustMap<T, R>(project: (value: T, index: number) => ObservableInput<R>): OperatorFunction<T, R>;\nexport function exhaustMap<T, I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable only if the previous projected Observable has completed.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link exhaust}.</span>\n *\n * <img src=\"./img/exhaustMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. When it projects a source value to\n * an Observable, the output Observable begins emitting the items emitted by\n * that projected Observable. However, `exhaustMap` ignores every new projected\n * Observable if the previous projected Observable has not yet completed. Once\n * that one completes, it will accept and flatten the next projected Observable\n * and repeat this process.\n *\n * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000).take(5));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaust}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable containing projected Observables\n * of each item of the source, ignoring projected Observables that start before\n * their preceding Observable has completed.\n * @method exhaustMap\n * @owner Observable\n */\nexport function exhaustMap<T, I, R>(\n  project: (value: T, index: number) => ObservableInput<I>,\n  resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R\n  ): OperatorFunction<T, R> {\n    return (source: Observable<T>) => source.lift(new SwitchFirstMapOperator(project, resultSelector));\n  }\n\nclass SwitchFirstMapOperator<T, I, R> implements Operator<T, R> {\n  constructor(private project: (value: T, index: number) => ObservableInput<I>,\n              private resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new SwitchFirstMapSubscriber(subscriber, this.project, this.resultSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SwitchFirstMapSubscriber<T, I, R> extends OuterSubscriber<T, I> {\n  private hasSubscription: boolean = false;\n  private hasCompleted: boolean = false;\n  private index: number = 0;\n\n  constructor(destination: Subscriber<R>,\n              private project: (value: T, index: number) => ObservableInput<I>,\n              private resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    if (!this.hasSubscription) {\n      this.tryNext(value);\n    }\n  }\n\n  private tryNext(value: T): void {\n    const index = this.index++;\n    const destination = this.destination;\n    try {\n      const result = this.project(value, index);\n      this.hasSubscription = true;\n      this.add(subscribeToResult(this, result, value, index));\n    } catch (err) {\n      destination.error(err);\n    }\n  }\n\n  protected _complete(): void {\n    this.hasCompleted = true;\n    if (!this.hasSubscription) {\n      this.destination.complete();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: I,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, I>): void {\n    const { resultSelector, destination } = this;\n    if (resultSelector) {\n      this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);\n    } else {\n      destination.next(innerValue);\n    }\n  }\n\n  private trySelectResult(outerValue: T, innerValue: I,\n                          outerIndex: number, innerIndex: number): void {\n    const { resultSelector, destination } = this;\n    try {\n      const result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n      destination.next(result);\n    } catch (err) {\n      destination.error(err);\n    }\n  }\n\n  notifyError(err: any): void {\n    this.destination.error(err);\n  }\n\n  notifyComplete(innerSub: Subscription): void {\n    this.remove(innerSub);\n\n    this.hasSubscription = false;\n    if (this.hasCompleted) {\n      this.destination.complete();\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}