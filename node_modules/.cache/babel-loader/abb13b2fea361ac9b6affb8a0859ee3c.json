{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar OuterSubscriber_1 = require('../OuterSubscriber');\n\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to the same Observable which is flattened multiple\n * times with {@link switch} in the output Observable.\n *\n * <span class=\"informal\">It's like {@link switchMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * <img src=\"./img/switchMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. The output Observables\n * emits values only from the most recently emitted instance of\n * `innerObservable`.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMapTo(Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMapTo}\n * @see {@link switch}\n * @see {@link switchMap}\n * @see {@link mergeMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits items from the given\n * `innerObservable` (and optionally transformed through `resultSelector`) every\n * time a value is emitted on the source Observable, and taking only the values\n * from the most recently projected inner Observable.\n * @method switchMapTo\n * @owner Observable\n */\n\n\nfunction switchMapTo(innerObservable, resultSelector) {\n  return function (source) {\n    return source.lift(new SwitchMapToOperator(innerObservable, resultSelector));\n  };\n}\n\nexports.switchMapTo = switchMapTo;\n\nvar SwitchMapToOperator = function () {\n  function SwitchMapToOperator(observable, resultSelector) {\n    this.observable = observable;\n    this.resultSelector = resultSelector;\n  }\n\n  SwitchMapToOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new SwitchMapToSubscriber(subscriber, this.observable, this.resultSelector));\n  };\n\n  return SwitchMapToOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar SwitchMapToSubscriber = function (_super) {\n  __extends(SwitchMapToSubscriber, _super);\n\n  function SwitchMapToSubscriber(destination, inner, resultSelector) {\n    _super.call(this, destination);\n\n    this.inner = inner;\n    this.resultSelector = resultSelector;\n    this.index = 0;\n  }\n\n  SwitchMapToSubscriber.prototype._next = function (value) {\n    var innerSubscription = this.innerSubscription;\n\n    if (innerSubscription) {\n      innerSubscription.unsubscribe();\n    }\n\n    this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, this.inner, value, this.index++));\n  };\n\n  SwitchMapToSubscriber.prototype._complete = function () {\n    var innerSubscription = this.innerSubscription;\n\n    if (!innerSubscription || innerSubscription.closed) {\n      _super.prototype._complete.call(this);\n    }\n  };\n  /** @deprecated internal use only */\n\n\n  SwitchMapToSubscriber.prototype._unsubscribe = function () {\n    this.innerSubscription = null;\n  };\n\n  SwitchMapToSubscriber.prototype.notifyComplete = function (innerSub) {\n    this.remove(innerSub);\n    this.innerSubscription = null;\n\n    if (this.isStopped) {\n      _super.prototype._complete.call(this);\n    }\n  };\n\n  SwitchMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    var _a = this,\n        resultSelector = _a.resultSelector,\n        destination = _a.destination;\n\n    if (resultSelector) {\n      this.tryResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n    } else {\n      destination.next(innerValue);\n    }\n  };\n\n  SwitchMapToSubscriber.prototype.tryResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {\n    var _a = this,\n        resultSelector = _a.resultSelector,\n        destination = _a.destination;\n\n    var result;\n\n    try {\n      result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n    } catch (err) {\n      destination.error(err);\n      return;\n    }\n\n    destination.next(result);\n  };\n\n  return SwitchMapToSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);","map":{"version":3,"sources":["../../src/operators/switchMapTo.ts"],"names":[],"mappings":"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","sourcesContent":["import { Operator } from '../Operator';\nimport { Observable, ObservableInput } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function switchMapTo<T, R>(observable: ObservableInput<R>): OperatorFunction<T, R>;\nexport function switchMapTo<T, I, R>(observable: ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to the same Observable which is flattened multiple\n * times with {@link switch} in the output Observable.\n *\n * <span class=\"informal\">It's like {@link switchMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * <img src=\"./img/switchMapTo.png\" width=\"100%\">\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. The output Observables\n * emits values only from the most recently emitted instance of\n * `innerObservable`.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMapTo(Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMapTo}\n * @see {@link switch}\n * @see {@link switchMap}\n * @see {@link mergeMapTo}\n *\n * @param {ObservableInput} innerObservable An Observable to replace each value from\n * the source Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits items from the given\n * `innerObservable` (and optionally transformed through `resultSelector`) every\n * time a value is emitted on the source Observable, and taking only the values\n * from the most recently projected inner Observable.\n * @method switchMapTo\n * @owner Observable\n */\nexport function switchMapTo<T, I, R>(innerObservable: Observable<I>,\n                                     resultSelector?: (outerValue: T,\n                                                       innerValue: I,\n                                                       outerIndex: number,\n                                                       innerIndex: number) => R): OperatorFunction<T, I | R> {\n  return (source: Observable<T>) => source.lift(new SwitchMapToOperator(innerObservable, resultSelector));\n}\n\nclass SwitchMapToOperator<T, I, R> implements Operator<T, I> {\n  constructor(private observable: Observable<I>,\n              private resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R) {\n  }\n\n  call(subscriber: Subscriber<I>, source: any): any {\n    return source.subscribe(new SwitchMapToSubscriber(subscriber, this.observable, this.resultSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SwitchMapToSubscriber<T, I, R> extends OuterSubscriber<T, I> {\n  private index: number = 0;\n  private innerSubscription: Subscription;\n\n  constructor(destination: Subscriber<I>,\n              private inner: Observable<I>,\n              private resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R) {\n    super(destination);\n  }\n\n  protected _next(value: any) {\n    const innerSubscription = this.innerSubscription;\n    if (innerSubscription) {\n      innerSubscription.unsubscribe();\n    }\n    this.add(this.innerSubscription = subscribeToResult(this, this.inner, value, this.index++));\n  }\n\n  protected _complete() {\n    const {innerSubscription} = this;\n    if (!innerSubscription || innerSubscription.closed) {\n      super._complete();\n    }\n  }\n\n  /** @deprecated internal use only */ _unsubscribe() {\n    this.innerSubscription = null;\n  }\n\n  notifyComplete(innerSub: Subscription) {\n    this.remove(innerSub);\n    this.innerSubscription = null;\n    if (this.isStopped) {\n      super._complete();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: I,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, I>): void {\n    const { resultSelector, destination } = this;\n    if (resultSelector) {\n      this.tryResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n    } else {\n      destination.next(innerValue);\n    }\n  }\n\n  private tryResultSelector(outerValue: T, innerValue: I,\n                            outerIndex: number, innerIndex: number): void {\n    const { resultSelector, destination } = this;\n    let result: R;\n    try {\n      result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n    } catch (err) {\n      destination.error(err);\n      return;\n    }\n\n    destination.next(result);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}