{"ast":null,"code":"\"use strict\";\n\nvar async_1 = require('../scheduler/async');\n\nvar isNumeric_1 = require('../util/isNumeric');\n\nvar isScheduler_1 = require('../util/isScheduler');\n\nvar windowTime_1 = require('../operators/windowTime');\n\nfunction windowTime(windowTimeSpan) {\n  var scheduler = async_1.async;\n  var windowCreationInterval = null;\n  var maxWindowSize = Number.POSITIVE_INFINITY;\n\n  if (isScheduler_1.isScheduler(arguments[3])) {\n    scheduler = arguments[3];\n  }\n\n  if (isScheduler_1.isScheduler(arguments[2])) {\n    scheduler = arguments[2];\n  } else if (isNumeric_1.isNumeric(arguments[2])) {\n    maxWindowSize = arguments[2];\n  }\n\n  if (isScheduler_1.isScheduler(arguments[1])) {\n    scheduler = arguments[1];\n  } else if (isNumeric_1.isNumeric(arguments[1])) {\n    windowCreationInterval = arguments[1];\n  }\n\n  return windowTime_1.windowTime(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler)(this);\n}\n\nexports.windowTime = windowTime;","map":{"version":3,"sources":["../../src/operator/windowTime.ts"],"names":[],"mappings":";;AACA,IAAA,OAAA,GAAA,OAAA,CAAsB,oBAAtB,CAAA;;AAEA,IAAA,WAAA,GAAA,OAAA,CAA0B,mBAA1B,CAAA;;AACA,IAAA,aAAA,GAAA,OAAA,CAA4B,qBAA5B,CAAA;;AACA,IAAA,YAAA,GAAA,OAAA,CAA0C,yBAA1C,CAAA;;AAwEA,SAAA,UAAA,CAC8B,cAD9B,EACoD;AAElD,MAAI,SAAS,GAAe,OAAA,CAAA,KAA5B;AACA,MAAI,sBAAsB,GAAW,IAArC;AACA,MAAI,aAAa,GAAW,MAAM,CAAC,iBAAnC;;AAEA,MAAI,aAAA,CAAA,WAAA,CAAY,SAAS,CAAC,CAAD,CAArB,CAAJ,EAA+B;AAC7B,IAAA,SAAS,GAAG,SAAS,CAAC,CAAD,CAArB;AACD;;AAED,MAAI,aAAA,CAAA,WAAA,CAAY,SAAS,CAAC,CAAD,CAArB,CAAJ,EAA+B;AAC7B,IAAA,SAAS,GAAG,SAAS,CAAC,CAAD,CAArB;AACD,GAFD,MAEO,IAAI,WAAA,CAAA,SAAA,CAAU,SAAS,CAAC,CAAD,CAAnB,CAAJ,EAA6B;AAClC,IAAA,aAAa,GAAG,SAAS,CAAC,CAAD,CAAzB;AACD;;AAED,MAAI,aAAA,CAAA,WAAA,CAAY,SAAS,CAAC,CAAD,CAArB,CAAJ,EAA+B;AAC7B,IAAA,SAAS,GAAG,SAAS,CAAC,CAAD,CAArB;AACD,GAFD,MAEO,IAAI,WAAA,CAAA,SAAA,CAAU,SAAS,CAAC,CAAD,CAAnB,CAAJ,EAA6B;AAClC,IAAA,sBAAsB,GAAG,SAAS,CAAC,CAAD,CAAlC;AACD;;AAED,SAAO,YAAA,CAAA,UAAA,CAAY,cAAZ,EAA4B,sBAA5B,EAAoD,aAApD,EAAmE,SAAnE,EAA8E,IAA9E,CAAP;AACD;;AAxBe,OAAA,CAAA,UAAA,GAAU,UAAV","sourcesContent":["import { IScheduler } from '../Scheduler';\nimport { async } from '../scheduler/async';\nimport { Observable } from '../Observable';\nimport { isNumeric } from '../util/isNumeric';\nimport { isScheduler } from '../util/isScheduler';\nimport { windowTime as higherOrder } from '../operators/windowTime';\n\n/**\n * Branch out the source Observable values as a nested Observable periodically\n * in time.\n *\n * <span class=\"informal\">It's like {@link bufferTime}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowTime.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable starts a new window periodically, as\n * determined by the `windowCreationInterval` argument. It emits each window\n * after a fixed timespan, specified by the `windowTimeSpan` argument. When the\n * source Observable completes or encounters an error, the output Observable\n * emits the current window and propagates the notification from the source\n * Observable. If `windowCreationInterval` is not provided, the output\n * Observable starts a new window when the previous window of duration\n * `windowTimeSpan` completes. If `maxWindowCount` is provided, each window\n * will emit at most fixed number of values. Window will complete immediately\n * after emitting last value and next one still will open as specified by\n * `windowTimeSpan` and `windowCreationInterval` arguments.\n *\n * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowTime(1000)\n *   .map(win => win.take(2)) // each window has at most 2 emissions\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Every 5 seconds start a window 1 second long, and emit at most 2 click events per window</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowTime(1000, 5000)\n *   .map(win => win.take(2)) // each window has at most 2 emissions\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Same as example above but with maxWindowCount instead of take</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowTime(1000, 5000, 2) // each window has still at most 2 emissions\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferTime}\n *\n * @param {number} windowTimeSpan The amount of time to fill each window.\n * @param {number} [windowCreationInterval] The interval at which to start new\n * windows.\n * @param {number} [maxWindowSize=Number.POSITIVE_INFINITY] Max number of\n * values each window can emit before completion.\n * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the\n * intervals that determine window boundaries.\n * @return {Observable<Observable<T>>} An observable of windows, which in turn\n * are Observables.\n * @method windowTime\n * @owner Observable\n */\nexport function windowTime<T>(this: Observable<T>, windowTimeSpan: number,\n                              scheduler?: IScheduler): Observable<Observable<T>>;\nexport function windowTime<T>(this: Observable<T>, windowTimeSpan: number,\n                              windowCreationInterval: number,\n                              scheduler?: IScheduler): Observable<Observable<T>>;\nexport function windowTime<T>(this: Observable<T>, windowTimeSpan: number,\n                              windowCreationInterval: number,\n                              maxWindowSize: number,\n                              scheduler?: IScheduler): Observable<Observable<T>>;\n\nexport function windowTime<T>(this: Observable<T>,\n                              windowTimeSpan: number): Observable<Observable<T>> {\n\n  let scheduler: IScheduler = async;\n  let windowCreationInterval: number = null;\n  let maxWindowSize: number = Number.POSITIVE_INFINITY;\n\n  if (isScheduler(arguments[3])) {\n    scheduler = arguments[3];\n  }\n\n  if (isScheduler(arguments[2])) {\n    scheduler = arguments[2];\n  } else if (isNumeric(arguments[2])) {\n    maxWindowSize = arguments[2];\n  }\n\n  if (isScheduler(arguments[1])) {\n    scheduler = arguments[1];\n  } else if (isNumeric(arguments[1])) {\n    windowCreationInterval = arguments[1];\n  }\n\n  return higherOrder(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler)(this) as Observable<Observable<T>>;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}