{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar OuterSubscriber_1 = require('../OuterSubscriber');\n\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Emits the most recently emitted value from the source Observable whenever\n * another Observable, the `notifier`, emits.\n *\n * <span class=\"informal\">It's like {@link sampleTime}, but samples whenever\n * the `notifier` Observable emits something.</span>\n *\n * <img src=\"./img/sample.png\" width=\"100%\">\n *\n * Whenever the `notifier` Observable emits a value or completes, `sample`\n * looks at the source Observable and emits whichever value it has most recently\n * emitted since the previous sampling, unless the source has not emitted\n * anything since the previous sampling. The `notifier` is subscribed to as soon\n * as the output Observable is subscribed.\n *\n * @example <caption>On every click, sample the most recent \"seconds\" timer</caption>\n * var seconds = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = seconds.sample(clicks);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {Observable<any>} notifier The Observable to use for sampling the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the results of sampling the\n * values emitted by the source Observable whenever the notifier Observable\n * emits value or completes.\n * @method sample\n * @owner Observable\n */\n\n\nfunction sample(notifier) {\n  return function (source) {\n    return source.lift(new SampleOperator(notifier));\n  };\n}\n\nexports.sample = sample;\n\nvar SampleOperator = function () {\n  function SampleOperator(notifier) {\n    this.notifier = notifier;\n  }\n\n  SampleOperator.prototype.call = function (subscriber, source) {\n    var sampleSubscriber = new SampleSubscriber(subscriber);\n    var subscription = source.subscribe(sampleSubscriber);\n    subscription.add(subscribeToResult_1.subscribeToResult(sampleSubscriber, this.notifier));\n    return subscription;\n  };\n\n  return SampleOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar SampleSubscriber = function (_super) {\n  __extends(SampleSubscriber, _super);\n\n  function SampleSubscriber() {\n    _super.apply(this, arguments);\n\n    this.hasValue = false;\n  }\n\n  SampleSubscriber.prototype._next = function (value) {\n    this.value = value;\n    this.hasValue = true;\n  };\n\n  SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this.emitValue();\n  };\n\n  SampleSubscriber.prototype.notifyComplete = function () {\n    this.emitValue();\n  };\n\n  SampleSubscriber.prototype.emitValue = function () {\n    if (this.hasValue) {\n      this.hasValue = false;\n      this.destination.next(this.value);\n    }\n  };\n\n  return SampleSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);","map":{"version":3,"sources":["../../src/operators/sample.ts"],"names":[],"mappings":";;;;;;;;;;;;AAIA,IAAA,iBAAA,GAAA,OAAA,CAAgC,oBAAhC,CAAA;;AAEA,IAAA,mBAAA,GAAA,OAAA,CAAkC,2BAAlC,CAAA;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCA,SAAA,MAAA,CAA0B,QAA1B,EAAmD;AACjD,SAAO,UAAC,MAAD,EAAsB;AAAK,WAAA,MAAM,CAAC,IAAP,CAAY,IAAI,cAAJ,CAAZ,QAAY,CAAZ,CAAA;AAAyC,GAA3E;AACD;;AAFe,OAAA,CAAA,MAAA,GAAM,MAAN;;AAIhB,IAAA,cAAA,GAAA,YAAA;AACE,WAAA,cAAA,CAAoB,QAApB,EAA6C;AAAzB,SAAA,QAAA,GAAA,QAAA;AACnB;;AAED,EAAA,cAAA,CAAA,SAAA,CAAA,IAAA,GAAA,UAAK,UAAL,EAAgC,MAAhC,EAA2C;AACzC,QAAM,gBAAgB,GAAG,IAAI,gBAAJ,CAAqB,UAArB,CAAzB;AACA,QAAM,YAAY,GAAG,MAAM,CAAC,SAAP,CAAiB,gBAAjB,CAArB;AACA,IAAA,YAAY,CAAC,GAAb,CAAiB,mBAAA,CAAA,iBAAA,CAAkB,gBAAlB,EAAoC,KAAK,QAAzC,CAAjB;AACA,WAAO,YAAP;AACD,GALD;;AAMF,SAAA,cAAA;AAAC,CAVD,EAAA;AAYA;;;;;;;AAKA,IAAA,gBAAA,GAAA,UAAA,MAAA,EAAA;AAAqC,EAAA,SAAA,CAAA,gBAAA,EAAA,MAAA,CAAA;;AAArC,WAAA,gBAAA,GAAA;AAAqC,IAAA,MAAA,CAAA,KAAA,CAAA,IAAA,EAAA,SAAA;;AAE3B,SAAA,QAAA,GAAoB,KAApB;AAuBT;;AArBW,EAAA,gBAAA,CAAA,SAAA,CAAA,KAAA,GAAV,UAAgB,KAAhB,EAAwB;AACtB,SAAK,KAAL,GAAa,KAAb;AACA,SAAK,QAAL,GAAgB,IAAhB;AACD,GAHS;;AAKV,EAAA,gBAAA,CAAA,SAAA,CAAA,UAAA,GAAA,UAAW,UAAX,EAA0B,UAA1B,EACW,UADX,EAC+B,UAD/B,EAEW,QAFX,EAE0C;AACxC,SAAK,SAAL;AACD,GAJD;;AAMA,EAAA,gBAAA,CAAA,SAAA,CAAA,cAAA,GAAA,YAAA;AACE,SAAK,SAAL;AACD,GAFD;;AAIA,EAAA,gBAAA,CAAA,SAAA,CAAA,SAAA,GAAA,YAAA;AACE,QAAI,KAAK,QAAT,EAAmB;AACjB,WAAK,QAAL,GAAgB,KAAhB;AACA,WAAK,WAAL,CAAiB,IAAjB,CAAsB,KAAK,KAA3B;AACD;AACF,GALD;;AAMF,SAAA,gBAAA;AAAC,CAzBD,CAAqC,iBAAA,CAAA,eAArC,CAAA","sourcesContent":["import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { TeardownLogic } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\n\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Emits the most recently emitted value from the source Observable whenever\n * another Observable, the `notifier`, emits.\n *\n * <span class=\"informal\">It's like {@link sampleTime}, but samples whenever\n * the `notifier` Observable emits something.</span>\n *\n * <img src=\"./img/sample.png\" width=\"100%\">\n *\n * Whenever the `notifier` Observable emits a value or completes, `sample`\n * looks at the source Observable and emits whichever value it has most recently\n * emitted since the previous sampling, unless the source has not emitted\n * anything since the previous sampling. The `notifier` is subscribed to as soon\n * as the output Observable is subscribed.\n *\n * @example <caption>On every click, sample the most recent \"seconds\" timer</caption>\n * var seconds = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = seconds.sample(clicks);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param {Observable<any>} notifier The Observable to use for sampling the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the results of sampling the\n * values emitted by the source Observable whenever the notifier Observable\n * emits value or completes.\n * @method sample\n * @owner Observable\n */\nexport function sample<T>(notifier: Observable<any>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new SampleOperator(notifier));\n}\n\nclass SampleOperator<T> implements Operator<T, T> {\n  constructor(private notifier: Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    const sampleSubscriber = new SampleSubscriber(subscriber);\n    const subscription = source.subscribe(sampleSubscriber);\n    subscription.add(subscribeToResult(sampleSubscriber, this.notifier));\n    return subscription;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SampleSubscriber<T, R> extends OuterSubscriber<T, R> {\n  private value: T;\n  private hasValue: boolean = false;\n\n  protected _next(value: T) {\n    this.value = value;\n    this.hasValue = true;\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.emitValue();\n  }\n\n  notifyComplete(): void {\n    this.emitValue();\n  }\n\n  emitValue() {\n    if (this.hasValue) {\n      this.hasValue = false;\n      this.destination.next(this.value);\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}