{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar tryCatch_1 = require('../util/tryCatch');\n\nvar errorObject_1 = require('../util/errorObject');\n\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n\nvar OuterSubscriber_1 = require('../OuterSubscriber');\n/**\n * Applies an accumulator function over the source Observable where the\n * accumulator function itself returns an Observable, then each intermediate\n * Observable returned is merged into the output Observable.\n *\n * <span class=\"informal\">It's like {@link scan}, but the Observables returned\n * by the accumulator are merged into the outer Observable.</span>\n *\n * @example <caption>Count the number of click events</caption>\n * const click$ = Rx.Observable.fromEvent(document, 'click');\n * const one$ = click$.mapTo(1);\n * const seed = 0;\n * const count$ = one$.mergeScan((acc, one) => Rx.Observable.of(acc + one), seed);\n * count$.subscribe(x => console.log(x));\n *\n * // Results:\n * 1\n * 2\n * 3\n * 4\n * // ...and so on for each click\n *\n * @param {function(acc: R, value: T): Observable<R>} accumulator\n * The accumulator function called on each source value.\n * @param seed The initial accumulation value.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of\n * input Observables being subscribed to concurrently.\n * @return {Observable<R>} An observable of the accumulated values.\n * @method mergeScan\n * @owner Observable\n */\n\n\nfunction mergeScan(accumulator, seed, concurrent) {\n  if (concurrent === void 0) {\n    concurrent = Number.POSITIVE_INFINITY;\n  }\n\n  return function (source) {\n    return source.lift(new MergeScanOperator(accumulator, seed, concurrent));\n  };\n}\n\nexports.mergeScan = mergeScan;\n\nvar MergeScanOperator = function () {\n  function MergeScanOperator(accumulator, seed, concurrent) {\n    this.accumulator = accumulator;\n    this.seed = seed;\n    this.concurrent = concurrent;\n  }\n\n  MergeScanOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));\n  };\n\n  return MergeScanOperator;\n}();\n\nexports.MergeScanOperator = MergeScanOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nvar MergeScanSubscriber = function (_super) {\n  __extends(MergeScanSubscriber, _super);\n\n  function MergeScanSubscriber(destination, accumulator, acc, concurrent) {\n    _super.call(this, destination);\n\n    this.accumulator = accumulator;\n    this.acc = acc;\n    this.concurrent = concurrent;\n    this.hasValue = false;\n    this.hasCompleted = false;\n    this.buffer = [];\n    this.active = 0;\n    this.index = 0;\n  }\n\n  MergeScanSubscriber.prototype._next = function (value) {\n    if (this.active < this.concurrent) {\n      var index = this.index++;\n      var ish = tryCatch_1.tryCatch(this.accumulator)(this.acc, value);\n      var destination = this.destination;\n\n      if (ish === errorObject_1.errorObject) {\n        destination.error(errorObject_1.errorObject.e);\n      } else {\n        this.active++;\n\n        this._innerSub(ish, value, index);\n      }\n    } else {\n      this.buffer.push(value);\n    }\n  };\n\n  MergeScanSubscriber.prototype._innerSub = function (ish, value, index) {\n    this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n  };\n\n  MergeScanSubscriber.prototype._complete = function () {\n    this.hasCompleted = true;\n\n    if (this.active === 0 && this.buffer.length === 0) {\n      if (this.hasValue === false) {\n        this.destination.next(this.acc);\n      }\n\n      this.destination.complete();\n    }\n  };\n\n  MergeScanSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    var destination = this.destination;\n    this.acc = innerValue;\n    this.hasValue = true;\n    destination.next(innerValue);\n  };\n\n  MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {\n    var buffer = this.buffer;\n    this.remove(innerSub);\n    this.active--;\n\n    if (buffer.length > 0) {\n      this._next(buffer.shift());\n    } else if (this.active === 0 && this.hasCompleted) {\n      if (this.hasValue === false) {\n        this.destination.next(this.acc);\n      }\n\n      this.destination.complete();\n    }\n  };\n\n  return MergeScanSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n\nexports.MergeScanSubscriber = MergeScanSubscriber;","map":{"version":3,"sources":["../../src/operators/mergeScan.ts"],"names":[],"mappings":"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","sourcesContent":["import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { OperatorFunction } from '../interfaces';\n\n/**\n * Applies an accumulator function over the source Observable where the\n * accumulator function itself returns an Observable, then each intermediate\n * Observable returned is merged into the output Observable.\n *\n * <span class=\"informal\">It's like {@link scan}, but the Observables returned\n * by the accumulator are merged into the outer Observable.</span>\n *\n * @example <caption>Count the number of click events</caption>\n * const click$ = Rx.Observable.fromEvent(document, 'click');\n * const one$ = click$.mapTo(1);\n * const seed = 0;\n * const count$ = one$.mergeScan((acc, one) => Rx.Observable.of(acc + one), seed);\n * count$.subscribe(x => console.log(x));\n *\n * // Results:\n * 1\n * 2\n * 3\n * 4\n * // ...and so on for each click\n *\n * @param {function(acc: R, value: T): Observable<R>} accumulator\n * The accumulator function called on each source value.\n * @param seed The initial accumulation value.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of\n * input Observables being subscribed to concurrently.\n * @return {Observable<R>} An observable of the accumulated values.\n * @method mergeScan\n * @owner Observable\n */\nexport function mergeScan<T, R>(accumulator: (acc: R, value: T) => Observable<R>,\n                                seed: R,\n                                concurrent: number = Number.POSITIVE_INFINITY): OperatorFunction<T, R> {\n  return (source: Observable<T>) => source.lift(new MergeScanOperator(accumulator, seed, concurrent));\n}\n\nexport class MergeScanOperator<T, R> implements Operator<T, R> {\n  constructor(private accumulator: (acc: R, value: T) => Observable<R>,\n              private seed: R,\n              private concurrent: number) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new MergeScanSubscriber(\n      subscriber, this.accumulator, this.seed, this.concurrent\n    ));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class MergeScanSubscriber<T, R> extends OuterSubscriber<T, R> {\n  private hasValue: boolean = false;\n  private hasCompleted: boolean = false;\n  private buffer: Observable<any>[] = [];\n  private active: number = 0;\n  protected index: number = 0;\n\n  constructor(destination: Subscriber<R>,\n              private accumulator: (acc: R, value: T) => Observable<R>,\n              private acc: R,\n              private concurrent: number) {\n    super(destination);\n  }\n\n  protected _next(value: any): void {\n    if (this.active < this.concurrent) {\n      const index = this.index++;\n      const ish = tryCatch(this.accumulator)(this.acc, value);\n      const destination = this.destination;\n      if (ish === errorObject) {\n        destination.error(errorObject.e);\n      } else {\n        this.active++;\n        this._innerSub(ish, value, index);\n      }\n    } else {\n      this.buffer.push(value);\n    }\n  }\n\n  private _innerSub(ish: any, value: T, index: number): void {\n    this.add(subscribeToResult<T, R>(this, ish, value, index));\n  }\n\n  protected _complete(): void {\n    this.hasCompleted = true;\n    if (this.active === 0 && this.buffer.length === 0) {\n      if (this.hasValue === false) {\n        this.destination.next(this.acc);\n      }\n      this.destination.complete();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    const { destination } = this;\n    this.acc = innerValue;\n    this.hasValue = true;\n    destination.next(innerValue);\n  }\n\n  notifyComplete(innerSub: Subscription): void {\n    const buffer = this.buffer;\n    this.remove(innerSub);\n    this.active--;\n    if (buffer.length > 0) {\n      this._next(buffer.shift());\n    } else if (this.active === 0 && this.hasCompleted) {\n      if (this.hasValue === false) {\n        this.destination.next(this.acc);\n      }\n      this.destination.complete();\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}