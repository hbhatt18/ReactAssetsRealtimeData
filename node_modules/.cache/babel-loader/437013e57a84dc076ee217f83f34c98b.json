{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = require('../Subscriber');\n\nvar Subject_1 = require('../Subject');\n/**\n * Branch out the source Observable values as a nested Observable with each\n * nested Observable emitting at most `windowSize` values.\n *\n * <span class=\"informal\">It's like {@link bufferCount}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowCount.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows every `startWindowEvery`\n * items, each containing no more than `windowSize` items. When the source\n * Observable completes or encounters an error, the output Observable emits\n * the current window and propagates the notification from the source\n * Observable. If `startWindowEvery` is not provided, then new windows are\n * started immediately at the start of the source and when each window completes\n * with size `windowSize`.\n *\n * @example <caption>Ignore every 3rd click event, starting from the first one</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowCount(3)\n *   .map(win => win.skip(1)) // skip first of every 3 clicks\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Ignore every 3rd click event, starting from the third one</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowCount(2, 3)\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferCount}\n *\n * @param {number} windowSize The maximum number of values emitted by each\n * window.\n * @param {number} [startWindowEvery] Interval at which to start a new window.\n * For example if `startWindowEvery` is `2`, then a new window will be started\n * on every other value from the source. A new window is started at the\n * beginning of the source by default.\n * @return {Observable<Observable<T>>} An Observable of windows, which in turn\n * are Observable of values.\n * @method windowCount\n * @owner Observable\n */\n\n\nfunction windowCount(windowSize, startWindowEvery) {\n  if (startWindowEvery === void 0) {\n    startWindowEvery = 0;\n  }\n\n  return function windowCountOperatorFunction(source) {\n    return source.lift(new WindowCountOperator(windowSize, startWindowEvery));\n  };\n}\n\nexports.windowCount = windowCount;\n\nvar WindowCountOperator = function () {\n  function WindowCountOperator(windowSize, startWindowEvery) {\n    this.windowSize = windowSize;\n    this.startWindowEvery = startWindowEvery;\n  }\n\n  WindowCountOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));\n  };\n\n  return WindowCountOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar WindowCountSubscriber = function (_super) {\n  __extends(WindowCountSubscriber, _super);\n\n  function WindowCountSubscriber(destination, windowSize, startWindowEvery) {\n    _super.call(this, destination);\n\n    this.destination = destination;\n    this.windowSize = windowSize;\n    this.startWindowEvery = startWindowEvery;\n    this.windows = [new Subject_1.Subject()];\n    this.count = 0;\n    destination.next(this.windows[0]);\n  }\n\n  WindowCountSubscriber.prototype._next = function (value) {\n    var startWindowEvery = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize;\n    var destination = this.destination;\n    var windowSize = this.windowSize;\n    var windows = this.windows;\n    var len = windows.length;\n\n    for (var i = 0; i < len && !this.closed; i++) {\n      windows[i].next(value);\n    }\n\n    var c = this.count - windowSize + 1;\n\n    if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {\n      windows.shift().complete();\n    }\n\n    if (++this.count % startWindowEvery === 0 && !this.closed) {\n      var window_1 = new Subject_1.Subject();\n      windows.push(window_1);\n      destination.next(window_1);\n    }\n  };\n\n  WindowCountSubscriber.prototype._error = function (err) {\n    var windows = this.windows;\n\n    if (windows) {\n      while (windows.length > 0 && !this.closed) {\n        windows.shift().error(err);\n      }\n    }\n\n    this.destination.error(err);\n  };\n\n  WindowCountSubscriber.prototype._complete = function () {\n    var windows = this.windows;\n\n    if (windows) {\n      while (windows.length > 0 && !this.closed) {\n        windows.shift().complete();\n      }\n    }\n\n    this.destination.complete();\n  };\n  /** @deprecated internal use only */\n\n\n  WindowCountSubscriber.prototype._unsubscribe = function () {\n    this.count = 0;\n    this.windows = null;\n  };\n\n  return WindowCountSubscriber;\n}(Subscriber_1.Subscriber);","map":{"version":3,"sources":["../../src/operators/windowCount.ts"],"names":[],"mappings":"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","sourcesContent":["import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { OperatorFunction } from '../interfaces';\n\n/**\n * Branch out the source Observable values as a nested Observable with each\n * nested Observable emitting at most `windowSize` values.\n *\n * <span class=\"informal\">It's like {@link bufferCount}, but emits a nested\n * Observable instead of an array.</span>\n *\n * <img src=\"./img/windowCount.png\" width=\"100%\">\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows every `startWindowEvery`\n * items, each containing no more than `windowSize` items. When the source\n * Observable completes or encounters an error, the output Observable emits\n * the current window and propagates the notification from the source\n * Observable. If `startWindowEvery` is not provided, then new windows are\n * started immediately at the start of the source and when each window completes\n * with size `windowSize`.\n *\n * @example <caption>Ignore every 3rd click event, starting from the first one</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowCount(3)\n *   .map(win => win.skip(1)) // skip first of every 3 clicks\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Ignore every 3rd click event, starting from the third one</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.windowCount(2, 3)\n *   .mergeAll(); // flatten the Observable-of-Observables\n * result.subscribe(x => console.log(x));\n *\n * @see {@link window}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferCount}\n *\n * @param {number} windowSize The maximum number of values emitted by each\n * window.\n * @param {number} [startWindowEvery] Interval at which to start a new window.\n * For example if `startWindowEvery` is `2`, then a new window will be started\n * on every other value from the source. A new window is started at the\n * beginning of the source by default.\n * @return {Observable<Observable<T>>} An Observable of windows, which in turn\n * are Observable of values.\n * @method windowCount\n * @owner Observable\n */\nexport function windowCount<T>(windowSize: number,\n                               startWindowEvery: number = 0): OperatorFunction<T, Observable<T>> {\n  return function windowCountOperatorFunction(source: Observable<T>) {\n    return source.lift(new WindowCountOperator<T>(windowSize, startWindowEvery));\n  };\n}\n\nclass WindowCountOperator<T> implements Operator<T, Observable<T>> {\n\n  constructor(private windowSize: number,\n              private startWindowEvery: number) {\n  }\n\n  call(subscriber: Subscriber<Observable<T>>, source: any): any {\n    return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass WindowCountSubscriber<T> extends Subscriber<T> {\n  private windows: Subject<T>[] = [ new Subject<T>() ];\n  private count: number = 0;\n\n  constructor(protected destination: Subscriber<Observable<T>>,\n              private windowSize: number,\n              private startWindowEvery: number) {\n    super(destination);\n    destination.next(this.windows[0]);\n  }\n\n  protected _next(value: T) {\n    const startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;\n    const destination = this.destination;\n    const windowSize = this.windowSize;\n    const windows = this.windows;\n    const len = windows.length;\n\n    for (let i = 0; i < len && !this.closed; i++) {\n      windows[i].next(value);\n    }\n    const c = this.count - windowSize + 1;\n    if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {\n      windows.shift().complete();\n    }\n    if (++this.count % startWindowEvery === 0 && !this.closed) {\n      const window = new Subject<T>();\n      windows.push(window);\n      destination.next(window);\n    }\n  }\n\n  protected _error(err: any) {\n    const windows = this.windows;\n    if (windows) {\n      while (windows.length > 0 && !this.closed) {\n        windows.shift().error(err);\n      }\n    }\n    this.destination.error(err);\n  }\n\n  protected _complete() {\n    const windows = this.windows;\n    if (windows) {\n      while (windows.length > 0 && !this.closed) {\n        windows.shift().complete();\n      }\n    }\n    this.destination.complete();\n  }\n\n  /** @deprecated internal use only */ _unsubscribe() {\n    this.count = 0;\n    this.windows = null;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}