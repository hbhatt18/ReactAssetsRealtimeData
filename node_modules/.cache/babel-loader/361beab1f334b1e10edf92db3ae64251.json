{"ast":null,"code":"\"use strict\";\n\nvar isArray_1 = require('../util/isArray');\n\nvar race_1 = require('../observable/race');\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that mirrors the first source Observable to emit an item\n * from the combination of this Observable and supplied Observables.\n * @param {...Observables} ...observables Sources used to race for which Observable emits first.\n * @return {Observable} An Observable that mirrors the output of the first Observable to emit an item.\n * @method race\n * @owner Observable\n */\n\n\nfunction race() {\n  var observables = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    observables[_i - 0] = arguments[_i];\n  }\n\n  return function raceOperatorFunction(source) {\n    // if the only argument is an array, it was most likely called with\n    // `pair([obs1, obs2, ...])`\n    if (observables.length === 1 && isArray_1.isArray(observables[0])) {\n      observables = observables[0];\n    }\n\n    return source.lift.call(race_1.race.apply(void 0, [source].concat(observables)));\n  };\n}\n\nexports.race = race;","map":{"version":3,"sources":["../../src/operators/race.ts"],"names":[],"mappings":";;AACA,IAAA,SAAA,GAAA,OAAA,CAAwB,iBAAxB,CAAA;;AAEA,IAAA,MAAA,GAAA,OAAA,CAAmC,oBAAnC,CAAA;AAOA;;AAEA;;;;;;;;;;AAQA,SAAA,IAAA,GAAA;AAAwB,MAAA,WAAA,GAAA,EAAA;;OAAA,IAAA,EAAA,GAAA,C,EAAA,EAAA,GAAA,SAAA,CAAA,M,EAAA,EAAA,E,EAA2D;AAA3D,IAAA,WAAA,CAAA,EAAA,GAAA,CAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;;AACtB,SAAO,SAAA,oBAAA,CAA8B,MAA9B,EAAmD;AACxD;AACA;AACA,QAAI,WAAW,CAAC,MAAZ,KAAuB,CAAvB,IAA4B,SAAA,CAAA,OAAA,CAAQ,WAAW,CAAC,CAAD,CAAnB,CAAhC,EAAyD;AACvD,MAAA,WAAW,GAAyB,WAAW,CAAC,CAAD,CAA/C;AACD;;AAED,WAAO,MAAM,CAAC,IAAP,CAAY,IAAZ,CAAiB,MAAA,CAAA,IAAA,CAAU,KAAV,CAAU,KAAA,CAAV,EAAU,CAAI,MAAJ,EAAU,MAAV,CAAe,WAAf,CAAV,CAAjB,CAAP;AACD,GARD;AASD;;AAVe,OAAA,CAAA,IAAA,GAAI,IAAJ","sourcesContent":["import { Observable } from '../Observable';\nimport { isArray } from '../util/isArray';\nimport { MonoTypeOperatorFunction, OperatorFunction } from '../interfaces';\nimport { race as raceStatic } from '../observable/race';\n\n/* tslint:disable:max-line-length */\nexport function race<T>(observables: Array<Observable<T>>): MonoTypeOperatorFunction<T>;\nexport function race<T, R>(observables: Array<Observable<T>>): OperatorFunction<T, R>;\nexport function race<T>(...observables: Array<Observable<T> | Array<Observable<T>>>): MonoTypeOperatorFunction<T>;\nexport function race<T, R>(...observables: Array<Observable<any> | Array<Observable<any>>>): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that mirrors the first source Observable to emit an item\n * from the combination of this Observable and supplied Observables.\n * @param {...Observables} ...observables Sources used to race for which Observable emits first.\n * @return {Observable} An Observable that mirrors the output of the first Observable to emit an item.\n * @method race\n * @owner Observable\n */\nexport function race<T>(...observables: Array<Observable<T> | Array<Observable<T>>>): MonoTypeOperatorFunction<T> {\n  return function raceOperatorFunction(source: Observable<T>) {\n    // if the only argument is an array, it was most likely called with\n    // `pair([obs1, obs2, ...])`\n    if (observables.length === 1 && isArray(observables[0])) {\n      observables = <Array<Observable<T>>>observables[0];\n    }\n\n    return source.lift.call(raceStatic<T>(source, ...observables));\n  };\n}"],"sourceRoot":""},"metadata":{},"sourceType":"script"}