{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = require('../Subscriber');\n\nvar async_1 = require('../scheduler/async');\n\nfunction timeInterval(scheduler) {\n  if (scheduler === void 0) {\n    scheduler = async_1.async;\n  }\n\n  return function (source) {\n    return source.lift(new TimeIntervalOperator(scheduler));\n  };\n}\n\nexports.timeInterval = timeInterval;\n\nvar TimeInterval = function () {\n  function TimeInterval(value, interval) {\n    this.value = value;\n    this.interval = interval;\n  }\n\n  return TimeInterval;\n}();\n\nexports.TimeInterval = TimeInterval;\n;\n\nvar TimeIntervalOperator = function () {\n  function TimeIntervalOperator(scheduler) {\n    this.scheduler = scheduler;\n  }\n\n  TimeIntervalOperator.prototype.call = function (observer, source) {\n    return source.subscribe(new TimeIntervalSubscriber(observer, this.scheduler));\n  };\n\n  return TimeIntervalOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar TimeIntervalSubscriber = function (_super) {\n  __extends(TimeIntervalSubscriber, _super);\n\n  function TimeIntervalSubscriber(destination, scheduler) {\n    _super.call(this, destination);\n\n    this.scheduler = scheduler;\n    this.lastTime = 0;\n    this.lastTime = scheduler.now();\n  }\n\n  TimeIntervalSubscriber.prototype._next = function (value) {\n    var now = this.scheduler.now();\n    var span = now - this.lastTime;\n    this.lastTime = now;\n    this.destination.next(new TimeInterval(value, span));\n  };\n\n  return TimeIntervalSubscriber;\n}(Subscriber_1.Subscriber);","map":{"version":3,"sources":["../../src/operators/timeInterval.ts"],"names":[],"mappings":";;;;;;;;;;;;AAEA,IAAA,YAAA,GAAA,OAAA,CAA2B,eAA3B,CAAA;;AAEA,IAAA,OAAA,GAAA,OAAA,CAAsB,oBAAtB,CAAA;;AAGA,SAAA,YAAA,CAAgC,SAAhC,EAA6D;AAA7B,MAAA,SAAA,KAAA,KAAA,CAAA,EAA6B;AAA7B,IAAA,SAAA,GAAA,OAAA,CAAA,KAAA;AAA6B;;AAC3D,SAAO,UAAC,MAAD,EAAsB;AAAK,WAAA,MAAM,CAAC,IAAP,CAAY,IAAI,oBAAJ,CAAZ,SAAY,CAAZ,CAAA;AAAgD,GAAlF;AACD;;AAFe,OAAA,CAAA,YAAA,GAAY,YAAZ;;AAIhB,IAAA,YAAA,GAAA,YAAA;AACE,WAAA,YAAA,CAAmB,KAAnB,EAAoC,QAApC,EAAoD;AAAjC,SAAA,KAAA,GAAA,KAAA;AAAiB,SAAA,QAAA,GAAA,QAAA;AAEnC;;AACH,SAAA,YAAA;AAAC,CAJD,EAAA;;AAAa,OAAA,CAAA,YAAA,GAAY,YAAZ;AAIZ;;AAED,IAAA,oBAAA,GAAA,YAAA;AACE,WAAA,oBAAA,CAAoB,SAApB,EAAyC;AAArB,SAAA,SAAA,GAAA,SAAA;AAEnB;;AAED,EAAA,oBAAA,CAAA,SAAA,CAAA,IAAA,GAAA,UAAK,QAAL,EAA4C,MAA5C,EAAuD;AACrD,WAAO,MAAM,CAAC,SAAP,CAAiB,IAAI,sBAAJ,CAA2B,QAA3B,EAAqC,KAAK,SAA1C,CAAjB,CAAP;AACD,GAFD;;AAGF,SAAA,oBAAA;AAAC,CARD,EAAA;AAUA;;;;;;;AAKA,IAAA,sBAAA,GAAA,UAAA,MAAA,EAAA;AAAwC,EAAA,SAAA,CAAA,sBAAA,EAAA,MAAA,CAAA;;AAGtC,WAAA,sBAAA,CAAY,WAAZ,EAA8D,SAA9D,EAAmF;AACjF,IAAA,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,WAAN;;AAD4D,SAAA,SAAA,GAAA,SAAA;AAFtD,SAAA,QAAA,GAAmB,CAAnB;AAKN,SAAK,QAAL,GAAgB,SAAS,CAAC,GAAV,EAAhB;AACD;;AAES,EAAA,sBAAA,CAAA,SAAA,CAAA,KAAA,GAAV,UAAgB,KAAhB,EAAwB;AACtB,QAAI,GAAG,GAAG,KAAK,SAAL,CAAe,GAAf,EAAV;AACA,QAAI,IAAI,GAAG,GAAG,GAAG,KAAK,QAAtB;AACA,SAAK,QAAL,GAAgB,GAAhB;AAEA,SAAK,WAAL,CAAiB,IAAjB,CAAsB,IAAI,YAAJ,CAAiB,KAAjB,EAAwB,IAAxB,CAAtB;AACD,GANS;;AAOZ,SAAA,sBAAA;AAAC,CAhBD,CAAwC,YAAA,CAAA,UAAxC,CAAA","sourcesContent":["import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { IScheduler } from '../Scheduler';\nimport { async } from '../scheduler/async';\nimport { OperatorFunction } from '../interfaces';\n\nexport function timeInterval<T>(scheduler: IScheduler = async): OperatorFunction<T, TimeInterval<T>> {\n  return (source: Observable<T>) => source.lift(new TimeIntervalOperator(scheduler));\n}\n\nexport class TimeInterval<T> {\n  constructor(public value: T, public interval: number) {\n\n  }\n};\n\nclass TimeIntervalOperator<T> implements Operator<T, TimeInterval<T>> {\n  constructor(private scheduler: IScheduler) {\n\n  }\n\n  call(observer: Subscriber<TimeInterval<T>>, source: any): any {\n    return source.subscribe(new TimeIntervalSubscriber(observer, this.scheduler));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass TimeIntervalSubscriber<T> extends Subscriber<T> {\n  private lastTime: number = 0;\n\n  constructor(destination: Subscriber<TimeInterval<T>>, private scheduler: IScheduler) {\n    super(destination);\n\n    this.lastTime = scheduler.now();\n  }\n\n  protected _next(value: T) {\n    let now = this.scheduler.now();\n    let span = now - this.lastTime;\n    this.lastTime = now;\n\n    this.destination.next(new TimeInterval(value, span));\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}