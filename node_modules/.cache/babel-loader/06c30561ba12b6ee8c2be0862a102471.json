{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subject_1 = require('./Subject');\n\nvar queue_1 = require('./scheduler/queue');\n\nvar Subscription_1 = require('./Subscription');\n\nvar observeOn_1 = require('./operators/observeOn');\n\nvar ObjectUnsubscribedError_1 = require('./util/ObjectUnsubscribedError');\n\nvar SubjectSubscription_1 = require('./SubjectSubscription');\n/**\n * @class ReplaySubject<T>\n */\n\n\nvar ReplaySubject = function (_super) {\n  __extends(ReplaySubject, _super);\n\n  function ReplaySubject(bufferSize, windowTime, scheduler) {\n    if (bufferSize === void 0) {\n      bufferSize = Number.POSITIVE_INFINITY;\n    }\n\n    if (windowTime === void 0) {\n      windowTime = Number.POSITIVE_INFINITY;\n    }\n\n    _super.call(this);\n\n    this.scheduler = scheduler;\n    this._events = [];\n    this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n    this._windowTime = windowTime < 1 ? 1 : windowTime;\n  }\n\n  ReplaySubject.prototype.next = function (value) {\n    var now = this._getNow();\n\n    this._events.push(new ReplayEvent(now, value));\n\n    this._trimBufferThenGetEvents();\n\n    _super.prototype.next.call(this, value);\n  };\n  /** @deprecated internal use only */\n\n\n  ReplaySubject.prototype._subscribe = function (subscriber) {\n    var _events = this._trimBufferThenGetEvents();\n\n    var scheduler = this.scheduler;\n    var subscription;\n\n    if (this.closed) {\n      throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n    } else if (this.hasError) {\n      subscription = Subscription_1.Subscription.EMPTY;\n    } else if (this.isStopped) {\n      subscription = Subscription_1.Subscription.EMPTY;\n    } else {\n      this.observers.push(subscriber);\n      subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);\n    }\n\n    if (scheduler) {\n      subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));\n    }\n\n    var len = _events.length;\n\n    for (var i = 0; i < len && !subscriber.closed; i++) {\n      subscriber.next(_events[i].value);\n    }\n\n    if (this.hasError) {\n      subscriber.error(this.thrownError);\n    } else if (this.isStopped) {\n      subscriber.complete();\n    }\n\n    return subscription;\n  };\n\n  ReplaySubject.prototype._getNow = function () {\n    return (this.scheduler || queue_1.queue).now();\n  };\n\n  ReplaySubject.prototype._trimBufferThenGetEvents = function () {\n    var now = this._getNow();\n\n    var _bufferSize = this._bufferSize;\n    var _windowTime = this._windowTime;\n    var _events = this._events;\n    var eventsCount = _events.length;\n    var spliceCount = 0; // Trim events that fall out of the time window.\n    // Start at the front of the list. Break early once\n    // we encounter an event that falls within the window.\n\n    while (spliceCount < eventsCount) {\n      if (now - _events[spliceCount].time < _windowTime) {\n        break;\n      }\n\n      spliceCount++;\n    }\n\n    if (eventsCount > _bufferSize) {\n      spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n    }\n\n    if (spliceCount > 0) {\n      _events.splice(0, spliceCount);\n    }\n\n    return _events;\n  };\n\n  return ReplaySubject;\n}(Subject_1.Subject);\n\nexports.ReplaySubject = ReplaySubject;\n\nvar ReplayEvent = function () {\n  function ReplayEvent(time, value) {\n    this.time = time;\n    this.value = value;\n  }\n\n  return ReplayEvent;\n}();","map":{"version":3,"sources":["../src/ReplaySubject.ts"],"names":[],"mappings":"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","sourcesContent":["import { Subject } from './Subject';\nimport { IScheduler } from './Scheduler';\nimport { queue } from './scheduler/queue';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { ObserveOnSubscriber } from './operators/observeOn';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\n/**\n * @class ReplaySubject<T>\n */\nexport class ReplaySubject<T> extends Subject<T> {\n  private _events: ReplayEvent<T>[] = [];\n  private _bufferSize: number;\n  private _windowTime: number;\n\n  constructor(bufferSize: number = Number.POSITIVE_INFINITY,\n              windowTime: number = Number.POSITIVE_INFINITY,\n              private scheduler?: IScheduler) {\n    super();\n    this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n    this._windowTime = windowTime < 1 ? 1 : windowTime;\n  }\n\n  next(value: T): void {\n    const now = this._getNow();\n    this._events.push(new ReplayEvent(now, value));\n    this._trimBufferThenGetEvents();\n    super.next(value);\n  }\n\n  /** @deprecated internal use only */ _subscribe(subscriber: Subscriber<T>): Subscription {\n    const _events = this._trimBufferThenGetEvents();\n    const scheduler = this.scheduler;\n    let subscription: Subscription;\n\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else if (this.hasError) {\n      subscription = Subscription.EMPTY;\n    } else if (this.isStopped) {\n      subscription = Subscription.EMPTY;\n    } else {\n      this.observers.push(subscriber);\n      subscription = new SubjectSubscription(this, subscriber);\n    }\n\n    if (scheduler) {\n      subscriber.add(subscriber = new ObserveOnSubscriber<T>(subscriber, scheduler));\n    }\n\n    const len = _events.length;\n    for (let i = 0; i < len && !subscriber.closed; i++) {\n      subscriber.next(_events[i].value);\n    }\n\n    if (this.hasError) {\n      subscriber.error(this.thrownError);\n    } else if (this.isStopped) {\n      subscriber.complete();\n    }\n\n    return subscription;\n  }\n\n  _getNow(): number {\n    return (this.scheduler || queue).now();\n  }\n\n  private _trimBufferThenGetEvents(): ReplayEvent<T>[] {\n    const now = this._getNow();\n    const _bufferSize = this._bufferSize;\n    const _windowTime = this._windowTime;\n    const _events = this._events;\n\n    let eventsCount = _events.length;\n    let spliceCount = 0;\n\n    // Trim events that fall out of the time window.\n    // Start at the front of the list. Break early once\n    // we encounter an event that falls within the window.\n    while (spliceCount < eventsCount) {\n      if ((now - _events[spliceCount].time) < _windowTime) {\n        break;\n      }\n      spliceCount++;\n    }\n\n    if (eventsCount > _bufferSize) {\n      spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n    }\n\n    if (spliceCount > 0) {\n      _events.splice(0, spliceCount);\n    }\n\n    return _events;\n  }\n}\n\nclass ReplayEvent<T> {\n  constructor(public time: number, public value: T) {\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}