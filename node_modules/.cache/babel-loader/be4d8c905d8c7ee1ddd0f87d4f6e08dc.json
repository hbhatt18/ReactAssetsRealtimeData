{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subject_1 = require('../../Subject');\n\nvar Subscriber_1 = require('../../Subscriber');\n\nvar Observable_1 = require('../../Observable');\n\nvar Subscription_1 = require('../../Subscription');\n\nvar root_1 = require('../../util/root');\n\nvar ReplaySubject_1 = require('../../ReplaySubject');\n\nvar tryCatch_1 = require('../../util/tryCatch');\n\nvar errorObject_1 = require('../../util/errorObject');\n\nvar assign_1 = require('../../util/assign');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar WebSocketSubject = function (_super) {\n  __extends(WebSocketSubject, _super);\n\n  function WebSocketSubject(urlConfigOrSource, destination) {\n    if (urlConfigOrSource instanceof Observable_1.Observable) {\n      _super.call(this, destination, urlConfigOrSource);\n    } else {\n      _super.call(this);\n\n      this.WebSocketCtor = root_1.root.WebSocket;\n      this._output = new Subject_1.Subject();\n\n      if (typeof urlConfigOrSource === 'string') {\n        this.url = urlConfigOrSource;\n      } else {\n        // WARNING: config object could override important members here.\n        assign_1.assign(this, urlConfigOrSource);\n      }\n\n      if (!this.WebSocketCtor) {\n        throw new Error('no WebSocket constructor can be found');\n      }\n\n      this.destination = new ReplaySubject_1.ReplaySubject();\n    }\n  }\n\n  WebSocketSubject.prototype.resultSelector = function (e) {\n    return JSON.parse(e.data);\n  };\n  /**\n   * Wrapper around the w3c-compatible WebSocket object provided by the browser.\n   *\n   * @example <caption>Wraps browser WebSocket</caption>\n   *\n   * let socket$ = Observable.webSocket('ws://localhost:8081');\n   *\n   * socket$.subscribe(\n   *    (msg) => console.log('message received: ' + msg),\n   *    (err) => console.log(err),\n   *    () => console.log('complete')\n   *  );\n   *\n   * socket$.next(JSON.stringify({ op: 'hello' }));\n   *\n   * @example <caption>Wraps WebSocket from nodejs-websocket (using node.js)</caption>\n   *\n   * import { w3cwebsocket } from 'websocket';\n   *\n   * let socket$ = Observable.webSocket({\n   *   url: 'ws://localhost:8081',\n   *   WebSocketCtor: w3cwebsocket\n   * });\n   *\n   * socket$.subscribe(\n   *    (msg) => console.log('message received: ' + msg),\n   *    (err) => console.log(err),\n   *    () => console.log('complete')\n   *  );\n   *\n   * socket$.next(JSON.stringify({ op: 'hello' }));\n   *\n   * @param {string | WebSocketSubjectConfig} urlConfigOrSource the source of the websocket as an url or a structure defining the websocket object\n   * @return {WebSocketSubject}\n   * @static true\n   * @name webSocket\n   * @owner Observable\n   */\n\n\n  WebSocketSubject.create = function (urlConfigOrSource) {\n    return new WebSocketSubject(urlConfigOrSource);\n  };\n\n  WebSocketSubject.prototype.lift = function (operator) {\n    var sock = new WebSocketSubject(this, this.destination);\n    sock.operator = operator;\n    return sock;\n  };\n\n  WebSocketSubject.prototype._resetState = function () {\n    this.socket = null;\n\n    if (!this.source) {\n      this.destination = new ReplaySubject_1.ReplaySubject();\n    }\n\n    this._output = new Subject_1.Subject();\n  }; // TODO: factor this out to be a proper Operator/Subscriber implementation and eliminate closures\n\n\n  WebSocketSubject.prototype.multiplex = function (subMsg, unsubMsg, messageFilter) {\n    var self = this;\n    return new Observable_1.Observable(function (observer) {\n      var result = tryCatch_1.tryCatch(subMsg)();\n\n      if (result === errorObject_1.errorObject) {\n        observer.error(errorObject_1.errorObject.e);\n      } else {\n        self.next(result);\n      }\n\n      var subscription = self.subscribe(function (x) {\n        var result = tryCatch_1.tryCatch(messageFilter)(x);\n\n        if (result === errorObject_1.errorObject) {\n          observer.error(errorObject_1.errorObject.e);\n        } else if (result) {\n          observer.next(x);\n        }\n      }, function (err) {\n        return observer.error(err);\n      }, function () {\n        return observer.complete();\n      });\n      return function () {\n        var result = tryCatch_1.tryCatch(unsubMsg)();\n\n        if (result === errorObject_1.errorObject) {\n          observer.error(errorObject_1.errorObject.e);\n        } else {\n          self.next(result);\n        }\n\n        subscription.unsubscribe();\n      };\n    });\n  };\n\n  WebSocketSubject.prototype._connectSocket = function () {\n    var _this = this;\n\n    var WebSocketCtor = this.WebSocketCtor;\n    var observer = this._output;\n    var socket = null;\n\n    try {\n      socket = this.protocol ? new WebSocketCtor(this.url, this.protocol) : new WebSocketCtor(this.url);\n      this.socket = socket;\n\n      if (this.binaryType) {\n        this.socket.binaryType = this.binaryType;\n      }\n    } catch (e) {\n      observer.error(e);\n      return;\n    }\n\n    var subscription = new Subscription_1.Subscription(function () {\n      _this.socket = null;\n\n      if (socket && socket.readyState === 1) {\n        socket.close();\n      }\n    });\n\n    socket.onopen = function (e) {\n      var openObserver = _this.openObserver;\n\n      if (openObserver) {\n        openObserver.next(e);\n      }\n\n      var queue = _this.destination;\n      _this.destination = Subscriber_1.Subscriber.create(function (x) {\n        return socket.readyState === 1 && socket.send(x);\n      }, function (e) {\n        var closingObserver = _this.closingObserver;\n\n        if (closingObserver) {\n          closingObserver.next(undefined);\n        }\n\n        if (e && e.code) {\n          socket.close(e.code, e.reason);\n        } else {\n          observer.error(new TypeError('WebSocketSubject.error must be called with an object with an error code, ' + 'and an optional reason: { code: number, reason: string }'));\n        }\n\n        _this._resetState();\n      }, function () {\n        var closingObserver = _this.closingObserver;\n\n        if (closingObserver) {\n          closingObserver.next(undefined);\n        }\n\n        socket.close();\n\n        _this._resetState();\n      });\n\n      if (queue && queue instanceof ReplaySubject_1.ReplaySubject) {\n        subscription.add(queue.subscribe(_this.destination));\n      }\n    };\n\n    socket.onerror = function (e) {\n      _this._resetState();\n\n      observer.error(e);\n    };\n\n    socket.onclose = function (e) {\n      _this._resetState();\n\n      var closeObserver = _this.closeObserver;\n\n      if (closeObserver) {\n        closeObserver.next(e);\n      }\n\n      if (e.wasClean) {\n        observer.complete();\n      } else {\n        observer.error(e);\n      }\n    };\n\n    socket.onmessage = function (e) {\n      var result = tryCatch_1.tryCatch(_this.resultSelector)(e);\n\n      if (result === errorObject_1.errorObject) {\n        observer.error(errorObject_1.errorObject.e);\n      } else {\n        observer.next(result);\n      }\n    };\n  };\n  /** @deprecated internal use only */\n\n\n  WebSocketSubject.prototype._subscribe = function (subscriber) {\n    var _this = this;\n\n    var source = this.source;\n\n    if (source) {\n      return source.subscribe(subscriber);\n    }\n\n    if (!this.socket) {\n      this._connectSocket();\n    }\n\n    var subscription = new Subscription_1.Subscription();\n    subscription.add(this._output.subscribe(subscriber));\n    subscription.add(function () {\n      var socket = _this.socket;\n\n      if (_this._output.observers.length === 0) {\n        if (socket && socket.readyState === 1) {\n          socket.close();\n        }\n\n        _this._resetState();\n      }\n    });\n    return subscription;\n  };\n\n  WebSocketSubject.prototype.unsubscribe = function () {\n    var _a = this,\n        source = _a.source,\n        socket = _a.socket;\n\n    if (socket && socket.readyState === 1) {\n      socket.close();\n\n      this._resetState();\n    }\n\n    _super.prototype.unsubscribe.call(this);\n\n    if (!source) {\n      this.destination = new ReplaySubject_1.ReplaySubject();\n    }\n  };\n\n  return WebSocketSubject;\n}(Subject_1.AnonymousSubject);\n\nexports.WebSocketSubject = WebSocketSubject;","map":{"version":3,"sources":["../../../src/observable/dom/WebSocketSubject.ts"],"names":[],"mappings":"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","sourcesContent":["import { Subject, AnonymousSubject } from '../../Subject';\nimport { Subscriber } from '../../Subscriber';\nimport { Observable } from '../../Observable';\nimport { Subscription } from '../../Subscription';\nimport { Operator } from '../../Operator';\nimport { root } from '../../util/root';\nimport { ReplaySubject } from '../../ReplaySubject';\nimport { Observer, NextObserver } from '../../Observer';\nimport { tryCatch } from '../../util/tryCatch';\nimport { errorObject } from '../../util/errorObject';\nimport { assign } from '../../util/assign';\n\nexport interface WebSocketSubjectConfig {\n  url: string;\n  protocol?: string | Array<string>;\n  resultSelector?: <T>(e: MessageEvent) => T;\n  openObserver?: NextObserver<Event>;\n  closeObserver?: NextObserver<CloseEvent>;\n  closingObserver?: NextObserver<void>;\n  WebSocketCtor?: { new(url: string, protocol?: string|Array<string>): WebSocket };\n  binaryType?: 'blob' | 'arraybuffer';\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class WebSocketSubject<T> extends AnonymousSubject<T> {\n\n  url: string;\n  protocol: string|Array<string>;\n  socket: WebSocket;\n  openObserver: NextObserver<Event>;\n  closeObserver: NextObserver<CloseEvent>;\n  closingObserver: NextObserver<void>;\n  WebSocketCtor: { new(url: string, protocol?: string|Array<string>): WebSocket };\n  binaryType?: 'blob' | 'arraybuffer';\n\n  private _output: Subject<T>;\n\n  resultSelector(e: MessageEvent) {\n    return JSON.parse(e.data);\n  }\n\n  /**\n   * Wrapper around the w3c-compatible WebSocket object provided by the browser.\n   *\n   * @example <caption>Wraps browser WebSocket</caption>\n   *\n   * let socket$ = Observable.webSocket('ws://localhost:8081');\n   *\n   * socket$.subscribe(\n   *    (msg) => console.log('message received: ' + msg),\n   *    (err) => console.log(err),\n   *    () => console.log('complete')\n   *  );\n   *\n   * socket$.next(JSON.stringify({ op: 'hello' }));\n   *\n   * @example <caption>Wraps WebSocket from nodejs-websocket (using node.js)</caption>\n   *\n   * import { w3cwebsocket } from 'websocket';\n   *\n   * let socket$ = Observable.webSocket({\n   *   url: 'ws://localhost:8081',\n   *   WebSocketCtor: w3cwebsocket\n   * });\n   *\n   * socket$.subscribe(\n   *    (msg) => console.log('message received: ' + msg),\n   *    (err) => console.log(err),\n   *    () => console.log('complete')\n   *  );\n   *\n   * socket$.next(JSON.stringify({ op: 'hello' }));\n   *\n   * @param {string | WebSocketSubjectConfig} urlConfigOrSource the source of the websocket as an url or a structure defining the websocket object\n   * @return {WebSocketSubject}\n   * @static true\n   * @name webSocket\n   * @owner Observable\n   */\n  static create<T>(urlConfigOrSource: string | WebSocketSubjectConfig): WebSocketSubject<T> {\n    return new WebSocketSubject<T>(urlConfigOrSource);\n  }\n\n  constructor(urlConfigOrSource: string | WebSocketSubjectConfig | Observable<T>, destination?: Observer<T>) {\n    if (urlConfigOrSource instanceof Observable) {\n      super(destination, <Observable<T>> urlConfigOrSource);\n    } else {\n      super();\n      this.WebSocketCtor = root.WebSocket;\n      this._output = new Subject<T>();\n      if (typeof urlConfigOrSource === 'string') {\n        this.url = urlConfigOrSource;\n      } else {\n        // WARNING: config object could override important members here.\n        assign(this, urlConfigOrSource);\n      }\n      if (!this.WebSocketCtor) {\n        throw new Error('no WebSocket constructor can be found');\n      }\n      this.destination = new ReplaySubject();\n    }\n  }\n\n  lift<R>(operator: Operator<T, R>): WebSocketSubject<R> {\n    const sock = new WebSocketSubject<R>(this, <any> this.destination);\n    sock.operator = operator;\n    return sock;\n  }\n\n  private _resetState() {\n    this.socket = null;\n    if (!this.source) {\n      this.destination = new ReplaySubject();\n    }\n    this._output = new Subject<T>();\n  }\n\n  // TODO: factor this out to be a proper Operator/Subscriber implementation and eliminate closures\n  multiplex(subMsg: () => any, unsubMsg: () => any, messageFilter: (value: T) => boolean) {\n    const self = this;\n    return new Observable((observer: Observer<any>) => {\n      const result = tryCatch(subMsg)();\n      if (result === errorObject) {\n        observer.error(errorObject.e);\n      } else {\n        self.next(result);\n      }\n\n      let subscription = self.subscribe(x => {\n        const result = tryCatch(messageFilter)(x);\n        if (result === errorObject) {\n          observer.error(errorObject.e);\n        } else if (result) {\n          observer.next(x);\n        }\n      },\n        err => observer.error(err),\n        () => observer.complete());\n\n      return () => {\n        const result = tryCatch(unsubMsg)();\n        if (result === errorObject) {\n          observer.error(errorObject.e);\n        } else {\n          self.next(result);\n        }\n        subscription.unsubscribe();\n      };\n    });\n  }\n\n  private _connectSocket() {\n    const { WebSocketCtor } = this;\n    const observer = this._output;\n\n    let socket: WebSocket = null;\n    try {\n      socket = this.protocol ?\n        new WebSocketCtor(this.url, this.protocol) :\n        new WebSocketCtor(this.url);\n      this.socket = socket;\n      if (this.binaryType) {\n        this.socket.binaryType = this.binaryType;\n      }\n    } catch (e) {\n      observer.error(e);\n      return;\n    }\n\n    const subscription = new Subscription(() => {\n      this.socket = null;\n      if (socket && socket.readyState === 1) {\n        socket.close();\n      }\n    });\n\n    socket.onopen = (e: Event) => {\n      const openObserver = this.openObserver;\n      if (openObserver) {\n        openObserver.next(e);\n      }\n\n      const queue = this.destination;\n\n      this.destination = Subscriber.create(\n        (x) => socket.readyState === 1 && socket.send(x),\n        (e) => {\n          const closingObserver = this.closingObserver;\n          if (closingObserver) {\n            closingObserver.next(undefined);\n          }\n          if (e && e.code) {\n            socket.close(e.code, e.reason);\n          } else {\n            observer.error(new TypeError('WebSocketSubject.error must be called with an object with an error code, ' +\n              'and an optional reason: { code: number, reason: string }'));\n          }\n          this._resetState();\n        },\n        ( ) => {\n          const closingObserver = this.closingObserver;\n          if (closingObserver) {\n            closingObserver.next(undefined);\n          }\n          socket.close();\n          this._resetState();\n        }\n      );\n\n      if (queue && queue instanceof ReplaySubject) {\n        subscription.add((<ReplaySubject<T>>queue).subscribe(this.destination));\n      }\n    };\n\n    socket.onerror = (e: Event) => {\n      this._resetState();\n      observer.error(e);\n    };\n\n    socket.onclose = (e: CloseEvent) => {\n      this._resetState();\n      const closeObserver = this.closeObserver;\n      if (closeObserver) {\n        closeObserver.next(e);\n      }\n      if (e.wasClean) {\n        observer.complete();\n      } else {\n        observer.error(e);\n      }\n    };\n\n    socket.onmessage = (e: MessageEvent) => {\n      const result = tryCatch(this.resultSelector)(e);\n      if (result === errorObject) {\n        observer.error(errorObject.e);\n      } else {\n        observer.next(result);\n      }\n    };\n  }\n\n  /** @deprecated internal use only */ _subscribe(subscriber: Subscriber<T>): Subscription {\n    const { source } = this;\n    if (source) {\n      return source.subscribe(subscriber);\n    }\n    if (!this.socket) {\n      this._connectSocket();\n    }\n    let subscription = new Subscription();\n    subscription.add(this._output.subscribe(subscriber));\n    subscription.add(() => {\n      const { socket } = this;\n      if (this._output.observers.length === 0) {\n        if (socket && socket.readyState === 1) {\n          socket.close();\n        }\n        this._resetState();\n      }\n    });\n    return subscription;\n  }\n\n  unsubscribe() {\n    const { source, socket } = this;\n    if (socket && socket.readyState === 1) {\n      socket.close();\n      this._resetState();\n    }\n    super.unsubscribe();\n    if (!source) {\n      this.destination = new ReplaySubject();\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}