{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Observable_1 = require('../Observable');\n\nvar tryCatch_1 = require('../util/tryCatch');\n\nvar errorObject_1 = require('../util/errorObject');\n\nvar AsyncSubject_1 = require('../AsyncSubject');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar BoundNodeCallbackObservable = function (_super) {\n  __extends(BoundNodeCallbackObservable, _super);\n\n  function BoundNodeCallbackObservable(callbackFunc, selector, args, context, scheduler) {\n    _super.call(this);\n\n    this.callbackFunc = callbackFunc;\n    this.selector = selector;\n    this.args = args;\n    this.context = context;\n    this.scheduler = scheduler;\n  }\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Converts a Node.js-style callback API to a function that returns an\n   * Observable.\n   *\n   * <span class=\"informal\">It's just like {@link bindCallback}, but the\n   * callback is expected to be of type `callback(error, result)`.</span>\n   *\n   * `bindNodeCallback` is not an operator because its input and output are not\n   * Observables. The input is a function `func` with some parameters, but the\n   * last parameter must be a callback function that `func` calls when it is\n   * done. The callback function is expected to follow Node.js conventions,\n   * where the first argument to the callback is an error object, signaling\n   * whether call was successful. If that object is passed to callback, it means\n   * something went wrong.\n   *\n   * The output of `bindNodeCallback` is a function that takes the same\n   * parameters as `func`, except the last one (the callback). When the output\n   * function is called with arguments, it will return an Observable.\n   * If `func` calls its callback with error parameter present, Observable will\n   * error with that value as well. If error parameter is not passed, Observable will emit\n   * second parameter. If there are more parameters (third and so on),\n   * Observable will emit an array with all arguments, except first error argument.\n   *\n   * Optionally `bindNodeCallback` accepts selector function, which allows you to\n   * make resulting Observable emit value computed by selector, instead of regular\n   * callback arguments. It works similarly to {@link bindCallback} selector, but\n   * Node.js-style error argument will never be passed to that function.\n   *\n   * Note that `func` will not be called at the same time output function is,\n   * but rather whenever resulting Observable is subscribed. By default call to\n   * `func` will happen synchronously after subscription, but that can be changed\n   * with proper {@link Scheduler} provided as optional third parameter. Scheduler\n   * can also control when values from callback will be emitted by Observable.\n   * To find out more, check out documentation for {@link bindCallback}, where\n   * Scheduler works exactly the same.\n   *\n   * As in {@link bindCallback}, context (`this` property) of input function will be set to context\n   * of returned function, when it is called.\n   *\n   * After Observable emits value, it will complete immediately. This means\n   * even if `func` calls callback again, values from second and consecutive\n   * calls will never appear on the stream. If you need to handle functions\n   * that call callbacks multiple times, check out {@link fromEvent} or\n   * {@link fromEventPattern} instead.\n   *\n   * Note that `bindNodeCallback` can be used in non-Node.js environments as well.\n   * \"Node.js-style\" callbacks are just a convention, so if you write for\n   * browsers or any other environment and API you use implements that callback style,\n   * `bindNodeCallback` can be safely used on that API functions as well.\n   *\n   * Remember that Error object passed to callback does not have to be an instance\n   * of JavaScript built-in `Error` object. In fact, it does not even have to an object.\n   * Error parameter of callback function is interpreted as \"present\", when value\n   * of that parameter is truthy. It could be, for example, non-zero number, non-empty\n   * string or boolean `true`. In all of these cases resulting Observable would error\n   * with that value. This means usually regular style callbacks will fail very often when\n   * `bindNodeCallback` is used. If your Observable errors much more often then you\n   * would expect, check if callback really is called in Node.js-style and, if not,\n   * switch to {@link bindCallback} instead.\n   *\n   * Note that even if error parameter is technically present in callback, but its value\n   * is falsy, it still won't appear in array emitted by Observable or in selector function.\n   *\n   *\n   * @example <caption>Read a file from the filesystem and get the data as an Observable</caption>\n   * import * as fs from 'fs';\n   * var readFileAsObservable = Rx.Observable.bindNodeCallback(fs.readFile);\n   * var result = readFileAsObservable('./roadNames.txt', 'utf8');\n   * result.subscribe(x => console.log(x), e => console.error(e));\n   *\n   *\n   * @example <caption>Use on function calling callback with multiple arguments</caption>\n   * someFunction((err, a, b) => {\n   *   console.log(err); // null\n   *   console.log(a); // 5\n   *   console.log(b); // \"some string\"\n   * });\n   * var boundSomeFunction = Rx.Observable.bindNodeCallback(someFunction);\n   * boundSomeFunction()\n   * .subscribe(value => {\n   *   console.log(value); // [5, \"some string\"]\n   * });\n   *\n   *\n   * @example <caption>Use with selector function</caption>\n   * someFunction((err, a, b) => {\n   *   console.log(err); // undefined\n   *   console.log(a); // \"abc\"\n   *   console.log(b); // \"DEF\"\n   * });\n   * var boundSomeFunction = Rx.Observable.bindNodeCallback(someFunction, (a, b) => a + b);\n   * boundSomeFunction()\n   * .subscribe(value => {\n   *   console.log(value); // \"abcDEF\"\n   * });\n   *\n   *\n   * @example <caption>Use on function calling callback in regular style</caption>\n   * someFunction(a => {\n   *   console.log(a); // 5\n   * });\n   * var boundSomeFunction = Rx.Observable.bindNodeCallback(someFunction);\n   * boundSomeFunction()\n   * .subscribe(\n   *   value => {}             // never gets called\n   *   err => console.log(err) // 5\n   *);\n   *\n   *\n   * @see {@link bindCallback}\n   * @see {@link from}\n   * @see {@link fromPromise}\n   *\n   * @param {function} func Function with a Node.js-style callback as the last parameter.\n   * @param {function} [selector] A function which takes the arguments from the\n   * callback and maps those to a value to emit on the output Observable.\n   * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n   * callbacks.\n   * @return {function(...params: *): Observable} A function which returns the\n   * Observable that delivers the same values the Node.js callback would\n   * deliver.\n   * @static true\n   * @name bindNodeCallback\n   * @owner Observable\n   */\n\n\n  BoundNodeCallbackObservable.create = function (func, selector, scheduler) {\n    if (selector === void 0) {\n      selector = undefined;\n    }\n\n    return function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i - 0] = arguments[_i];\n      }\n\n      return new BoundNodeCallbackObservable(func, selector, args, this, scheduler);\n    };\n  };\n  /** @deprecated internal use only */\n\n\n  BoundNodeCallbackObservable.prototype._subscribe = function (subscriber) {\n    var callbackFunc = this.callbackFunc;\n    var args = this.args;\n    var scheduler = this.scheduler;\n    var subject = this.subject;\n\n    if (!scheduler) {\n      if (!subject) {\n        subject = this.subject = new AsyncSubject_1.AsyncSubject();\n\n        var handler = function handlerFn() {\n          var innerArgs = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            innerArgs[_i - 0] = arguments[_i];\n          }\n\n          var source = handlerFn.source;\n          var selector = source.selector,\n              subject = source.subject;\n          var err = innerArgs.shift();\n\n          if (err) {\n            subject.error(err);\n          } else if (selector) {\n            var result_1 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);\n\n            if (result_1 === errorObject_1.errorObject) {\n              subject.error(errorObject_1.errorObject.e);\n            } else {\n              subject.next(result_1);\n              subject.complete();\n            }\n          } else {\n            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);\n            subject.complete();\n          }\n        }; // use named function instance to avoid closure.\n\n\n        handler.source = this;\n        var result = tryCatch_1.tryCatch(callbackFunc).apply(this.context, args.concat(handler));\n\n        if (result === errorObject_1.errorObject) {\n          subject.error(errorObject_1.errorObject.e);\n        }\n      }\n\n      return subject.subscribe(subscriber);\n    } else {\n      return scheduler.schedule(dispatch, 0, {\n        source: this,\n        subscriber: subscriber,\n        context: this.context\n      });\n    }\n  };\n\n  return BoundNodeCallbackObservable;\n}(Observable_1.Observable);\n\nexports.BoundNodeCallbackObservable = BoundNodeCallbackObservable;\n\nfunction dispatch(state) {\n  var self = this;\n  var source = state.source,\n      subscriber = state.subscriber,\n      context = state.context; // XXX: cast to `any` to access to the private field in `source`.\n\n  var _a = source,\n      callbackFunc = _a.callbackFunc,\n      args = _a.args,\n      scheduler = _a.scheduler;\n  var subject = source.subject;\n\n  if (!subject) {\n    subject = source.subject = new AsyncSubject_1.AsyncSubject();\n\n    var handler = function handlerFn() {\n      var innerArgs = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        innerArgs[_i - 0] = arguments[_i];\n      }\n\n      var source = handlerFn.source;\n      var selector = source.selector,\n          subject = source.subject;\n      var err = innerArgs.shift();\n\n      if (err) {\n        self.add(scheduler.schedule(dispatchError, 0, {\n          err: err,\n          subject: subject\n        }));\n      } else if (selector) {\n        var result_2 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);\n\n        if (result_2 === errorObject_1.errorObject) {\n          self.add(scheduler.schedule(dispatchError, 0, {\n            err: errorObject_1.errorObject.e,\n            subject: subject\n          }));\n        } else {\n          self.add(scheduler.schedule(dispatchNext, 0, {\n            value: result_2,\n            subject: subject\n          }));\n        }\n      } else {\n        var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;\n        self.add(scheduler.schedule(dispatchNext, 0, {\n          value: value,\n          subject: subject\n        }));\n      }\n    }; // use named function to pass values in without closure\n\n\n    handler.source = source;\n    var result = tryCatch_1.tryCatch(callbackFunc).apply(context, args.concat(handler));\n\n    if (result === errorObject_1.errorObject) {\n      self.add(scheduler.schedule(dispatchError, 0, {\n        err: errorObject_1.errorObject.e,\n        subject: subject\n      }));\n    }\n  }\n\n  self.add(subject.subscribe(subscriber));\n}\n\nfunction dispatchNext(arg) {\n  var value = arg.value,\n      subject = arg.subject;\n  subject.next(value);\n  subject.complete();\n}\n\nfunction dispatchError(arg) {\n  var err = arg.err,\n      subject = arg.subject;\n  subject.error(err);\n}","map":{"version":3,"sources":["../../src/observable/BoundNodeCallbackObservable.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { IScheduler } from '../Scheduler';\nimport { Action } from '../scheduler/Action';\nimport { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\nimport { AsyncSubject } from '../AsyncSubject';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class BoundNodeCallbackObservable<T> extends Observable<T> {\n  subject: AsyncSubject<T>;\n\n  /* tslint:disable:max-line-length */\n  static create<R>(callbackFunc: (callback: (err: any, result: R) => any) => any, selector?: void, scheduler?: IScheduler): () => Observable<R>;\n  static create<T, R>(callbackFunc: (v1: T, callback: (err: any, result: R) => any) => any, selector?: void, scheduler?: IScheduler): (v1: T) => Observable<R>;\n  static create<T, T2, R>(callbackFunc: (v1: T, v2: T2, callback: (err: any, result: R) => any) => any, selector?: void, scheduler?: IScheduler): (v1: T, v2: T2) => Observable<R>;\n  static create<T, T2, T3, R>(callbackFunc: (v1: T, v2: T2, v3: T3, callback: (err: any, result: R) => any) => any, selector?: void, scheduler?: IScheduler): (v1: T, v2: T2, v3: T3) => Observable<R>;\n  static create<T, T2, T3, T4, R>(callbackFunc: (v1: T, v2: T2, v3: T3, v4: T4, callback: (err: any, result: R) => any) => any, selector?: void, scheduler?: IScheduler): (v1: T, v2: T2, v3: T3, v4: T4) => Observable<R>;\n  static create<T, T2, T3, T4, T5, R>(callbackFunc: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, callback: (err: any, result: R) => any) => any, selector?: void, scheduler?: IScheduler): (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => Observable<R>;\n  static create<T, T2, T3, T4, T5, T6, R>(callbackFunc: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6, callback: (err: any, result: R) => any) => any, selector?: void, scheduler?: IScheduler): (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => Observable<R>;\n  static create<T>(callbackFunc: Function, selector?: void, scheduler?: IScheduler): (...args: any[]) => Observable<T>;\n  static create<T>(callbackFunc: Function, selector?: (...args: any[]) => T, scheduler?: IScheduler): (...args: any[]) => Observable<T>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Converts a Node.js-style callback API to a function that returns an\n   * Observable.\n   *\n   * <span class=\"informal\">It's just like {@link bindCallback}, but the\n   * callback is expected to be of type `callback(error, result)`.</span>\n   *\n   * `bindNodeCallback` is not an operator because its input and output are not\n   * Observables. The input is a function `func` with some parameters, but the\n   * last parameter must be a callback function that `func` calls when it is\n   * done. The callback function is expected to follow Node.js conventions,\n   * where the first argument to the callback is an error object, signaling\n   * whether call was successful. If that object is passed to callback, it means\n   * something went wrong.\n   *\n   * The output of `bindNodeCallback` is a function that takes the same\n   * parameters as `func`, except the last one (the callback). When the output\n   * function is called with arguments, it will return an Observable.\n   * If `func` calls its callback with error parameter present, Observable will\n   * error with that value as well. If error parameter is not passed, Observable will emit\n   * second parameter. If there are more parameters (third and so on),\n   * Observable will emit an array with all arguments, except first error argument.\n   *\n   * Optionally `bindNodeCallback` accepts selector function, which allows you to\n   * make resulting Observable emit value computed by selector, instead of regular\n   * callback arguments. It works similarly to {@link bindCallback} selector, but\n   * Node.js-style error argument will never be passed to that function.\n   *\n   * Note that `func` will not be called at the same time output function is,\n   * but rather whenever resulting Observable is subscribed. By default call to\n   * `func` will happen synchronously after subscription, but that can be changed\n   * with proper {@link Scheduler} provided as optional third parameter. Scheduler\n   * can also control when values from callback will be emitted by Observable.\n   * To find out more, check out documentation for {@link bindCallback}, where\n   * Scheduler works exactly the same.\n   *\n   * As in {@link bindCallback}, context (`this` property) of input function will be set to context\n   * of returned function, when it is called.\n   *\n   * After Observable emits value, it will complete immediately. This means\n   * even if `func` calls callback again, values from second and consecutive\n   * calls will never appear on the stream. If you need to handle functions\n   * that call callbacks multiple times, check out {@link fromEvent} or\n   * {@link fromEventPattern} instead.\n   *\n   * Note that `bindNodeCallback` can be used in non-Node.js environments as well.\n   * \"Node.js-style\" callbacks are just a convention, so if you write for\n   * browsers or any other environment and API you use implements that callback style,\n   * `bindNodeCallback` can be safely used on that API functions as well.\n   *\n   * Remember that Error object passed to callback does not have to be an instance\n   * of JavaScript built-in `Error` object. In fact, it does not even have to an object.\n   * Error parameter of callback function is interpreted as \"present\", when value\n   * of that parameter is truthy. It could be, for example, non-zero number, non-empty\n   * string or boolean `true`. In all of these cases resulting Observable would error\n   * with that value. This means usually regular style callbacks will fail very often when\n   * `bindNodeCallback` is used. If your Observable errors much more often then you\n   * would expect, check if callback really is called in Node.js-style and, if not,\n   * switch to {@link bindCallback} instead.\n   *\n   * Note that even if error parameter is technically present in callback, but its value\n   * is falsy, it still won't appear in array emitted by Observable or in selector function.\n   *\n   *\n   * @example <caption>Read a file from the filesystem and get the data as an Observable</caption>\n   * import * as fs from 'fs';\n   * var readFileAsObservable = Rx.Observable.bindNodeCallback(fs.readFile);\n   * var result = readFileAsObservable('./roadNames.txt', 'utf8');\n   * result.subscribe(x => console.log(x), e => console.error(e));\n   *\n   *\n   * @example <caption>Use on function calling callback with multiple arguments</caption>\n   * someFunction((err, a, b) => {\n   *   console.log(err); // null\n   *   console.log(a); // 5\n   *   console.log(b); // \"some string\"\n   * });\n   * var boundSomeFunction = Rx.Observable.bindNodeCallback(someFunction);\n   * boundSomeFunction()\n   * .subscribe(value => {\n   *   console.log(value); // [5, \"some string\"]\n   * });\n   *\n   *\n   * @example <caption>Use with selector function</caption>\n   * someFunction((err, a, b) => {\n   *   console.log(err); // undefined\n   *   console.log(a); // \"abc\"\n   *   console.log(b); // \"DEF\"\n   * });\n   * var boundSomeFunction = Rx.Observable.bindNodeCallback(someFunction, (a, b) => a + b);\n   * boundSomeFunction()\n   * .subscribe(value => {\n   *   console.log(value); // \"abcDEF\"\n   * });\n   *\n   *\n   * @example <caption>Use on function calling callback in regular style</caption>\n   * someFunction(a => {\n   *   console.log(a); // 5\n   * });\n   * var boundSomeFunction = Rx.Observable.bindNodeCallback(someFunction);\n   * boundSomeFunction()\n   * .subscribe(\n   *   value => {}             // never gets called\n   *   err => console.log(err) // 5\n   *);\n   *\n   *\n   * @see {@link bindCallback}\n   * @see {@link from}\n   * @see {@link fromPromise}\n   *\n   * @param {function} func Function with a Node.js-style callback as the last parameter.\n   * @param {function} [selector] A function which takes the arguments from the\n   * callback and maps those to a value to emit on the output Observable.\n   * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n   * callbacks.\n   * @return {function(...params: *): Observable} A function which returns the\n   * Observable that delivers the same values the Node.js callback would\n   * deliver.\n   * @static true\n   * @name bindNodeCallback\n   * @owner Observable\n   */\n  static create<T>(func: Function,\n                   selector: Function | void = undefined,\n                   scheduler?: IScheduler): (...args: any[]) => Observable<T> {\n    return function(this: any, ...args: any[]): Observable<T> {\n      return new BoundNodeCallbackObservable<T>(func, <any>selector, args, this, scheduler);\n    };\n  }\n\n  constructor(private callbackFunc: Function,\n              private selector: Function,\n              private args: any[],\n              private context: any,\n              public scheduler: IScheduler) {\n    super();\n  }\n\n  /** @deprecated internal use only */ _subscribe(subscriber: Subscriber<T | T[]>): Subscription {\n    const callbackFunc = this.callbackFunc;\n    const args = this.args;\n    const scheduler = this.scheduler;\n    let subject = this.subject;\n\n    if (!scheduler) {\n      if (!subject) {\n        subject = this.subject = new AsyncSubject<T>();\n        const handler = function handlerFn(this: any, ...innerArgs: any[]) {\n          const source = (<any>handlerFn).source;\n          const { selector, subject } = source;\n          const err = innerArgs.shift();\n\n          if (err) {\n            subject.error(err);\n          } else if (selector) {\n            const result = tryCatch(selector).apply(this, innerArgs);\n            if (result === errorObject) {\n              subject.error(errorObject.e);\n            } else {\n              subject.next(result);\n              subject.complete();\n            }\n          } else {\n            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);\n            subject.complete();\n          }\n        };\n        // use named function instance to avoid closure.\n        (<any>handler).source = this;\n\n        const result = tryCatch(callbackFunc).apply(this.context, args.concat(handler));\n        if (result === errorObject) {\n          subject.error(errorObject.e);\n        }\n      }\n      return subject.subscribe(subscriber);\n    } else {\n      return scheduler.schedule(dispatch, 0, { source: this, subscriber, context: this.context });\n    }\n  }\n}\n\ninterface DispatchState<T> {\n  source: BoundNodeCallbackObservable<T>;\n  subscriber: Subscriber<T>;\n  context: any;\n}\n\nfunction dispatch<T>(this: Action<DispatchState<T>>, state: DispatchState<T>) {\n  const self = (<Subscription> this);\n  const { source, subscriber, context } = state;\n  // XXX: cast to `any` to access to the private field in `source`.\n  const { callbackFunc, args, scheduler } = source as any;\n  let subject = source.subject;\n\n  if (!subject) {\n    subject = source.subject = new AsyncSubject<T>();\n\n    const handler = function handlerFn(this: any, ...innerArgs: any[]) {\n      const source = (<any>handlerFn).source;\n      const { selector, subject } = source;\n      const err = innerArgs.shift();\n\n      if (err) {\n        self.add(scheduler.schedule(dispatchError, 0, { err, subject }));\n      } else if (selector) {\n        const result = tryCatch(selector).apply(this, innerArgs);\n        if (result === errorObject) {\n          self.add(scheduler.schedule(dispatchError, 0, { err: errorObject.e, subject }));\n        } else {\n          self.add(scheduler.schedule(dispatchNext, 0, { value: result, subject }));\n        }\n      } else {\n        const value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;\n        self.add(scheduler.schedule(dispatchNext, 0, { value, subject }));\n      }\n    };\n    // use named function to pass values in without closure\n    (<any>handler).source = source;\n\n    const result = tryCatch(callbackFunc).apply(context, args.concat(handler));\n    if (result === errorObject) {\n      self.add(scheduler.schedule(dispatchError, 0, { err: errorObject.e, subject }));\n    }\n  }\n\n  self.add(subject.subscribe(subscriber));\n}\n\ninterface DispatchNextArg<T> {\n  subject: AsyncSubject<T>;\n  value: T;\n}\nfunction dispatchNext<T>(arg: DispatchNextArg<T>) {\n  const { value, subject } = arg;\n  subject.next(value);\n  subject.complete();\n}\n\ninterface DispatchErrorArg<T> {\n  subject: AsyncSubject<T>;\n  err: any;\n}\nfunction dispatchError<T>(arg: DispatchErrorArg<T>) {\n  const { err, subject } = arg;\n  subject.error(err);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}