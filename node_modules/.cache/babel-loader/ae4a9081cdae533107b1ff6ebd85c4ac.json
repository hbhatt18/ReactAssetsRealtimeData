{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar OuterSubscriber_1 = require('../OuterSubscriber');\n\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.\n *\n * <img src=\"./img/skipUntil.png\" width=\"100%\">\n *\n * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to\n * be mirrored by the resulting Observable.\n * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits\n * an item, then emits the remaining items.\n * @method skipUntil\n * @owner Observable\n */\n\n\nfunction skipUntil(notifier) {\n  return function (source) {\n    return source.lift(new SkipUntilOperator(notifier));\n  };\n}\n\nexports.skipUntil = skipUntil;\n\nvar SkipUntilOperator = function () {\n  function SkipUntilOperator(notifier) {\n    this.notifier = notifier;\n  }\n\n  SkipUntilOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new SkipUntilSubscriber(subscriber, this.notifier));\n  };\n\n  return SkipUntilOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar SkipUntilSubscriber = function (_super) {\n  __extends(SkipUntilSubscriber, _super);\n\n  function SkipUntilSubscriber(destination, notifier) {\n    _super.call(this, destination);\n\n    this.hasValue = false;\n    this.isInnerStopped = false;\n    this.add(subscribeToResult_1.subscribeToResult(this, notifier));\n  }\n\n  SkipUntilSubscriber.prototype._next = function (value) {\n    if (this.hasValue) {\n      _super.prototype._next.call(this, value);\n    }\n  };\n\n  SkipUntilSubscriber.prototype._complete = function () {\n    if (this.isInnerStopped) {\n      _super.prototype._complete.call(this);\n    } else {\n      this.unsubscribe();\n    }\n  };\n\n  SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    this.hasValue = true;\n  };\n\n  SkipUntilSubscriber.prototype.notifyComplete = function () {\n    this.isInnerStopped = true;\n\n    if (this.isStopped) {\n      _super.prototype._complete.call(this);\n    }\n  };\n\n  return SkipUntilSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);","map":{"version":3,"sources":["../../src/operators/skipUntil.ts"],"names":[],"mappings":";;;;;;;;;;;;AAIA,IAAA,iBAAA,GAAA,OAAA,CAAgC,oBAAhC,CAAA;;AAEA,IAAA,mBAAA,GAAA,OAAA,CAAkC,2BAAlC,CAAA;AAGA;;;;;;;;;;;;;;AAYA,SAAA,SAAA,CAA6B,QAA7B,EAAsD;AACpD,SAAO,UAAC,MAAD,EAAsB;AAAK,WAAA,MAAM,CAAC,IAAP,CAAY,IAAI,iBAAJ,CAAZ,QAAY,CAAZ,CAAA;AAA4C,GAA9E;AACD;;AAFe,OAAA,CAAA,SAAA,GAAS,SAAT;;AAIhB,IAAA,iBAAA,GAAA,YAAA;AACE,WAAA,iBAAA,CAAoB,QAApB,EAA6C;AAAzB,SAAA,QAAA,GAAA,QAAA;AACnB;;AAED,EAAA,iBAAA,CAAA,SAAA,CAAA,IAAA,GAAA,UAAK,UAAL,EAAgC,MAAhC,EAA2C;AACzC,WAAO,MAAM,CAAC,SAAP,CAAiB,IAAI,mBAAJ,CAAwB,UAAxB,EAAoC,KAAK,QAAzC,CAAjB,CAAP;AACD,GAFD;;AAGF,SAAA,iBAAA;AAAC,CAPD,EAAA;AASA;;;;;;;AAKA,IAAA,mBAAA,GAAA,UAAA,MAAA,EAAA;AAAwC,EAAA,SAAA,CAAA,mBAAA,EAAA,MAAA,CAAA;;AAKtC,WAAA,mBAAA,CAAY,WAAZ,EACY,QADZ,EACqC;AACnC,IAAA,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,WAAN;;AALM,SAAA,QAAA,GAAoB,KAApB;AACA,SAAA,cAAA,GAA0B,KAA1B;AAKN,SAAK,GAAL,CAAS,mBAAA,CAAA,iBAAA,CAAkB,IAAlB,EAAwB,QAAxB,CAAT;AACD;;AAES,EAAA,mBAAA,CAAA,SAAA,CAAA,KAAA,GAAV,UAAgB,KAAhB,EAAwB;AACtB,QAAI,KAAK,QAAT,EAAmB;AACjB,MAAA,MAAA,CAAA,SAAA,CAAM,KAAN,CAAW,IAAX,CAAW,IAAX,EAAY,KAAZ;AACD;AACF,GAJS;;AAMA,EAAA,mBAAA,CAAA,SAAA,CAAA,SAAA,GAAV,YAAA;AACE,QAAI,KAAK,cAAT,EAAyB;AACvB,MAAA,MAAA,CAAA,SAAA,CAAM,SAAN,CAAe,IAAf,CAAe,IAAf;AACD,KAFD,MAEO;AACL,WAAK,WAAL;AACD;AACF,GANS;;AAQV,EAAA,mBAAA,CAAA,SAAA,CAAA,UAAA,GAAA,UAAW,UAAX,EAA0B,UAA1B,EACW,UADX,EAC+B,UAD/B,EAEW,QAFX,EAE0C;AACxC,SAAK,QAAL,GAAgB,IAAhB;AACD,GAJD;;AAMA,EAAA,mBAAA,CAAA,SAAA,CAAA,cAAA,GAAA,YAAA;AACE,SAAK,cAAL,GAAsB,IAAtB;;AACA,QAAI,KAAK,SAAT,EAAoB;AAClB,MAAA,MAAA,CAAA,SAAA,CAAM,SAAN,CAAe,IAAf,CAAe,IAAf;AACD;AACF,GALD;;AAMF,SAAA,mBAAA;AAAC,CArCD,CAAwC,iBAAA,CAAA,eAAxC,CAAA","sourcesContent":["import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { TeardownLogic } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.\n *\n * <img src=\"./img/skipUntil.png\" width=\"100%\">\n *\n * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to\n * be mirrored by the resulting Observable.\n * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits\n * an item, then emits the remaining items.\n * @method skipUntil\n * @owner Observable\n */\nexport function skipUntil<T>(notifier: Observable<any>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new SkipUntilOperator(notifier));\n}\n\nclass SkipUntilOperator<T> implements Operator<T, T> {\n  constructor(private notifier: Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new SkipUntilSubscriber(subscriber, this.notifier));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SkipUntilSubscriber<T, R> extends OuterSubscriber<T, R> {\n\n  private hasValue: boolean = false;\n  private isInnerStopped: boolean = false;\n\n  constructor(destination: Subscriber<any>,\n              notifier: Observable<any>) {\n    super(destination);\n    this.add(subscribeToResult(this, notifier));\n  }\n\n  protected _next(value: T) {\n    if (this.hasValue) {\n      super._next(value);\n    }\n  }\n\n  protected _complete() {\n    if (this.isInnerStopped) {\n      super._complete();\n    } else {\n      this.unsubscribe();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.hasValue = true;\n  }\n\n  notifyComplete(): void {\n    this.isInnerStopped = true;\n    if (this.isStopped) {\n      super._complete();\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}