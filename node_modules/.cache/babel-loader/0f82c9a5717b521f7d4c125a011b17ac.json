{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = require('../Subscriber');\n\nvar EmptyError_1 = require('../util/EmptyError');\n/**\n * Emits only the first value (or the first value that meets some condition)\n * emitted by the source Observable.\n *\n * <span class=\"informal\">Emits only the first value. Or emits only the first\n * value that passes some test.</span>\n *\n * <img src=\"./img/first.png\" width=\"100%\">\n *\n * If called with no arguments, `first` emits the first value of the source\n * Observable, then completes. If called with a `predicate` function, `first`\n * emits the first value of the source that matches the specified condition. It\n * may also take a `resultSelector` function to produce the output value from\n * the input value, and a `defaultValue` to emit in case the source completes\n * before it is able to emit a valid value. Throws an error if `defaultValue`\n * was not provided and a matching element is not found.\n *\n * @example <caption>Emit only the first click that happens on the DOM</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first();\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Emits the first click that happens on a DIV</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link take}\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]\n * An optional function called with each item to test for condition matching.\n * @param {function(value: T, index: number): R} [resultSelector] A function to\n * produce the value on the output Observable based on the values\n * and the indices of the source Observable. The arguments passed to this\n * function are:\n * - `value`: the value that was emitted on the source.\n * - `index`: the \"index\" of the value from the source.\n * @param {R} [defaultValue] The default value emitted in case no valid value\n * was found on the source.\n * @return {Observable<T|R>} An Observable of the first item that matches the\n * condition.\n * @method first\n * @owner Observable\n */\n\n\nfunction first(predicate, resultSelector, defaultValue) {\n  return function (source) {\n    return source.lift(new FirstOperator(predicate, resultSelector, defaultValue, source));\n  };\n}\n\nexports.first = first;\n\nvar FirstOperator = function () {\n  function FirstOperator(predicate, resultSelector, defaultValue, source) {\n    this.predicate = predicate;\n    this.resultSelector = resultSelector;\n    this.defaultValue = defaultValue;\n    this.source = source;\n  }\n\n  FirstOperator.prototype.call = function (observer, source) {\n    return source.subscribe(new FirstSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));\n  };\n\n  return FirstOperator;\n}();\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar FirstSubscriber = function (_super) {\n  __extends(FirstSubscriber, _super);\n\n  function FirstSubscriber(destination, predicate, resultSelector, defaultValue, source) {\n    _super.call(this, destination);\n\n    this.predicate = predicate;\n    this.resultSelector = resultSelector;\n    this.defaultValue = defaultValue;\n    this.source = source;\n    this.index = 0;\n    this.hasCompleted = false;\n    this._emitted = false;\n  }\n\n  FirstSubscriber.prototype._next = function (value) {\n    var index = this.index++;\n\n    if (this.predicate) {\n      this._tryPredicate(value, index);\n    } else {\n      this._emit(value, index);\n    }\n  };\n\n  FirstSubscriber.prototype._tryPredicate = function (value, index) {\n    var result;\n\n    try {\n      result = this.predicate(value, index, this.source);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    if (result) {\n      this._emit(value, index);\n    }\n  };\n\n  FirstSubscriber.prototype._emit = function (value, index) {\n    if (this.resultSelector) {\n      this._tryResultSelector(value, index);\n\n      return;\n    }\n\n    this._emitFinal(value);\n  };\n\n  FirstSubscriber.prototype._tryResultSelector = function (value, index) {\n    var result;\n\n    try {\n      result = this.resultSelector(value, index);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    this._emitFinal(result);\n  };\n\n  FirstSubscriber.prototype._emitFinal = function (value) {\n    var destination = this.destination;\n\n    if (!this._emitted) {\n      this._emitted = true;\n      destination.next(value);\n      destination.complete();\n      this.hasCompleted = true;\n    }\n  };\n\n  FirstSubscriber.prototype._complete = function () {\n    var destination = this.destination;\n\n    if (!this.hasCompleted && typeof this.defaultValue !== 'undefined') {\n      destination.next(this.defaultValue);\n      destination.complete();\n    } else if (!this.hasCompleted) {\n      destination.error(new EmptyError_1.EmptyError());\n    }\n  };\n\n  return FirstSubscriber;\n}(Subscriber_1.Subscriber);","map":{"version":3,"sources":["../../src/operators/first.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { EmptyError } from '../util/EmptyError';\nimport { OperatorFunction, MonoTypeOperatorFunction } from '../interfaces';\n/* tslint:disable:max-line-length */\nexport function first<T, S extends T>(predicate: (value: T, index: number, source: Observable<T>) => value is S): OperatorFunction<T, S>;\nexport function first<T, S extends T, R>(predicate: (value: T | S, index: number, source: Observable<T>) => value is S,\n                                         resultSelector: (value: S, index: number) => R, defaultValue?: R): OperatorFunction<T, R>;\nexport function first<T, S extends T>(predicate: (value: T, index: number, source: Observable<T>) => value is S,\n                                      resultSelector: void,\n                                      defaultValue?: S): OperatorFunction<T, S>;\nexport function first<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): MonoTypeOperatorFunction<T>;\nexport function first<T, R>(predicate: (value: T, index: number, source: Observable<T>) => boolean,\n                            resultSelector?: (value: T, index: number) => R,\n                            defaultValue?: R): OperatorFunction<T, R>;\nexport function first<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean,\n                         resultSelector: void,\n                         defaultValue?: T): MonoTypeOperatorFunction<T>;\n\n/**\n * Emits only the first value (or the first value that meets some condition)\n * emitted by the source Observable.\n *\n * <span class=\"informal\">Emits only the first value. Or emits only the first\n * value that passes some test.</span>\n *\n * <img src=\"./img/first.png\" width=\"100%\">\n *\n * If called with no arguments, `first` emits the first value of the source\n * Observable, then completes. If called with a `predicate` function, `first`\n * emits the first value of the source that matches the specified condition. It\n * may also take a `resultSelector` function to produce the output value from\n * the input value, and a `defaultValue` to emit in case the source completes\n * before it is able to emit a valid value. Throws an error if `defaultValue`\n * was not provided and a matching element is not found.\n *\n * @example <caption>Emit only the first click that happens on the DOM</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first();\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Emits the first click that happens on a DIV</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.first(ev => ev.target.tagName === 'DIV');\n * result.subscribe(x => console.log(x));\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link take}\n *\n * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n *\n * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]\n * An optional function called with each item to test for condition matching.\n * @param {function(value: T, index: number): R} [resultSelector] A function to\n * produce the value on the output Observable based on the values\n * and the indices of the source Observable. The arguments passed to this\n * function are:\n * - `value`: the value that was emitted on the source.\n * - `index`: the \"index\" of the value from the source.\n * @param {R} [defaultValue] The default value emitted in case no valid value\n * was found on the source.\n * @return {Observable<T|R>} An Observable of the first item that matches the\n * condition.\n * @method first\n * @owner Observable\n */\nexport function first<T, R>(predicate?: (value: T, index: number, source: Observable<T>) => boolean,\n                            resultSelector?: ((value: T, index: number) => R) | void,\n                            defaultValue?: R): OperatorFunction<T, T | R> {\n  return (source: Observable<T>) => source.lift(new FirstOperator(predicate, resultSelector, defaultValue, source));\n}\n\nclass FirstOperator<T, R> implements Operator<T, R> {\n  constructor(private predicate?: (value: T, index: number, source: Observable<T>) => boolean,\n              private resultSelector?: ((value: T, index: number) => R) | void,\n              private defaultValue?: any,\n              private source?: Observable<T>) {\n  }\n\n  call(observer: Subscriber<R>, source: any): any {\n    return source.subscribe(new FirstSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass FirstSubscriber<T, R> extends Subscriber<T> {\n  private index: number = 0;\n  private hasCompleted: boolean = false;\n  private _emitted: boolean = false;\n\n  constructor(destination: Subscriber<R>,\n              private predicate?: (value: T, index: number, source: Observable<T>) => boolean,\n              private resultSelector?: ((value: T, index: number) => R) | void,\n              private defaultValue?: any,\n              private source?: Observable<T>) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    const index = this.index++;\n    if (this.predicate) {\n      this._tryPredicate(value, index);\n    } else {\n      this._emit(value, index);\n    }\n  }\n\n  private _tryPredicate(value: T, index: number) {\n    let result: any;\n    try {\n      result = this.predicate(value, index, this.source);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    if (result) {\n      this._emit(value, index);\n    }\n  }\n\n  private _emit(value: any, index: number) {\n    if (this.resultSelector) {\n      this._tryResultSelector(value, index);\n      return;\n    }\n    this._emitFinal(value);\n  }\n\n  private _tryResultSelector(value: T, index: number) {\n    let result: any;\n    try {\n      result = (<any>this).resultSelector(value, index);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this._emitFinal(result);\n  }\n\n  private _emitFinal(value: any) {\n    const destination = this.destination;\n    if (!this._emitted) {\n      this._emitted = true;\n      destination.next(value);\n      destination.complete();\n      this.hasCompleted = true;\n    }\n  }\n\n  protected _complete(): void {\n    const destination = this.destination;\n    if (!this.hasCompleted && typeof this.defaultValue !== 'undefined') {\n      destination.next(this.defaultValue);\n      destination.complete();\n    } else if (!this.hasCompleted) {\n      destination.error(new EmptyError);\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}