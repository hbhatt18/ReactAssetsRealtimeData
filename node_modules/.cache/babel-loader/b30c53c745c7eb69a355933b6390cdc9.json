{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Observable_1 = require('../Observable');\n\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n\nvar OuterSubscriber_1 = require('../OuterSubscriber');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar DeferObservable = function (_super) {\n  __extends(DeferObservable, _super);\n\n  function DeferObservable(observableFactory) {\n    _super.call(this);\n\n    this.observableFactory = observableFactory;\n  }\n  /**\n   * Creates an Observable that, on subscribe, calls an Observable factory to\n   * make an Observable for each new Observer.\n   *\n   * <span class=\"informal\">Creates the Observable lazily, that is, only when it\n   * is subscribed.\n   * </span>\n   *\n   * <img src=\"./img/defer.png\" width=\"100%\">\n   *\n   * `defer` allows you to create the Observable only when the Observer\n   * subscribes, and create a fresh Observable for each Observer. It waits until\n   * an Observer subscribes to it, and then it generates an Observable,\n   * typically with an Observable factory function. It does this afresh for each\n   * subscriber, so although each subscriber may think it is subscribing to the\n   * same Observable, in fact each subscriber gets its own individual\n   * Observable.\n   *\n   * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>\n   * var clicksOrInterval = Rx.Observable.defer(function () {\n   *   if (Math.random() > 0.5) {\n   *     return Rx.Observable.fromEvent(document, 'click');\n   *   } else {\n   *     return Rx.Observable.interval(1000);\n   *   }\n   * });\n   * clicksOrInterval.subscribe(x => console.log(x));\n   *\n   * // Results in the following behavior:\n   * // If the result of Math.random() is greater than 0.5 it will listen\n   * // for clicks anywhere on the \"document\"; when document is clicked it\n   * // will log a MouseEvent object to the console. If the result is less\n   * // than 0.5 it will emit ascending numbers, one every second(1000ms).\n   *\n   * @see {@link create}\n   *\n   * @param {function(): SubscribableOrPromise} observableFactory The Observable\n   * factory function to invoke for each Observer that subscribes to the output\n   * Observable. May also return a Promise, which will be converted on the fly\n   * to an Observable.\n   * @return {Observable} An Observable whose Observers' subscriptions trigger\n   * an invocation of the given Observable factory function.\n   * @static true\n   * @name defer\n   * @owner Observable\n   */\n\n\n  DeferObservable.create = function (observableFactory) {\n    return new DeferObservable(observableFactory);\n  };\n  /** @deprecated internal use only */\n\n\n  DeferObservable.prototype._subscribe = function (subscriber) {\n    return new DeferSubscriber(subscriber, this.observableFactory);\n  };\n\n  return DeferObservable;\n}(Observable_1.Observable);\n\nexports.DeferObservable = DeferObservable;\n\nvar DeferSubscriber = function (_super) {\n  __extends(DeferSubscriber, _super);\n\n  function DeferSubscriber(destination, factory) {\n    _super.call(this, destination);\n\n    this.factory = factory;\n    this.tryDefer();\n  }\n\n  DeferSubscriber.prototype.tryDefer = function () {\n    try {\n      this._callFactory();\n    } catch (err) {\n      this._error(err);\n    }\n  };\n\n  DeferSubscriber.prototype._callFactory = function () {\n    var result = this.factory();\n\n    if (result) {\n      this.add(subscribeToResult_1.subscribeToResult(this, result));\n    }\n  };\n\n  return DeferSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);","map":{"version":3,"sources":["../../src/observable/DeferObservable.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,IAAA,YAAA,GAAA,OAAA,CAAkD,eAAlD,CAAA;;AAIA,IAAA,mBAAA,GAAA,OAAA,CAAkC,2BAAlC,CAAA;;AACA,IAAA,iBAAA,GAAA,OAAA,CAAgC,oBAAhC,CAAA;AACA;;;;;;;AAKA,IAAA,eAAA,GAAA,UAAA,MAAA,EAAA;AAAwC,EAAA,SAAA,CAAA,eAAA,EAAA,MAAA,CAAA;;AAoDtC,WAAA,eAAA,CAAoB,iBAApB,EAA4E;AAC1E,IAAA,MAAA,CAAA,IAAA,CAAA,IAAA;;AADkB,SAAA,iBAAA,GAAA,iBAAA;AAEnB;AApDD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8CO,EAAA,eAAA,CAAA,MAAA,GAAP,UAAiB,iBAAjB,EAAyE;AACvE,WAAO,IAAI,eAAJ,CAAoB,iBAApB,CAAP;AACD,GAFM;AAQP;;;AAAqC,EAAA,eAAA,CAAA,SAAA,CAAA,UAAA,GAAA,UAAW,UAAX,EAAoC;AACvE,WAAO,IAAI,eAAJ,CAAoB,UAApB,EAAgC,KAAK,iBAArC,CAAP;AACD,GAFoC;;AAGvC,SAAA,eAAA;AAAC,CA3DD,CAAwC,YAAA,CAAA,UAAxC,CAAA;;AAAa,OAAA,CAAA,eAAA,GAAe,eAAf;;AA6Db,IAAA,eAAA,GAAA,UAAA,MAAA,EAAA;AAAiC,EAAA,SAAA,CAAA,eAAA,EAAA,MAAA,CAAA;;AAC/B,WAAA,eAAA,CAAY,WAAZ,EACoB,OADpB,EACkE;AAChE,IAAA,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,WAAN;;AADkB,SAAA,OAAA,GAAA,OAAA;AAElB,SAAK,QAAL;AACD;;AAEO,EAAA,eAAA,CAAA,SAAA,CAAA,QAAA,GAAR,YAAA;AACE,QAAI;AACF,WAAK,YAAL;AACA,KAFF,CAEE,OAAO,GAAP,EAAY;AACZ,WAAK,MAAL,CAAY,GAAZ;AACD;AACF,GANO;;AAQA,EAAA,eAAA,CAAA,SAAA,CAAA,YAAA,GAAR,YAAA;AACE,QAAM,MAAM,GAAG,KAAK,OAAL,EAAf;;AACA,QAAI,MAAJ,EAAY;AACV,WAAK,GAAL,CAAS,mBAAA,CAAA,iBAAA,CAAkB,IAAlB,EAAwB,MAAxB,CAAT;AACD;AACF,GALO;;AAMV,SAAA,eAAA;AAAC,CArBD,CAAiC,iBAAA,CAAA,eAAjC,CAAA","sourcesContent":["import { Observable, SubscribableOrPromise } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\n\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OuterSubscriber } from '../OuterSubscriber';\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class DeferObservable<T> extends Observable<T> {\n\n  /**\n   * Creates an Observable that, on subscribe, calls an Observable factory to\n   * make an Observable for each new Observer.\n   *\n   * <span class=\"informal\">Creates the Observable lazily, that is, only when it\n   * is subscribed.\n   * </span>\n   *\n   * <img src=\"./img/defer.png\" width=\"100%\">\n   *\n   * `defer` allows you to create the Observable only when the Observer\n   * subscribes, and create a fresh Observable for each Observer. It waits until\n   * an Observer subscribes to it, and then it generates an Observable,\n   * typically with an Observable factory function. It does this afresh for each\n   * subscriber, so although each subscriber may think it is subscribing to the\n   * same Observable, in fact each subscriber gets its own individual\n   * Observable.\n   *\n   * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>\n   * var clicksOrInterval = Rx.Observable.defer(function () {\n   *   if (Math.random() > 0.5) {\n   *     return Rx.Observable.fromEvent(document, 'click');\n   *   } else {\n   *     return Rx.Observable.interval(1000);\n   *   }\n   * });\n   * clicksOrInterval.subscribe(x => console.log(x));\n   *\n   * // Results in the following behavior:\n   * // If the result of Math.random() is greater than 0.5 it will listen\n   * // for clicks anywhere on the \"document\"; when document is clicked it\n   * // will log a MouseEvent object to the console. If the result is less\n   * // than 0.5 it will emit ascending numbers, one every second(1000ms).\n   *\n   * @see {@link create}\n   *\n   * @param {function(): SubscribableOrPromise} observableFactory The Observable\n   * factory function to invoke for each Observer that subscribes to the output\n   * Observable. May also return a Promise, which will be converted on the fly\n   * to an Observable.\n   * @return {Observable} An Observable whose Observers' subscriptions trigger\n   * an invocation of the given Observable factory function.\n   * @static true\n   * @name defer\n   * @owner Observable\n   */\n  static create<T>(observableFactory: () => SubscribableOrPromise<T> | void): Observable<T> {\n    return new DeferObservable(observableFactory);\n  }\n\n  constructor(private observableFactory: () => SubscribableOrPromise<T> | void) {\n    super();\n  }\n\n  /** @deprecated internal use only */ _subscribe(subscriber: Subscriber<T>): Subscription {\n    return new DeferSubscriber(subscriber, this.observableFactory);\n  }\n}\n\nclass DeferSubscriber<T> extends OuterSubscriber<T, T> {\n  constructor(destination: Subscriber<T>,\n              private factory: () => SubscribableOrPromise<T> | void) {\n    super(destination);\n    this.tryDefer();\n  }\n\n  private tryDefer(): void {\n    try {\n      this._callFactory();\n    } catch (err) {\n      this._error(err);\n    }\n  }\n\n  private _callFactory(): void {\n    const result = this.factory();\n    if (result) {\n      this.add(subscribeToResult(this, result));\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}